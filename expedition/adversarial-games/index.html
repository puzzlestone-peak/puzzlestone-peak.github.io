<!DOCTYPE html><html lang="en" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1LM5FNK1VX"></script><meta name="color-scheme" content="dark light"/><link rel="preload" href="/assets/poppins-400-cpxAROuN.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-500-C8OXljZJ.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-600-zEkxB9Mr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-700-Qrb0O0WB.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Adversarial Games - Puzzlestone Peak</title><meta name="description" content="Learn how to analyse two-player, zero-sum games by building game trees,
classifying positions as winning or losing, and finding optimal strategies.
"/><meta property="og:title" content="Adversarial Games - Puzzlestone Peak"/><meta property="og:description" content="Learn how to analyse two-player, zero-sum games by building game trees,
classifying positions as winning or losing, and finding optimal strategies.
"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Adversarial Games - Puzzlestone Peak"/><meta name="twitter:description" content="Learn how to analyse two-player, zero-sum games by building game trees,
classifying positions as winning or losing, and finding optimal strategies.
"/><link rel="modulepreload" href="/assets/manifest-25fb394a.js"/><link rel="modulepreload" href="/assets/entry.client-BQEHofJp.js"/><link rel="modulepreload" href="/assets/index-DIth0oIc.js"/><link rel="modulepreload" href="/assets/root-BjuwspyJ.js"/><link rel="modulepreload" href="/assets/Logo-BRp-LhsU.js"/><link rel="modulepreload" href="/assets/use-dark-mode-mdHJdo6o.js"/><link rel="modulepreload" href="/assets/card-CeispfCi.js"/><link rel="modulepreload" href="/assets/NavHeightContext-BwIQMGhB.js"/><link rel="modulepreload" href="/assets/expeditionIndex-Dy75PiyG.js"/><link rel="modulepreload" href="/assets/puzzleIndex-CvT980ad.js"/><link rel="modulepreload" href="/assets/loader-circle-F5-c-Aqt.js"/><link rel="modulepreload" href="/assets/expedition-detail-3tRHBKcD.js"/><link rel="modulepreload" href="/assets/useBack-BDsmIQAJ.js"/><link rel="modulepreload" href="/assets/ItemCardList-DC-u4o5t.js"/><link rel="modulepreload" href="/assets/ErrorBoundary-Ch767kHG.js"/><link rel="modulepreload" href="/assets/chevron-left-CY6pwb5D.js"/><script>
              (function initTheme() {
                if (localStorage.getItem('darkmode') === '1') {
                  document.documentElement.classList.add('dark');
                }
              })();
            </script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-1LM5FNK1VX');
            </script><link rel="stylesheet" href="/assets/root-DvvwlXDE.css"/><link rel="stylesheet" href="/assets/useBack-CyAuISp2.css"/></head><body><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><div class="min-h-screen bg-background"><nav class="sticky top-0 z-[1000] border-b border-border bg-card"><div class="container mx-auto px-6"><div class="flex h-16 items-center justify-between"><a class="flex items-center gap-3 text-nav-foreground no-underline" href="/" data-discover="true"><svg class="h-10 w-10 text-nav-foreground" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2211.37 2208.98" aria-label="Puzzlestone Peak Logo"><g><g><path fill="currentColor" d="M1108.28,0c649.77,5.24,1114.13,533.8,1102.89,1120-11.85,618.13-493.23,1100.61-1128,1088.81C450,2197-8.61,1690.25.12,1087.2,8.81,487.59,492.57,4.1,1108.28,0ZM121.13,1114.76c1.14,543.44,432.5,984.51,996.37,978.51,557.06-5.93,978-444.2,971.35-995.6C2082,528.37,1628.73,114,1095.67,118.84,573.44,123.64,121,538.05,121.13,1114.76Z"></path><path fill="currentColor" d="M2021.18,1304.81c-125.17-118.57-243.11-238.8-364.9-359.1-2.56,14.24,1.92,24,3.82,33.95,4.41,23.07,11.61,45.81,13.73,69.05,4,43.53,24.59,76.14,55.56,106,57.17,55,111.85,112.69,167.64,169.19,3.08,3.11,6.78,5.62,13.43,11.07l-29.92-94c24.62,13.75,40.06,32.2,57.87,47.59,20.91,18.06,40.77,37.34,61.77,55.28,8.84,7.54,10.58,14.7,7.36,25.8-20.06,69.13-47.63,135-81.34,198.6-9.36,17.65-14.91,9.53-22.48,0q-90.9-114.8-181.89-229.53-95.47-120.15-191.27-240c-1-1.26-2.64-2-7-5.25,9.72,71.9,28.35,139.3,37.91,208.53-107.81-169.7-206.63-344.59-311.28-516-9.22,3.51-3.87,12.13-10,16-12-7.35-18.72-20.06-27.45-30.66q-45.4-55.15-89.63-111.28c-9.15-11.66-14.16-9.84-23.87.14-12.63,13-13.15,24.45-6.86,40.56,17.11,43.76,35.07,87.25,48.64,132.33,1,3.28,1.72,6.64,3.84,14.9L1022.35,771.4l-2.78,2.64c13.51,22.36,26.89,44.8,40.55,67.06,24.58,40.09,49,80.27,74.21,120,6,9.48,6,15.92-1.51,24.54-28.26,32.31-55.84,65.21-83.61,97.95-15.86,18.69-15.92,18.85,1.06,35.86q114.7,114.87,229.51,229.63c2.84,2.84,5.41,6,11.73,12.92-46.79-8.28-88.16-19-132.09-25.8l298,291.64,3.93-2.17L1430.53,1306c23.59,34.58,44.25,64.91,65,95.22q123.36,180.63,251.43,357.94c1.38,1.9,2.39,4.13,4,5.79,13.32,13.77,9.47,24-4.25,35.81-47.75,41.22-98,78.83-151.9,111.65-8.1,4.94-16.34,5.41-25.27,5.45-104.54.45-203.43-26.94-300.81-61.29-107-37.74-210.39-84.76-315.67-126.92-149.26-59.78-302.65-102.49-463-118.55-55.13-5.53-110.43-4.65-165.7-3.63-9.28.18-16.45-.49-22-10-61.64-105.06-105-216.59-122.31-337.73-1.51-10.61,1.49-17.46,8.71-24.81q184.24-187.54,367.82-375.72c10-10.28,15.36-7.56,23.67,1.12,35.77,37.39,72.31,74.05,108,111.53,8.31,8.73,13.08,10.25,21.86.21Q871.5,787.48,1033.71,603.54c21-23.84,42.59-47.13,63.21-71.27,8.62-10.09,13.52-8.08,21.52,1q195.46,222.81,391.26,445.32c9.78,11.18,14.44,10.28,23.92.32,36.07-37.91,73.29-74.72,109.47-112.54,8.26-8.63,13.09-7.71,20.87.25q175.07,179.21,350.85,357.7c13.23,13.39,20.15,25.9,13.9,44.57C2025.39,1278.84,2024.3,1289.49,2021.18,1304.81ZM564.41,931.41c0,18.05-1.59,31,.28,43.31,7.16,47.25-7.05,85.12-43.68,116.5-15.75,13.5-32.89,30.56-38.74,49.32-11,35.33-14.27,73.08-20.87,110.49,8.29-1,11-6.85,14.51-11.08q84.69-101.51,174.52-198.49c8.71-9.46,11.86-16.15.08-25.48-9.14-7.24-16.56-16.62-24.93-24.86C606.56,972.43,587.42,953.86,564.41,931.41Z"></path><path fill="currentColor" d="M1258,2036.19c-156.22,31.67-307.68,13.84-456-37.14-128-44-242.37-111.53-346.16-205.19,33.78-3.18,62.72.36,91.57,3.41,177.71,18.78,340.49,86.11,502.68,155.25,63.74,27.17,127.88,53.3,193.63,75.29C1248.52,2029.42,1254.05,2029.85,1258,2036.19Z"></path><path fill="currentColor" d="M1461.61,671.32c.48-75.58,59.09-133.3,135-132.91,69.62.35,129.18,61.43,128.77,132.05-.43,74-59.91,132.06-134.66,131.48C1518.42,801.37,1461.15,743.42,1461.61,671.32Z"></path></g></g></svg><span class="text-[1.25rem] font-semibold leading-none">Puzzlestone Peak</span></a><div class="hidden items-center gap-6 md:flex"><ul class="flex items-center gap-8"><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/progress" data-discover="true">Progress</a></li></ul><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div><button class="flex h-8 w-8 cursor-pointer flex-col justify-around border-none bg-transparent p-1 text-nav-foreground md:hidden" aria-label="Toggle mobile menu" aria-expanded="false" aria-controls="mobile-menu"><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span></button></div></div></nav><div id="mobile-menu" class="fixed left-0 right-0 top-16 z-[999] border-b border-border bg-card shadow-lg transition-all duration-300 md:hidden pointer-events-none -translate-y-full opacity-0"><div class="px-6 pb-6 pt-4"><ul class="flex flex-col gap-3"><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/progress" data-discover="true">Progress</a></li></ul><div class="mt-4 flex justify-center border-t border-border pt-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div></div></div><main><div class="container mx-auto px-4 py-6 max-w-4xl"><a class="inline-flex items-center gap-1.5 text-link hover:text-link-hover hover:underline mb-6 cursor-pointer" href="/expeditions" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left size-4" aria-hidden="true"><path d="m15 18-6-6 6-6"></path></svg>Back</a><div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-4"><h1 class="text-4xl font-bold text-foreground sm:flex-1">Adversarial Games</h1><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark expedition as complete">Mark as Complete</button></div><div class="space-y-4 border-b border-divider pb-6 mb-6"><div class="text-sm text-muted-foreground"><span>Created: <!-- -->February 9, 2026</span></div></div><div class="markdown-content prose max-w-none space-y-4"><p>In the context of puzzles, games typically refer to a scenario where players take turns to make a move, eventually leading to an outcome. The game is called adversarial if the players have conflicting goals. For example, if one player wins, the other must lose; they canâ€™t both win.</p>
<p>For this module, we shall only consider games with the following properties:</p>
<ul>
<li>The game involves 2 players.</li>
<li>Players will take turns to make a single move.</li>
<li>All sequences of moves eventually lead to one player winning. This means that there are no infinite games.</li>
<li>It is a zero-sum game: one player winning means the other must lose.</li>
<li>There are no ties: there must always be one player winning.</li>
<li>Deterministic: there are no elements of randomness. A particular sequence of moves from a particular game state will always result in the same final game state.</li>
</ul>
<p>The most general way to solve such games is to draw out the game tree. For instance, this is the game tree of Tic-Tac-Toe.</p>
<div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/expeditions/adversarial-games.md






































































































































function draw(options) {
  const { canvas, api, width } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Calculate responsive sizing - base unit for level 2 (smallest boards)
  const baseCellSize = Math.max(10, Math.min(30, width / 50));

  // Different sizes for each level
  const level2CellSize = baseCellSize;          // Level 2: base size (1x)
  const level1CellSize = baseCellSize * 1.5;      // Level 1: 1.5x bigger
  const level0CellSize = baseCellSize * 2;      // Level 0 (root): 2x bigger

  const level2BoardSize = level2CellSize * 3;
  const level1BoardSize = level1CellSize * 3;
  const level0BoardSize = level0CellSize * 3;

  const boardGap = level2CellSize * 0.5; // Gap between boards at level 2
  const levelHeight = level0BoardSize * 1.4; // Space between levels

  // Board state definitions (0 = empty, 1 = X, 2 = O)
  // Grid positions: 0=top-left, 1=top-mid, 2=top-right, 3=mid-left, 4=center, 5=mid-right, 6=bot-left, 7=bot-mid, 8=bot-right
  const boards = {
    A: [0, 0, 0, 0, 0, 0, 0, 0, 0],  // empty
    // Level 1: X first moves (corner, edge, center)
    B: [1, 0, 0, 0, 0, 0, 0, 0, 0],  // X__/___/___  (corner)
    C: [0, 1, 0, 0, 0, 0, 0, 0, 0],  // _X_/___/___  (edge)
    D: [0, 0, 0, 0, 1, 0, 0, 0, 0],  // ___/_X_/___  (center)
    // Children of B (corner X) - O responses
    E: [1, 0, 0, 2, 0, 0, 0, 0, 0],  // X__/O__/___
    F: [1, 0, 0, 0, 0, 0, 2, 0, 0],  // X__/___/O__
    G: [1, 0, 0, 0, 2, 0, 0, 0, 0],  // X__/_O_/___
    H: [1, 0, 0, 0, 0, 0, 0, 2, 0],  // X__/___/_O_
    I: [1, 0, 0, 0, 0, 0, 0, 0, 2],  // X__/___/__O
    // Children of C (edge X) - O responses
    J: [2, 1, 0, 0, 0, 0, 0, 0, 0],  // OX_/___/___
    K: [0, 1, 0, 2, 0, 0, 0, 0, 0],  // _X_/O__/___
    L: [0, 1, 0, 0, 0, 0, 2, 0, 0],  // _X_/___/O__
    M: [0, 1, 0, 0, 2, 0, 0, 0, 0],  // _X_/_O_/___
    N: [0, 1, 0, 0, 0, 0, 0, 2, 0],  // _X_/___/_O_
    // Children of D (center X) - O responses
    O: [2, 0, 0, 0, 1, 0, 0, 0, 0],  // O__/_X_/___
    P: [0, 2, 0, 0, 1, 0, 0, 0, 0],  // _O_/_X_/___
  };

  // Tree structure: each level 1 node has children at level 2
  const tree = [
    { board: &#x27;B&#x27;, children: [&#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;] },
    { board: &#x27;C&#x27;, children: [&#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;] },
    { board: &#x27;D&#x27;, children: [&#x27;O&#x27;, &#x27;P&#x27;] }
  ];

  // Calculate total width needed for level 2
  const level2Widths = tree.map(node =&gt; node.children.length * level2BoardSize + (node.children.length - 1) * boardGap);
  const groupGap = level2BoardSize * 0.75; // Gap between groups
  const totalLevel2Width = level2Widths.reduce((a, b) =&gt; a + b, 0) + (tree.length - 1) * groupGap;

  // Canvas dimensions
  const canvasWidth = Math.max(width, totalLevel2Width + level2BoardSize);
  const height = level0BoardSize + levelHeight * 2 + level2BoardSize + baseCellSize * 2;
  canvas.width = canvasWidth;
  canvas.height = height;

  // Get theme colors
  const fgColor = api.getColor(&#x27;foreground&#x27;);
  const mutedColor = api.getColor(&#x27;muted-foreground&#x27;);

  // Draw a single tic-tac-toe board (no label)
  // cellSz: cell size for this board
  function drawBoard(x, y, state, cellSz) {
    const brdSize = cellSz * 3;

    // Draw grid
    ctx.strokeStyle = mutedColor;
    ctx.lineWidth = 1;

    for (let i = 1; i &lt; 3; i++) {
      ctx.beginPath();
      ctx.moveTo(x + i * cellSz, y);
      ctx.lineTo(x + i * cellSz, y + brdSize);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x, y + i * cellSz);
      ctx.lineTo(x + brdSize, y + i * cellSz);
      ctx.stroke();
    }

    // Draw X&#x27;s and O&#x27;s
    for (let i = 0; i &lt; 9; i++) {
      const row = Math.floor(i / 3);
      const col = i % 3;
      const cellX = x + col * cellSz + cellSz / 2;
      const cellY = y + row * cellSz + cellSz / 2;

      if (state[i] === 1) {
        ctx.strokeStyle = fgColor;
        ctx.lineWidth = 2;
        const offset = cellSz * 0.25;
        ctx.beginPath();
        ctx.moveTo(cellX - offset, cellY - offset);
        ctx.lineTo(cellX + offset, cellY + offset);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cellX + offset, cellY - offset);
        ctx.lineTo(cellX - offset, cellY + offset);
        ctx.stroke();
      } else if (state[i] === 2) {
        ctx.strokeStyle = fgColor;
        ctx.lineWidth = 2;
        const radius = cellSz * 0.25;
        ctx.beginPath();
        ctx.arc(cellX, cellY, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    return { x: x + brdSize / 2, y: y + brdSize / 2, size: brdSize };
  }

  // Padding between board edges and connector lines
  const connectorPadding = baseCellSize * 0.4;

  // Draw connecting line (paler using reduced opacity)
  function drawLine(x1, y1, x2, y2) {
    ctx.strokeStyle = fgColor;
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
  }

  // Calculate positions for level 2 first (bottom-up layout)
  const level2Y = level0BoardSize + levelHeight * 2 - level2BoardSize;
  let currentX = (canvasWidth - totalLevel2Width) / 2;

  const level2Positions = [];
  const level1Centers = [];

  tree.forEach((node, groupIndex) =&gt; {
    const groupPositions = [];
    node.children.forEach((childBoard, childIndex) =&gt; {
      const x = currentX + childIndex * (level2BoardSize + boardGap);
      groupPositions.push({ board: childBoard, x, y: level2Y });
    });
    level2Positions.push(groupPositions);

    // Calculate level 1 center (above the middle of its children)
    const groupLeft = currentX;
    const groupRight = currentX + (node.children.length - 1) * (level2BoardSize + boardGap) + level2BoardSize;
    const level1CenterX = (groupLeft + groupRight) / 2;
    level1Centers.push({ board: node.board, centerX: level1CenterX });

    currentX = groupRight + groupGap;
  });

  // Level 1 Y position
  const level1Y = level0BoardSize + levelHeight - level1BoardSize / 2;

  // Level 0 (root) position - centered above level 1
  const rootX = canvasWidth / 2 - level0BoardSize / 2;
  const rootY = baseCellSize;
  const rootCenter = drawBoard(rootX, rootY, boards.A, level0CellSize);

  // Draw level 1 nodes and lines from root
  const level1Positions = level1Centers.map(item =&gt; ({
    board: item.board,
    x: item.centerX - level1BoardSize / 2,
    y: level1Y
  }));

  // Draw level 1 nodes with fanned-out lines from root
  const level1SpreadWidth = level0BoardSize * 0.6;
  level1Positions.forEach((pos, index) =&gt; {
    const center = drawBoard(pos.x, pos.y, boards[pos.board], level1CellSize);
    // Calculate spread-out start position on root board
    const numChildren = level1Positions.length;
    const startX = numChildren === 1
      ? rootCenter.x
      : rootCenter.x - level1SpreadWidth / 2 + (index * level1SpreadWidth / (numChildren - 1));
    drawLine(startX, rootCenter.y + level0BoardSize / 2 + connectorPadding, center.x, center.y - level1BoardSize / 2 - connectorPadding);
  });

  // Draw level 2 nodes and lines from level 1 with fanned-out connections
  // Spread width scales with number of children (max spread for 5 children)
  const maxSpreadWidth = level1BoardSize * 0.6;
  level2Positions.forEach((group, groupIndex) =&gt; {
    const parentPos = level1Positions[groupIndex];
    const parentCenter = { x: parentPos.x + level1BoardSize / 2, y: parentPos.y + level1BoardSize / 2 };

    const numChildren = group.length;
    // Scale spread based on number of children (fewer children = narrower spread)
    const level2SpreadWidth = numChildren &lt;= 1 ? 0 : maxSpreadWidth * (numChildren - 1) / 4;

    group.forEach((pos, childIndex) =&gt; {
      const center = drawBoard(pos.x, pos.y, boards[pos.board], level2CellSize);
      // Calculate spread-out start position on parent board
      const startX = numChildren === 1
        ? parentCenter.x
        : parentCenter.x - level2SpreadWidth / 2 + (childIndex * level2SpreadWidth / (numChildren - 1));
      drawLine(startX, parentCenter.y + level1BoardSize / 2 + connectorPadding, center.x, center.y - level2BoardSize / 2 - connectorPadding);
    });

    // Draw &quot;...&quot; below each group
    ctx.fillStyle = mutedColor;
    ctx.font = `${Math.max(12, baseCellSize)}px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.fillText(&#x27;...&#x27;, parentCenter.x, level2Y + level2BoardSize + baseCellSize);
  });
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Tic-tac-toe game tree showing first two levels of moves"></iframe></div>
<p>On the 1st level of the tree, we have one node (we call this the root node) that represents the gameâ€™s starting state. Each state branches out into possible states that can be reached as a result of the next playerâ€™s move. On the 1st, 3rd, 5th, â€¦ levels, the â€œXâ€ player is next to move. On the 2nd, 4th, 6th, â€¦ levels, the â€œOâ€ player is next to move.</p>
<p>Now that we have an understanding of how a game tree looks, letâ€™s consider a simpler game so we can analyse it:</p>
<p>You and your opponent have a stack of 4 coins: 3 iron coins and 1 gold coin at the bottom. On each playerâ€™s turn, they have to take 1 or 2 coins, with the goal being to take the golden coin. Youâ€™re going first. How do you ensure you get the golden coin?</p>
<p>Letâ€™s draw the game tree for this game. The red arrows represent the moves you can make, and the blue arrows represent your opponentâ€™s moves.</p>
<div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;stage&quot;:1};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/expeditions/adversarial-games.md































































































































































































































































































































































function draw(options) {
  const { canvas, api, width, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Stage: 1 = neutral, 2 = leaves colored + sample node, 3 = all colored
  const stage = props.stage || 1;

  // Theme colors
  const fgColor = api.getColor(&#x27;foreground&#x27;);
  const mutedColor = api.getColor(&#x27;muted-foreground&#x27;);
  const isLight = api.theme === &#x27;light&#x27;;
  const playerAColor = isLight ? api.getColor(&#x27;red-600&#x27;, { chroma: 0.05 }) : api.getColor(&#x27;red-300&#x27;, { chroma: 0.05 });
  const playerBColor = isLight ? api.getColor(&#x27;blue-600&#x27;, { chroma: 0.05 }) : api.getColor(&#x27;blue-300&#x27;, { chroma: 0.05 });

  // Responsive sizing
  const baseUnit = Math.max(12, Math.min(28, width / 30));
  const nodeRadius = baseUnit * 1.2;
  const font = api.getFont(&#x27;default&#x27;);

  // Tree data structure
  // winner: who ultimately wins from this position (computed via backward induction)
  // leafWinner: only on leaf nodes, who won the game at that terminal state
  const tree = {
    coins: 4, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
      { coins: 3, player: &#x27;B&#x27;, winner: &#x27;A&#x27;, children: [
        { coins: 2, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, annotation: true, children: [
          { coins: 1, player: &#x27;B&#x27;, winner: &#x27;B&#x27;, children: [
            { coins: 0, isLeaf: true, leafWinner: &#x27;B&#x27; }
          ]},
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]},
        { coins: 1, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]}
      ]},
      { coins: 2, player: &#x27;B&#x27;, winner: &#x27;B&#x27;, children: [
        { coins: 1, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]},
        { coins: 0, isLeaf: true, leafWinner: &#x27;B&#x27; }
      ]}
    ]
  };

  // Determine node color based on stage
  function getNodeColor(node) {
    if (stage === 1) return null; // neutral
    if (stage === 2) {
      if (node.isLeaf) return node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
      // Color internal nodes only if all descendants agree on winner
      const allDescendants = [];
      function collect(n) {
        if (n.isLeaf) { allDescendants.push(n.leafWinner); return; }
        if (n.children) n.children.forEach(collect);
      }
      collect(node);
      const allSame = allDescendants.every(w =&gt; w === allDescendants[0]);
      if (allSame) return allDescendants[0] === &#x27;A&#x27; ? playerAColor : playerBColor;
      return null;
    }
    // stage 3: all nodes colored by winner
    if (node.isLeaf) return node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
    return node.winner === &#x27;A&#x27; ? playerAColor : playerBColor;
  }

  // Layout calculations
  function countLeaves(node) {
    if (!node.children || node.children.length === 0) return 1;
    return node.children.reduce((sum, c) =&gt; sum + countLeaves(c), 0);
  }

  function getDepth(node) {
    if (!node.children || node.children.length === 0) return 0;
    return 1 + Math.max(...node.children.map(getDepth));
  }

  const totalLeaves = countLeaves(tree);
  const maxDepth = getDepth(tree);

  const hSpacing = nodeRadius * 4;
  const vSpacing = nodeRadius * 5;
  const topPadding = nodeRadius * 2;
  const bottomPadding = nodeRadius * 3;
  const annotationSpace = stage === 2 ? nodeRadius * 4 : 0;

  const treeWidth = (totalLeaves - 1) * hSpacing;
  const treeHeight = maxDepth * vSpacing;

  const canvasWidth = Math.max(width, treeWidth + nodeRadius * 4 + annotationSpace);
  const canvasHeight = treeHeight + topPadding + bottomPadding;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Assign positions bottom-up
  let leafIndex = 0;
  const treeLeft = (canvasWidth - treeWidth) / 2;

  function assignPositions(node, depth) {
    const y = topPadding + depth * vSpacing;
    if (!node.children || node.children.length === 0) {
      node.x = treeLeft + leafIndex * hSpacing;
      node.y = y;
      leafIndex++;
      return;
    }
    node.children.forEach(c =&gt; assignPositions(c, depth + 1));
    const childXs = node.children.map(c =&gt; c.x);
    node.x = (Math.min(...childXs) + Math.max(...childXs)) / 2;
    node.y = y;
  }

  assignPositions(tree, 0);

  // Draw arrow with arrowhead
  function drawArrow(x1, y1, x2, y2, color) {
    const headLen = baseUnit * 0.4;
    const angle = Math.atan2(y2 - y1, x2 - x1);
    const tipX = x2;
    const tipY = y2;

    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(tipX - headLen * Math.cos(angle), tipY - headLen * Math.sin(angle));
    ctx.stroke();

    // Arrowhead
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - headLen * Math.cos(angle - 0.35), tipY - headLen * Math.sin(angle - 0.35));
    ctx.lineTo(tipX - headLen * Math.cos(angle + 0.35), tipY - headLen * Math.sin(angle + 0.35));
    ctx.closePath();
    ctx.fill();
  }

  // Draw edges
  function drawEdges(node) {
    if (!node.children) return;
    node.children.forEach(child =&gt; {
      const edgeColor = node.player === &#x27;A&#x27; ? playerAColor : playerBColor;
      drawArrow(node.x, node.y + nodeRadius, child.x, child.y - nodeRadius, edgeColor);

      // Edge label: at midpoint of the line, offset to the side
      const coinsTaken = node.coins - child.coins;
      const labelSize = Math.max(9, baseUnit * 0.42);
      const lineHeight = labelSize * 1.4;
      ctx.font = `${labelSize}px ${font}`;
      ctx.fillStyle = edgeColor;
      ctx.textBaseline = &#x27;middle&#x27;;
      const midX = (node.x + child.x) / 2;
      const midY = (node.y + nodeRadius + child.y - nodeRadius) / 2;
      const numChildren = node.children.length;
      if (numChildren === 1) {
        // Single child: label to the right of the midpoint
        ctx.textAlign = &#x27;left&#x27;;
        ctx.fillText(`take ${coinsTaken}`, midX + lineHeight * 0.5, midY);
      } else {
        // Two children: left child label on left, right child label on right
        const isLeftChild = child.x &lt; node.x || (child.x === node.x &amp;&amp; node.children.indexOf(child) === 0);
        if (isLeftChild) {
          ctx.textAlign = &#x27;right&#x27;;
          ctx.fillText(`take ${coinsTaken}`, midX - lineHeight, midY);
        } else {
          ctx.textAlign = &#x27;left&#x27;;
          ctx.fillText(`take ${coinsTaken}`, midX + lineHeight, midY);
        }
      }

      drawEdges(child);
    });
  }

  drawEdges(tree);

  // Draw nodes
  function drawNode(node) {
    const { x, y } = node;
    const color = getNodeColor(node);
    const strokeColor = color || fgColor;
    const fillBgColor = color || fgColor;

    // Circle background
    ctx.fillStyle = fillBgColor;
    ctx.globalAlpha = color ? 0.15 : 0.04;
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // Circle border
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.stroke();

    // Coin count number
    const numSize = Math.max(12, baseUnit * 0.7);
    ctx.font = `bold ${numSize}px ${font}`;
    ctx.fillStyle = color || fgColor;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(`${node.coins}`, x, y - numSize * 0.15);

    // &quot;coins&quot; label below the number (inside the circle)
    const coinsLabelSize = Math.max(8, baseUnit * 0.38);
    ctx.font = `${coinsLabelSize}px ${font}`;
    ctx.fillStyle = color || fgColor;
    ctx.fillText(node.coins === 1 ? &#x27;coin&#x27; : &#x27;coins&#x27;, x, y + numSize * 0.45);

    // Below-node label: &quot;A wins&quot; / &quot;B wins&quot; for leaf nodes
    if (node.isLeaf) {
      const winColor = node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
      const winSize = Math.max(8, baseUnit * 0.4);
      ctx.font = `bold ${winSize}px ${font}`;
      ctx.fillStyle = stage === 1 ? fgColor : winColor;
      ctx.fillText(node.leafWinner === &#x27;A&#x27; ? &#x27;You win&#x27; : &#x27;Opponent wins&#x27;, x, y + nodeRadius + winSize * 1.2);
    }

    // Annotation arrow for sample node (stage 2 only)
    if (node.annotation &amp;&amp; stage === 2) {
      const arrowStartX = x - nodeRadius - baseUnit * 2;
      const arrowEndX = x - nodeRadius - baseUnit * 0.4;
      const arrowY = y;

      ctx.strokeStyle = fgColor;
      ctx.lineWidth = Math.max(1, baseUnit * 0.06);
      ctx.beginPath();
      ctx.moveTo(arrowStartX, arrowY);
      ctx.lineTo(arrowEndX, arrowY);
      ctx.stroke();

      // Arrowhead pointing right (toward node)
      const headSize = baseUnit * 0.25;
      ctx.fillStyle = fgColor;
      ctx.beginPath();
      ctx.moveTo(arrowEndX, arrowY);
      ctx.lineTo(arrowEndX - headSize, arrowY - headSize * 0.6);
      ctx.lineTo(arrowEndX - headSize, arrowY + headSize * 0.6);
      ctx.closePath();
      ctx.fill();

      const annotSize = Math.max(8, baseUnit * 0.42);
      ctx.font = `italic ${annotSize}px ${font}`;
      ctx.fillStyle = fgColor;
      ctx.textAlign = &#x27;right&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;
      ctx.fillText(&#x27;Node S&#x27;, arrowStartX - baseUnit * 0.3, arrowY);
    }

    if (node.children) node.children.forEach(drawNode);
  }

  drawNode(tree);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Game tree for the stack of coins game with 4 coins"></iframe></div>
<p>Each node has a number representing the number of coins left in the pile, with the leaf nodes (the nodes with no children) representing the end state of the game.</p>
<p>Letâ€™s colour the leaf nodes red if you win at that state, and blue if your opponent wins at that state. If any branch nodes only have 1 leaf node below it, we can colour it the same colour.</p>
<div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;stage&quot;:2};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/expeditions/adversarial-games.md































































































































































































































































































































































function draw(options) {
  const { canvas, api, width, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Stage: 1 = neutral, 2 = leaves colored + sample node, 3 = all colored
  const stage = props.stage || 1;

  // Theme colors
  const fgColor = api.getColor(&#x27;foreground&#x27;);
  const mutedColor = api.getColor(&#x27;muted-foreground&#x27;);
  const isLight = api.theme === &#x27;light&#x27;;
  const playerAColor = isLight ? api.getColor(&#x27;red-600&#x27;, { chroma: 0.05 }) : api.getColor(&#x27;red-300&#x27;, { chroma: 0.05 });
  const playerBColor = isLight ? api.getColor(&#x27;blue-600&#x27;, { chroma: 0.05 }) : api.getColor(&#x27;blue-300&#x27;, { chroma: 0.05 });

  // Responsive sizing
  const baseUnit = Math.max(12, Math.min(28, width / 30));
  const nodeRadius = baseUnit * 1.2;
  const font = api.getFont(&#x27;default&#x27;);

  // Tree data structure
  // winner: who ultimately wins from this position (computed via backward induction)
  // leafWinner: only on leaf nodes, who won the game at that terminal state
  const tree = {
    coins: 4, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
      { coins: 3, player: &#x27;B&#x27;, winner: &#x27;A&#x27;, children: [
        { coins: 2, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, annotation: true, children: [
          { coins: 1, player: &#x27;B&#x27;, winner: &#x27;B&#x27;, children: [
            { coins: 0, isLeaf: true, leafWinner: &#x27;B&#x27; }
          ]},
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]},
        { coins: 1, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]}
      ]},
      { coins: 2, player: &#x27;B&#x27;, winner: &#x27;B&#x27;, children: [
        { coins: 1, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]},
        { coins: 0, isLeaf: true, leafWinner: &#x27;B&#x27; }
      ]}
    ]
  };

  // Determine node color based on stage
  function getNodeColor(node) {
    if (stage === 1) return null; // neutral
    if (stage === 2) {
      if (node.isLeaf) return node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
      // Color internal nodes only if all descendants agree on winner
      const allDescendants = [];
      function collect(n) {
        if (n.isLeaf) { allDescendants.push(n.leafWinner); return; }
        if (n.children) n.children.forEach(collect);
      }
      collect(node);
      const allSame = allDescendants.every(w =&gt; w === allDescendants[0]);
      if (allSame) return allDescendants[0] === &#x27;A&#x27; ? playerAColor : playerBColor;
      return null;
    }
    // stage 3: all nodes colored by winner
    if (node.isLeaf) return node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
    return node.winner === &#x27;A&#x27; ? playerAColor : playerBColor;
  }

  // Layout calculations
  function countLeaves(node) {
    if (!node.children || node.children.length === 0) return 1;
    return node.children.reduce((sum, c) =&gt; sum + countLeaves(c), 0);
  }

  function getDepth(node) {
    if (!node.children || node.children.length === 0) return 0;
    return 1 + Math.max(...node.children.map(getDepth));
  }

  const totalLeaves = countLeaves(tree);
  const maxDepth = getDepth(tree);

  const hSpacing = nodeRadius * 4;
  const vSpacing = nodeRadius * 5;
  const topPadding = nodeRadius * 2;
  const bottomPadding = nodeRadius * 3;
  const annotationSpace = stage === 2 ? nodeRadius * 4 : 0;

  const treeWidth = (totalLeaves - 1) * hSpacing;
  const treeHeight = maxDepth * vSpacing;

  const canvasWidth = Math.max(width, treeWidth + nodeRadius * 4 + annotationSpace);
  const canvasHeight = treeHeight + topPadding + bottomPadding;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Assign positions bottom-up
  let leafIndex = 0;
  const treeLeft = (canvasWidth - treeWidth) / 2;

  function assignPositions(node, depth) {
    const y = topPadding + depth * vSpacing;
    if (!node.children || node.children.length === 0) {
      node.x = treeLeft + leafIndex * hSpacing;
      node.y = y;
      leafIndex++;
      return;
    }
    node.children.forEach(c =&gt; assignPositions(c, depth + 1));
    const childXs = node.children.map(c =&gt; c.x);
    node.x = (Math.min(...childXs) + Math.max(...childXs)) / 2;
    node.y = y;
  }

  assignPositions(tree, 0);

  // Draw arrow with arrowhead
  function drawArrow(x1, y1, x2, y2, color) {
    const headLen = baseUnit * 0.4;
    const angle = Math.atan2(y2 - y1, x2 - x1);
    const tipX = x2;
    const tipY = y2;

    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(tipX - headLen * Math.cos(angle), tipY - headLen * Math.sin(angle));
    ctx.stroke();

    // Arrowhead
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - headLen * Math.cos(angle - 0.35), tipY - headLen * Math.sin(angle - 0.35));
    ctx.lineTo(tipX - headLen * Math.cos(angle + 0.35), tipY - headLen * Math.sin(angle + 0.35));
    ctx.closePath();
    ctx.fill();
  }

  // Draw edges
  function drawEdges(node) {
    if (!node.children) return;
    node.children.forEach(child =&gt; {
      const edgeColor = node.player === &#x27;A&#x27; ? playerAColor : playerBColor;
      drawArrow(node.x, node.y + nodeRadius, child.x, child.y - nodeRadius, edgeColor);

      // Edge label: at midpoint of the line, offset to the side
      const coinsTaken = node.coins - child.coins;
      const labelSize = Math.max(9, baseUnit * 0.42);
      const lineHeight = labelSize * 1.4;
      ctx.font = `${labelSize}px ${font}`;
      ctx.fillStyle = edgeColor;
      ctx.textBaseline = &#x27;middle&#x27;;
      const midX = (node.x + child.x) / 2;
      const midY = (node.y + nodeRadius + child.y - nodeRadius) / 2;
      const numChildren = node.children.length;
      if (numChildren === 1) {
        // Single child: label to the right of the midpoint
        ctx.textAlign = &#x27;left&#x27;;
        ctx.fillText(`take ${coinsTaken}`, midX + lineHeight * 0.5, midY);
      } else {
        // Two children: left child label on left, right child label on right
        const isLeftChild = child.x &lt; node.x || (child.x === node.x &amp;&amp; node.children.indexOf(child) === 0);
        if (isLeftChild) {
          ctx.textAlign = &#x27;right&#x27;;
          ctx.fillText(`take ${coinsTaken}`, midX - lineHeight, midY);
        } else {
          ctx.textAlign = &#x27;left&#x27;;
          ctx.fillText(`take ${coinsTaken}`, midX + lineHeight, midY);
        }
      }

      drawEdges(child);
    });
  }

  drawEdges(tree);

  // Draw nodes
  function drawNode(node) {
    const { x, y } = node;
    const color = getNodeColor(node);
    const strokeColor = color || fgColor;
    const fillBgColor = color || fgColor;

    // Circle background
    ctx.fillStyle = fillBgColor;
    ctx.globalAlpha = color ? 0.15 : 0.04;
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // Circle border
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.stroke();

    // Coin count number
    const numSize = Math.max(12, baseUnit * 0.7);
    ctx.font = `bold ${numSize}px ${font}`;
    ctx.fillStyle = color || fgColor;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(`${node.coins}`, x, y - numSize * 0.15);

    // &quot;coins&quot; label below the number (inside the circle)
    const coinsLabelSize = Math.max(8, baseUnit * 0.38);
    ctx.font = `${coinsLabelSize}px ${font}`;
    ctx.fillStyle = color || fgColor;
    ctx.fillText(node.coins === 1 ? &#x27;coin&#x27; : &#x27;coins&#x27;, x, y + numSize * 0.45);

    // Below-node label: &quot;A wins&quot; / &quot;B wins&quot; for leaf nodes
    if (node.isLeaf) {
      const winColor = node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
      const winSize = Math.max(8, baseUnit * 0.4);
      ctx.font = `bold ${winSize}px ${font}`;
      ctx.fillStyle = stage === 1 ? fgColor : winColor;
      ctx.fillText(node.leafWinner === &#x27;A&#x27; ? &#x27;You win&#x27; : &#x27;Opponent wins&#x27;, x, y + nodeRadius + winSize * 1.2);
    }

    // Annotation arrow for sample node (stage 2 only)
    if (node.annotation &amp;&amp; stage === 2) {
      const arrowStartX = x - nodeRadius - baseUnit * 2;
      const arrowEndX = x - nodeRadius - baseUnit * 0.4;
      const arrowY = y;

      ctx.strokeStyle = fgColor;
      ctx.lineWidth = Math.max(1, baseUnit * 0.06);
      ctx.beginPath();
      ctx.moveTo(arrowStartX, arrowY);
      ctx.lineTo(arrowEndX, arrowY);
      ctx.stroke();

      // Arrowhead pointing right (toward node)
      const headSize = baseUnit * 0.25;
      ctx.fillStyle = fgColor;
      ctx.beginPath();
      ctx.moveTo(arrowEndX, arrowY);
      ctx.lineTo(arrowEndX - headSize, arrowY - headSize * 0.6);
      ctx.lineTo(arrowEndX - headSize, arrowY + headSize * 0.6);
      ctx.closePath();
      ctx.fill();

      const annotSize = Math.max(8, baseUnit * 0.42);
      ctx.font = `italic ${annotSize}px ${font}`;
      ctx.fillStyle = fgColor;
      ctx.textAlign = &#x27;right&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;
      ctx.fillText(&#x27;Node S&#x27;, arrowStartX - baseUnit * 0.3, arrowY);
    }

    if (node.children) node.children.forEach(drawNode);
  }

  drawNode(tree);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Game tree with leaf nodes and simple branches colored"></iframe></div>
<p>Consider the game at state <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation>S</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">S</span></span></span></span> indicated in the diagram above. You have the choice of taking 1 or 2 coins. If you take 1 coin, you end up in a blue node and you lose. If you take 2 coins, you end up on a red node, and you win. Since you can win from this state, you can colour this state red too.</p>
<p>For any node where it is a certain player&#x27;s turn, it is a winning state for that player if ANY of the possible moves will lead to a winning state for that player too. On the other hand, it is a losing state for that player if ALL of the possible moves will lead to a losing state for that player too.</p>
<p>Letâ€™s use this new rule to colour the rest of the nodes.</p>
<div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;stage&quot;:3};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/expeditions/adversarial-games.md































































































































































































































































































































































function draw(options) {
  const { canvas, api, width, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Stage: 1 = neutral, 2 = leaves colored + sample node, 3 = all colored
  const stage = props.stage || 1;

  // Theme colors
  const fgColor = api.getColor(&#x27;foreground&#x27;);
  const mutedColor = api.getColor(&#x27;muted-foreground&#x27;);
  const isLight = api.theme === &#x27;light&#x27;;
  const playerAColor = isLight ? api.getColor(&#x27;red-600&#x27;, { chroma: 0.05 }) : api.getColor(&#x27;red-300&#x27;, { chroma: 0.05 });
  const playerBColor = isLight ? api.getColor(&#x27;blue-600&#x27;, { chroma: 0.05 }) : api.getColor(&#x27;blue-300&#x27;, { chroma: 0.05 });

  // Responsive sizing
  const baseUnit = Math.max(12, Math.min(28, width / 30));
  const nodeRadius = baseUnit * 1.2;
  const font = api.getFont(&#x27;default&#x27;);

  // Tree data structure
  // winner: who ultimately wins from this position (computed via backward induction)
  // leafWinner: only on leaf nodes, who won the game at that terminal state
  const tree = {
    coins: 4, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
      { coins: 3, player: &#x27;B&#x27;, winner: &#x27;A&#x27;, children: [
        { coins: 2, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, annotation: true, children: [
          { coins: 1, player: &#x27;B&#x27;, winner: &#x27;B&#x27;, children: [
            { coins: 0, isLeaf: true, leafWinner: &#x27;B&#x27; }
          ]},
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]},
        { coins: 1, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]}
      ]},
      { coins: 2, player: &#x27;B&#x27;, winner: &#x27;B&#x27;, children: [
        { coins: 1, player: &#x27;A&#x27;, winner: &#x27;A&#x27;, children: [
          { coins: 0, isLeaf: true, leafWinner: &#x27;A&#x27; }
        ]},
        { coins: 0, isLeaf: true, leafWinner: &#x27;B&#x27; }
      ]}
    ]
  };

  // Determine node color based on stage
  function getNodeColor(node) {
    if (stage === 1) return null; // neutral
    if (stage === 2) {
      if (node.isLeaf) return node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
      // Color internal nodes only if all descendants agree on winner
      const allDescendants = [];
      function collect(n) {
        if (n.isLeaf) { allDescendants.push(n.leafWinner); return; }
        if (n.children) n.children.forEach(collect);
      }
      collect(node);
      const allSame = allDescendants.every(w =&gt; w === allDescendants[0]);
      if (allSame) return allDescendants[0] === &#x27;A&#x27; ? playerAColor : playerBColor;
      return null;
    }
    // stage 3: all nodes colored by winner
    if (node.isLeaf) return node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
    return node.winner === &#x27;A&#x27; ? playerAColor : playerBColor;
  }

  // Layout calculations
  function countLeaves(node) {
    if (!node.children || node.children.length === 0) return 1;
    return node.children.reduce((sum, c) =&gt; sum + countLeaves(c), 0);
  }

  function getDepth(node) {
    if (!node.children || node.children.length === 0) return 0;
    return 1 + Math.max(...node.children.map(getDepth));
  }

  const totalLeaves = countLeaves(tree);
  const maxDepth = getDepth(tree);

  const hSpacing = nodeRadius * 4;
  const vSpacing = nodeRadius * 5;
  const topPadding = nodeRadius * 2;
  const bottomPadding = nodeRadius * 3;
  const annotationSpace = stage === 2 ? nodeRadius * 4 : 0;

  const treeWidth = (totalLeaves - 1) * hSpacing;
  const treeHeight = maxDepth * vSpacing;

  const canvasWidth = Math.max(width, treeWidth + nodeRadius * 4 + annotationSpace);
  const canvasHeight = treeHeight + topPadding + bottomPadding;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Assign positions bottom-up
  let leafIndex = 0;
  const treeLeft = (canvasWidth - treeWidth) / 2;

  function assignPositions(node, depth) {
    const y = topPadding + depth * vSpacing;
    if (!node.children || node.children.length === 0) {
      node.x = treeLeft + leafIndex * hSpacing;
      node.y = y;
      leafIndex++;
      return;
    }
    node.children.forEach(c =&gt; assignPositions(c, depth + 1));
    const childXs = node.children.map(c =&gt; c.x);
    node.x = (Math.min(...childXs) + Math.max(...childXs)) / 2;
    node.y = y;
  }

  assignPositions(tree, 0);

  // Draw arrow with arrowhead
  function drawArrow(x1, y1, x2, y2, color) {
    const headLen = baseUnit * 0.4;
    const angle = Math.atan2(y2 - y1, x2 - x1);
    const tipX = x2;
    const tipY = y2;

    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(tipX - headLen * Math.cos(angle), tipY - headLen * Math.sin(angle));
    ctx.stroke();

    // Arrowhead
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - headLen * Math.cos(angle - 0.35), tipY - headLen * Math.sin(angle - 0.35));
    ctx.lineTo(tipX - headLen * Math.cos(angle + 0.35), tipY - headLen * Math.sin(angle + 0.35));
    ctx.closePath();
    ctx.fill();
  }

  // Draw edges
  function drawEdges(node) {
    if (!node.children) return;
    node.children.forEach(child =&gt; {
      const edgeColor = node.player === &#x27;A&#x27; ? playerAColor : playerBColor;
      drawArrow(node.x, node.y + nodeRadius, child.x, child.y - nodeRadius, edgeColor);

      // Edge label: at midpoint of the line, offset to the side
      const coinsTaken = node.coins - child.coins;
      const labelSize = Math.max(9, baseUnit * 0.42);
      const lineHeight = labelSize * 1.4;
      ctx.font = `${labelSize}px ${font}`;
      ctx.fillStyle = edgeColor;
      ctx.textBaseline = &#x27;middle&#x27;;
      const midX = (node.x + child.x) / 2;
      const midY = (node.y + nodeRadius + child.y - nodeRadius) / 2;
      const numChildren = node.children.length;
      if (numChildren === 1) {
        // Single child: label to the right of the midpoint
        ctx.textAlign = &#x27;left&#x27;;
        ctx.fillText(`take ${coinsTaken}`, midX + lineHeight * 0.5, midY);
      } else {
        // Two children: left child label on left, right child label on right
        const isLeftChild = child.x &lt; node.x || (child.x === node.x &amp;&amp; node.children.indexOf(child) === 0);
        if (isLeftChild) {
          ctx.textAlign = &#x27;right&#x27;;
          ctx.fillText(`take ${coinsTaken}`, midX - lineHeight, midY);
        } else {
          ctx.textAlign = &#x27;left&#x27;;
          ctx.fillText(`take ${coinsTaken}`, midX + lineHeight, midY);
        }
      }

      drawEdges(child);
    });
  }

  drawEdges(tree);

  // Draw nodes
  function drawNode(node) {
    const { x, y } = node;
    const color = getNodeColor(node);
    const strokeColor = color || fgColor;
    const fillBgColor = color || fgColor;

    // Circle background
    ctx.fillStyle = fillBgColor;
    ctx.globalAlpha = color ? 0.15 : 0.04;
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // Circle border
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.stroke();

    // Coin count number
    const numSize = Math.max(12, baseUnit * 0.7);
    ctx.font = `bold ${numSize}px ${font}`;
    ctx.fillStyle = color || fgColor;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(`${node.coins}`, x, y - numSize * 0.15);

    // &quot;coins&quot; label below the number (inside the circle)
    const coinsLabelSize = Math.max(8, baseUnit * 0.38);
    ctx.font = `${coinsLabelSize}px ${font}`;
    ctx.fillStyle = color || fgColor;
    ctx.fillText(node.coins === 1 ? &#x27;coin&#x27; : &#x27;coins&#x27;, x, y + numSize * 0.45);

    // Below-node label: &quot;A wins&quot; / &quot;B wins&quot; for leaf nodes
    if (node.isLeaf) {
      const winColor = node.leafWinner === &#x27;A&#x27; ? playerAColor : playerBColor;
      const winSize = Math.max(8, baseUnit * 0.4);
      ctx.font = `bold ${winSize}px ${font}`;
      ctx.fillStyle = stage === 1 ? fgColor : winColor;
      ctx.fillText(node.leafWinner === &#x27;A&#x27; ? &#x27;You win&#x27; : &#x27;Opponent wins&#x27;, x, y + nodeRadius + winSize * 1.2);
    }

    // Annotation arrow for sample node (stage 2 only)
    if (node.annotation &amp;&amp; stage === 2) {
      const arrowStartX = x - nodeRadius - baseUnit * 2;
      const arrowEndX = x - nodeRadius - baseUnit * 0.4;
      const arrowY = y;

      ctx.strokeStyle = fgColor;
      ctx.lineWidth = Math.max(1, baseUnit * 0.06);
      ctx.beginPath();
      ctx.moveTo(arrowStartX, arrowY);
      ctx.lineTo(arrowEndX, arrowY);
      ctx.stroke();

      // Arrowhead pointing right (toward node)
      const headSize = baseUnit * 0.25;
      ctx.fillStyle = fgColor;
      ctx.beginPath();
      ctx.moveTo(arrowEndX, arrowY);
      ctx.lineTo(arrowEndX - headSize, arrowY - headSize * 0.6);
      ctx.lineTo(arrowEndX - headSize, arrowY + headSize * 0.6);
      ctx.closePath();
      ctx.fill();

      const annotSize = Math.max(8, baseUnit * 0.42);
      ctx.font = `italic ${annotSize}px ${font}`;
      ctx.fillStyle = fgColor;
      ctx.textAlign = &#x27;right&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;
      ctx.fillText(&#x27;Node S&#x27;, arrowStartX - baseUnit * 0.3, arrowY);
    }

    if (node.children) node.children.forEach(drawNode);
  }

  drawNode(tree);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Fully colored game tree showing winning positions"></iframe></div>
<p>It turns out the root node is red! That means that if you play optimally, you can always guarantee a win, no matter what your opponent plays. You can see this play out by traversing down this tree. When itâ€™s your turn, choose a move that leads to a red node. When itâ€™s your opponentâ€™s turn, all his possible moves should only lead to red nodes.</p>
<p>We can summarise your winning strategy as such:</p>
<ul>
<li>On your first move, take 1 coin</li>
<li>If your opponent takes 1 coin on the next turn, take 2 coins.</li>
<li>If your opponent takes 2 coins on the next turn, take 1 coin.</li>
</ul>
<p>And thatâ€™s it, weâ€™ve solved this game.</p>
<p>Game trees are a powerful tool to solve games. However, analysing a game tree requires us to draw out the whole game tree to compute it. After all, if we leave out some of the branches, we might accidentally exclude a winning strategy that could determine if the first player always wins or loses.</p>
<p>But that doesnâ€™t mean game trees are entirely useless. If we can learn the properties of game trees, we can use them to reason out an alternative solution. In particular, weâ€™ll be using the lessons we learnt from studying game trees.</p>
<ul>
<li>We can represent the game as a series of positions.</li>
<li>A position is a winning position for a player if:
<ul>
<li>It is the playerâ€™s turn to move, and he can make a move that leads to another winning position.</li>
<li>It is the other playerâ€™s turn to move, but all his options lead to a losing position for him (i.e. the first playerâ€™s winning position).</li>
</ul>
</li>
</ul>
<p>If a game is symmetric (that means the rules are the same for both players), we get an additional bonus: if there is a position that is a losing position for you, then it is a losing position for the other player too IF you can get the game to that position on his turn. By extension, a position is a winning position for you if there is a move that leads it to a losing position for the other player.</p>
<p>With that in mind, letâ€™s take a look at the earlier game with the stack of coins. This time, there are 16 coins, a lot more than we can analyse in a game tree, at least by hand. So how can we solve this game?</p>
<p>Let us notice that if the other player takes 1 coin, you can take 2 coins. Likewise, if the other player takes 2 coins, you can take 1 coin. Either way, you can ensure that the stack is exactly 3 coins shorter after 2 moves.</p>
<p>Consider the position where the stack has only 3 coins, and it is the other playerâ€™s turn. The other player can only take 1 or 2 coins, and you can take the remaining coins on your turn, winning the game. This means that a position with 3 coins left is a losing position for the player that moves next. If you end up with 3 coins in the stack and itâ€™s the other playerâ€™s turn, he loses and you win. Likewise, if there are 3 coins in the stack and itâ€™s your turn, he can use the same strategy to force you to lose, ensuring his win.</p>
<p>Now letâ€™s consider another position, this time with a stack of 6 coins, and it is the other playerâ€™s turn. If the other player takes 1 or 2 coins, you take 2 or 1 coins respectively, bringing the other player to the losing position of 3 coins with him moving next. This means that a stack of 6 coins is also a losing position for the player that moves next.</p>
<p>In general, any stack of coins that contains a multiple of 3 coins is a losing position for the player that goes next. If you encounter such a stack, you want to go second.</p>
<p>However, what happens if the number of coins is not a multiple of 3? Then it must be 1 or 2 more coins than a multiple of 3, and the first player can take 1 or 2 coins respectively to leave a stack with a multiple of 3 coins to the other player. That means you want to go first.</p>
<p>To summarise this game:</p>
<ul>
<li>A position is a losing position for the player that goes next if the number of coins is a multiple of 3, otherwise it is a winning position.</li>
<li>From a winning position, the optimal move is to divide the number of coins by 3 and get the remainder. Take that number of coins to leave the other player with a losing position.</li>
<li>From a losing position, anything you do doesnâ€™t affect the outcome of the game: you lose the game.</li>
<li>If you get to pick who goes first, choose to go first if the starting position is a winning position. Otherwise, choose to go second.</li>
</ul>
<p>In this way, weâ€™ve solved this particular game without having to draw the entire game tree. But as you may have noticed, we needed to find a special property of this game that helps us to identify the winning and losing positions of the game.</p>





















<table class="no-header"><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">What is a winning position?</td><td align="left">â€¢ A position that has already ended, giving the win to the last player that has moved.<br/>â€¢ A position where there exists a move to put the other player in a losing position.</td></tr><tr><td align="left">What is a losing position?</td><td align="left">â€¢ A game position that has already ended, giving a loss to the last player whose turn it is.<br/>â€¢ A game position where all possible moves will put the other player in a winning position.</td></tr><tr><td align="left">Should you go first?</td><td align="left">â€¢ Yes, if the starting position is a winning position.<br/>â€¢ No, if the starting position is a losing position.</td></tr></tbody></table>
<p>Many adversarial game puzzles will ask you something like â€œcan you guarantee a win?â€ The answer usually depends on whether you get to choose who goes first. If the starting position is a winning position, you want to go first so you can play the winning strategy. If itâ€™s a losing position, you want to go second â€” because then the starting position is a losing position for your opponent instead. When you encounter an adversarial game puzzle, one of the first things to figure out is whether the starting position favours the first or the second player.</p>
<p>Thatâ€™s the foundation. You now have the tools to approach adversarial game puzzles: represent the game as a series of positions, classify those positions as winning or losing, and use that classification to play optimally. The puzzles ahead will put these ideas to work â€” and along the way, youâ€™ll discover more techniques and patterns that make these games tick.</p>
<div class="inline-component-definition" style="display:none"></div>
<div class="inline-component-definition" style="display:none"></div></div><div class="flex justify-center my-8"><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark expedition as complete">Mark as Complete</button></div><section class="mt-12"><h2 class="mb-4 text-xl font-bold text-foreground lg:text-2xl">Try These Expeditions Next</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/expedition/adversarial-games" data-discover="true"><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Adversarial Games</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Learn how to analyse two-player, zero-sum games by building game trees,
classifying positions as winning or losing, and finding optimal strategies.
</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/expedition/binary" data-discover="true"><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Binary</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Understanding binary number systems, and converting between decimal and binary.</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/expedition/gray-code" data-discover="true"><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Gray Code</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Learn about Gray code, a binary numbering system where consecutive values differ by only one bit. Essential for puzzles involving binary states with single-bit transitions.</p></div></a></div></section></div></main></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":false,"unstable_splitRouteModules":false,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-25fb394a.js";
import * as route0 from "/assets/root-BjuwspyJ.js";
import * as route1 from "/assets/expedition-detail-3tRHBKcD.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/expedition-detail":route1};

import("/assets/entry.client-BQEHofJp.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_71\":-5,\"_72\":-5},\"loaderData\",{\"_3\":4},\"routes/expedition-detail\",{\"_5\":6,\"_7\":8,\"_9\":10},\"status\",\"success\",\"slug\",\"adversarial-games\",\"expedition\",{\"_7\":8,\"_11\":12,\"_28\":29,\"_30\":31,\"_32\":33,\"_59\":60},\"metadata\",{\"_13\":14,\"_15\":16,\"_17\":18,\"_19\":20,\"_23\":24,\"_25\":24,\"_26\":27},\"id\",\"expedition-3\",\"title\",\"Adversarial Games\",\"description\",\"Learn how to analyse two-player, zero-sum games by building game trees,\\nclassifying positions as winning or losing, and finding optimal strategies.\\n\",\"concepts\",[21,22],\"adversarial-game\",\"game-theory\",\"dateCreated\",\"2026-02-09\",\"lastUpdated\",\"published\",true,\"content\",\"\u003cp\u003eIn the context of puzzles, games typically refer to a scenario where players take turns to make a move, eventually leading to an outcome. The game is called adversarial if the players have conflicting goals. For example, if one player wins, the other must lose; they canâ€™t both win.\u003c/p\u003e\\n\u003cp\u003eFor this module, we shall only consider games with the following properties:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eThe game involves 2 players.\u003c/li\u003e\\n\u003cli\u003ePlayers will take turns to make a single move.\u003c/li\u003e\\n\u003cli\u003eAll sequences of moves eventually lead to one player winning. This means that there are no infinite games.\u003c/li\u003e\\n\u003cli\u003eIt is a zero-sum game: one player winning means the other must lose.\u003c/li\u003e\\n\u003cli\u003eThere are no ties: there must always be one player winning.\u003c/li\u003e\\n\u003cli\u003eDeterministic: there are no elements of randomness. A particular sequence of moves from a particular game state will always result in the same final game state.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eThe most general way to solve such games is to draw out the game tree. For instance, this is the game tree of Tic-Tac-Toe.\u003c/p\u003e\\n\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"0\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eOn the 1st level of the tree, we have one node (we call this the root node) that represents the gameâ€™s starting state. Each state branches out into possible states that can be reached as a result of the next playerâ€™s move. On the 1st, 3rd, 5th, â€¦ levels, the â€œXâ€ player is next to move. On the 2nd, 4th, 6th, â€¦ levels, the â€œOâ€ player is next to move.\u003c/p\u003e\\n\u003cp\u003eNow that we have an understanding of how a game tree looks, letâ€™s consider a simpler game so we can analyse it:\u003c/p\u003e\\n\u003cp\u003eYou and your opponent have a stack of 4 coins: 3 iron coins and 1 gold coin at the bottom. On each playerâ€™s turn, they have to take 1 or 2 coins, with the goal being to take the golden coin. Youâ€™re going first. How do you ensure you get the golden coin?\u003c/p\u003e\\n\u003cp\u003eLetâ€™s draw the game tree for this game. The red arrows represent the moves you can make, and the blue arrows represent your opponentâ€™s moves.\u003c/p\u003e\\n\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"1\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eEach node has a number representing the number of coins left in the pile, with the leaf nodes (the nodes with no children) representing the end state of the game.\u003c/p\u003e\\n\u003cp\u003eLetâ€™s colour the leaf nodes red if you win at that state, and blue if your opponent wins at that state. If any branch nodes only have 1 leaf node below it, we can colour it the same colour.\u003c/p\u003e\\n\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"2\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eConsider the game at state \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eS\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003eS\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\"\u003eS\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e indicated in the diagram above. You have the choice of taking 1 or 2 coins. If you take 1 coin, you end up in a blue node and you lose. If you take 2 coins, you end up on a red node, and you win. Since you can win from this state, you can colour this state red too.\u003c/p\u003e\\n\u003cp\u003eFor any node where it is a certain player's turn, it is a winning state for that player if ANY of the possible moves will lead to a winning state for that player too. On the other hand, it is a losing state for that player if ALL of the possible moves will lead to a losing state for that player too.\u003c/p\u003e\\n\u003cp\u003eLetâ€™s use this new rule to colour the rest of the nodes.\u003c/p\u003e\\n\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"3\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eIt turns out the root node is red! That means that if you play optimally, you can always guarantee a win, no matter what your opponent plays. You can see this play out by traversing down this tree. When itâ€™s your turn, choose a move that leads to a red node. When itâ€™s your opponentâ€™s turn, all his possible moves should only lead to red nodes.\u003c/p\u003e\\n\u003cp\u003eWe can summarise your winning strategy as such:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eOn your first move, take 1 coin\u003c/li\u003e\\n\u003cli\u003eIf your opponent takes 1 coin on the next turn, take 2 coins.\u003c/li\u003e\\n\u003cli\u003eIf your opponent takes 2 coins on the next turn, take 1 coin.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eAnd thatâ€™s it, weâ€™ve solved this game.\u003c/p\u003e\\n\u003cp\u003eGame trees are a powerful tool to solve games. However, analysing a game tree requires us to draw out the whole game tree to compute it. After all, if we leave out some of the branches, we might accidentally exclude a winning strategy that could determine if the first player always wins or loses.\u003c/p\u003e\\n\u003cp\u003eBut that doesnâ€™t mean game trees are entirely useless. If we can learn the properties of game trees, we can use them to reason out an alternative solution. In particular, weâ€™ll be using the lessons we learnt from studying game trees.\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eWe can represent the game as a series of positions.\u003c/li\u003e\\n\u003cli\u003eA position is a winning position for a player if:\\n\u003cul\u003e\\n\u003cli\u003eIt is the playerâ€™s turn to move, and he can make a move that leads to another winning position.\u003c/li\u003e\\n\u003cli\u003eIt is the other playerâ€™s turn to move, but all his options lead to a losing position for him (i.e. the first playerâ€™s winning position).\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eIf a game is symmetric (that means the rules are the same for both players), we get an additional bonus: if there is a position that is a losing position for you, then it is a losing position for the other player too IF you can get the game to that position on his turn. By extension, a position is a winning position for you if there is a move that leads it to a losing position for the other player.\u003c/p\u003e\\n\u003cp\u003eWith that in mind, letâ€™s take a look at the earlier game with the stack of coins. This time, there are 16 coins, a lot more than we can analyse in a game tree, at least by hand. So how can we solve this game?\u003c/p\u003e\\n\u003cp\u003eLet us notice that if the other player takes 1 coin, you can take 2 coins. Likewise, if the other player takes 2 coins, you can take 1 coin. Either way, you can ensure that the stack is exactly 3 coins shorter after 2 moves.\u003c/p\u003e\\n\u003cp\u003eConsider the position where the stack has only 3 coins, and it is the other playerâ€™s turn. The other player can only take 1 or 2 coins, and you can take the remaining coins on your turn, winning the game. This means that a position with 3 coins left is a losing position for the player that moves next. If you end up with 3 coins in the stack and itâ€™s the other playerâ€™s turn, he loses and you win. Likewise, if there are 3 coins in the stack and itâ€™s your turn, he can use the same strategy to force you to lose, ensuring his win.\u003c/p\u003e\\n\u003cp\u003eNow letâ€™s consider another position, this time with a stack of 6 coins, and it is the other playerâ€™s turn. If the other player takes 1 or 2 coins, you take 2 or 1 coins respectively, bringing the other player to the losing position of 3 coins with him moving next. This means that a stack of 6 coins is also a losing position for the player that moves next.\u003c/p\u003e\\n\u003cp\u003eIn general, any stack of coins that contains a multiple of 3 coins is a losing position for the player that goes next. If you encounter such a stack, you want to go second.\u003c/p\u003e\\n\u003cp\u003eHowever, what happens if the number of coins is not a multiple of 3? Then it must be 1 or 2 more coins than a multiple of 3, and the first player can take 1 or 2 coins respectively to leave a stack with a multiple of 3 coins to the other player. That means you want to go first.\u003c/p\u003e\\n\u003cp\u003eTo summarise this game:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eA position is a losing position for the player that goes next if the number of coins is a multiple of 3, otherwise it is a winning position.\u003c/li\u003e\\n\u003cli\u003eFrom a winning position, the optimal move is to divide the number of coins by 3 and get the remainder. Take that number of coins to leave the other player with a losing position.\u003c/li\u003e\\n\u003cli\u003eFrom a losing position, anything you do doesnâ€™t affect the outcome of the game: you lose the game.\u003c/li\u003e\\n\u003cli\u003eIf you get to pick who goes first, choose to go first if the starting position is a winning position. Otherwise, choose to go second.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eIn this way, weâ€™ve solved this particular game without having to draw the entire game tree. But as you may have noticed, we needed to find a special property of this game that helps us to identify the winning and losing positions of the game.\u003c/p\u003e\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\u003ctable class=\\\"no-header\\\"\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\\\"left\\\"\u003e\u003c/th\u003e\u003cth align=\\\"left\\\"\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\\\"left\\\"\u003eWhat is a winning position?\u003c/td\u003e\u003ctd align=\\\"left\\\"\u003eâ€¢ A position that has already ended, giving the win to the last player that has moved.\u003cbr\u003eâ€¢ A position where there exists a move to put the other player in a losing position.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\\\"left\\\"\u003eWhat is a losing position?\u003c/td\u003e\u003ctd align=\\\"left\\\"\u003eâ€¢ A game position that has already ended, giving a loss to the last player whose turn it is.\u003cbr\u003eâ€¢ A game position where all possible moves will put the other player in a winning position.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\\\"left\\\"\u003eShould you go first?\u003c/td\u003e\u003ctd align=\\\"left\\\"\u003eâ€¢ Yes, if the starting position is a winning position.\u003cbr\u003eâ€¢ No, if the starting position is a losing position.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\\n\u003cp\u003eMany adversarial game puzzles will ask you something like â€œcan you guarantee a win?â€ The answer usually depends on whether you get to choose who goes first. If the starting position is a winning position, you want to go first so you can play the winning strategy. If itâ€™s a losing position, you want to go second â€” because then the starting position is a losing position for your opponent instead. When you encounter an adversarial game puzzle, one of the first things to figure out is whether the starting position favours the first or the second player.\u003c/p\u003e\\n\u003cp\u003eThatâ€™s the foundation. You now have the tools to approach adversarial game puzzles: represent the game as a series of positions, classify those positions as winning or losing, and use that classification to play optimally. The puzzles ahead will put these ideas to work â€” and along the way, youâ€™ll discover more techniques and patterns that make these games tick.\u003c/p\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\",\"rawContent\",\"In the context of puzzles, games typically refer to a scenario where players take turns to make a move, eventually leading to an outcome. The game is called adversarial if the players have conflicting goals. For example, if one player wins, the other must lose; they canâ€™t both win.\\n\\nFor this module, we shall only consider games with the following properties:\\n\\n* The game involves 2 players.  \\n* Players will take turns to make a single move.  \\n* All sequences of moves eventually lead to one player winning. This means that there are no infinite games.  \\n* It is a zero-sum game: one player winning means the other must lose.  \\n* There are no ties: there must always be one player winning.\\n* Deterministic: there are no elements of randomness. A particular sequence of moves from a particular game state will always result in the same final game state.\\n\\nThe most general way to solve such games is to draw out the game tree. For instance, this is the game tree of Tic-Tac-Toe.\\n\\n:::dynamic\\n```yaml\\ntitle: 'Tic-tac-toe game tree showing first two levels of moves'\\nariaLabel: \\\"Game tree diagram with an empty tic-tac-toe board at the root, branching to three boards showing first moves by X in corner, center, and edge positions, each branching further to show possible responses by O\\\"\\nuse: '#tic-tac-toe-tree'\\n```\\n:::\\n\\nOn the 1st level of the tree, we have one node (we call this the root node) that represents the gameâ€™s starting state. Each state branches out into possible states that can be reached as a result of the next playerâ€™s move. On the 1st, 3rd, 5th, â€¦ levels, the â€œXâ€ player is next to move. On the 2nd, 4th, 6th, â€¦ levels, the â€œOâ€ player is next to move.\\n\\nNow that we have an understanding of how a game tree looks, letâ€™s consider a simpler game so we can analyse it:\\n\\nYou and your opponent have a stack of 4 coins: 3 iron coins and 1 gold coin at the bottom. On each playerâ€™s turn, they have to take 1 or 2 coins, with the goal being to take the golden coin. Youâ€™re going first. How do you ensure you get the golden coin?\\n\\nLetâ€™s draw the game tree for this game. The red arrows represent the moves you can make, and the blue arrows represent your opponentâ€™s moves.\\n\\n:::dynamic\\n```yaml\\ntitle: 'Game tree for the stack of coins game with 4 coins'\\nariaLabel: \\\"Game tree diagram. Root node shows 4 coins with player A to move. A can take 1 coin (going to 3, player B) or 2 coins (going to 2, player B). The tree branches further showing all possible game outcomes, with leaf nodes showing which player wins.\\\"\\nuse: '#coin-game-tree'\\nprops:\\n  stage: 1\\n```\\n:::\\n\\nEach node has a number representing the number of coins left in the pile, with the leaf nodes (the nodes with no children) representing the end state of the game.\\n\\nLetâ€™s colour the leaf nodes red if you win at that state, and blue if your opponent wins at that state. If any branch nodes only have 1 leaf node below it, we can colour it the same colour.\\n\\n:::dynamic\\n```yaml\\ntitle: 'Game tree with leaf nodes and simple branches colored'\\nariaLabel: \\\"Same game tree as before, but leaf nodes are now colored red for A wins and blue for B wins. Internal nodes with only one leaf descendant are also colored. The node with 2 coins on player A's turn is highlighted as a sample node to reason about.\\\"\\nuse: '#coin-game-tree'\\nprops:\\n  stage: 2\\n```\\n:::\\n\\nConsider the game at state $S$ indicated in the diagram above. You have the choice of taking 1 or 2 coins. If you take 1 coin, you end up in a blue node and you lose. If you take 2 coins, you end up on a red node, and you win. Since you can win from this state, you can colour this state red too.\\n\\nFor any node where it is a certain player's turn, it is a winning state for that player if ANY of the possible moves will lead to a winning state for that player too. On the other hand, it is a losing state for that player if ALL of the possible moves will lead to a losing state for that player too.\\n\\nLetâ€™s use this new rule to colour the rest of the nodes.\\n\\n:::dynamic\\n```yaml\\ntitle: 'Fully colored game tree showing winning positions'\\nariaLabel: \\\"The complete game tree with all nodes colored. Red nodes are winning positions for player A, blue nodes are winning positions for player B. The root node with 4 coins is red, showing that player A can always win with optimal play.\\\"\\nuse: '#coin-game-tree'\\nprops:\\n  stage: 3\\n```\\n:::\\n\\nIt turns out the root node is red! That means that if you play optimally, you can always guarantee a win, no matter what your opponent plays. You can see this play out by traversing down this tree. When itâ€™s your turn, choose a move that leads to a red node. When itâ€™s your opponentâ€™s turn, all his possible moves should only lead to red nodes.\\n\\nWe can summarise your winning strategy as such:\\n\\n* On your first move, take 1 coin  \\n* If your opponent takes 1 coin on the next turn, take 2 coins.  \\n* If your opponent takes 2 coins on the next turn, take 1 coin.\\n\\nAnd thatâ€™s it, weâ€™ve solved this game.\\n\\nGame trees are a powerful tool to solve games. However, analysing a game tree requires us to draw out the whole game tree to compute it. After all, if we leave out some of the branches, we might accidentally exclude a winning strategy that could determine if the first player always wins or loses.\\n\\nBut that doesnâ€™t mean game trees are entirely useless. If we can learn the properties of game trees, we can use them to reason out an alternative solution. In particular, weâ€™ll be using the lessons we learnt from studying game trees.\\n\\n* We can represent the game as a series of positions.  \\n* A position is a winning position for a player if:  \\n  * It is the playerâ€™s turn to move, and he can make a move that leads to another winning position.\\n  * It is the other playerâ€™s turn to move, but all his options lead to a losing position for him (i.e. the first playerâ€™s winning position).\\n\\nIf a game is symmetric (that means the rules are the same for both players), we get an additional bonus: if there is a position that is a losing position for you, then it is a losing position for the other player too IF you can get the game to that position on his turn. By extension, a position is a winning position for you if there is a move that leads it to a losing position for the other player.\\n\\nWith that in mind, letâ€™s take a look at the earlier game with the stack of coins. This time, there are 16 coins, a lot more than we can analyse in a game tree, at least by hand. So how can we solve this game?\\n\\nLet us notice that if the other player takes 1 coin, you can take 2 coins. Likewise, if the other player takes 2 coins, you can take 1 coin. Either way, you can ensure that the stack is exactly 3 coins shorter after 2 moves.\\n\\nConsider the position where the stack has only 3 coins, and it is the other playerâ€™s turn. The other player can only take 1 or 2 coins, and you can take the remaining coins on your turn, winning the game. This means that a position with 3 coins left is a losing position for the player that moves next. If you end up with 3 coins in the stack and itâ€™s the other playerâ€™s turn, he loses and you win. Likewise, if there are 3 coins in the stack and itâ€™s your turn, he can use the same strategy to force you to lose, ensuring his win.\\n\\nNow letâ€™s consider another position, this time with a stack of 6 coins, and it is the other playerâ€™s turn. If the other player takes 1 or 2 coins, you take 2 or 1 coins respectively, bringing the other player to the losing position of 3 coins with him moving next. This means that a stack of 6 coins is also a losing position for the player that moves next.\\n\\nIn general, any stack of coins that contains a multiple of 3 coins is a losing position for the player that goes next. If you encounter such a stack, you want to go second.\\n\\nHowever, what happens if the number of coins is not a multiple of 3? Then it must be 1 or 2 more coins than a multiple of 3, and the first player can take 1 or 2 coins respectively to leave a stack with a multiple of 3 coins to the other player. That means you want to go first.\\n\\nTo summarise this game:\\n\\n* A position is a losing position for the player that goes next if the number of coins is a multiple of 3, otherwise it is a winning position.  \\n* From a winning position, the optimal move is to divide the number of coins by 3 and get the remainder. Take that number of coins to leave the other player with a losing position.  \\n* From a losing position, anything you do doesnâ€™t affect the outcome of the game: you lose the game.  \\n* If you get to pick who goes first, choose to go first if the starting position is a winning position. Otherwise, choose to go second.\\n\\nIn this way, weâ€™ve solved this particular game without having to draw the entire game tree. But as you may have noticed, we needed to find a special property of this game that helps us to identify the winning and losing positions of the game.\\n\\n\\n|||\\n| :---- | :---- |\\n| What is a winning position? | â€¢ A position that has already ended, giving the win to the last player that has moved.\u003cbr\u003eâ€¢ A position where there exists a move to put the other player in a losing position. |\\n| What is a losing position? | â€¢ A game position that has already ended, giving a loss to the last player whose turn it is.\u003cbr\u003eâ€¢ A game position where all possible moves will put the other player in a winning position.|\\n| Should you go first? | â€¢ Yes, if the starting position is a winning position.\u003cbr\u003eâ€¢ No, if the starting position is a losing position. |\\n\\nMany adversarial game puzzles will ask you something like â€œcan you guarantee a win?â€ The answer usually depends on whether you get to choose who goes first. If the starting position is a winning position, you want to go first so you can play the winning strategy. If itâ€™s a losing position, you want to go second â€” because then the starting position is a losing position for your opponent instead. When you encounter an adversarial game puzzle, one of the first things to figure out is whether the starting position favours the first or the second player.\\n\\nThatâ€™s the foundation. You now have the tools to approach adversarial game puzzles: represent the game as a series of positions, classify those positions as winning or losing, and use that classification to play optimally. The puzzles ahead will put these ideas to work â€” and along the way, youâ€™ll discover more techniques and patterns that make these games tick.\\n\\n:::component[tic-tac-toe-tree]\\n```js\\nfunction draw(options) {\\n  const { canvas, api, width } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Calculate responsive sizing - base unit for level 2 (smallest boards)\\n  const baseCellSize = Math.max(10, Math.min(30, width / 50));\\n\\n  // Different sizes for each level\\n  const level2CellSize = baseCellSize;          // Level 2: base size (1x)\\n  const level1CellSize = baseCellSize * 1.5;      // Level 1: 1.5x bigger\\n  const level0CellSize = baseCellSize * 2;      // Level 0 (root): 2x bigger\\n\\n  const level2BoardSize = level2CellSize * 3;\\n  const level1BoardSize = level1CellSize * 3;\\n  const level0BoardSize = level0CellSize * 3;\\n\\n  const boardGap = level2CellSize * 0.5; // Gap between boards at level 2\\n  const levelHeight = level0BoardSize * 1.4; // Space between levels\\n\\n  // Board state definitions (0 = empty, 1 = X, 2 = O)\\n  // Grid positions: 0=top-left, 1=top-mid, 2=top-right, 3=mid-left, 4=center, 5=mid-right, 6=bot-left, 7=bot-mid, 8=bot-right\\n  const boards = {\\n    A: [0, 0, 0, 0, 0, 0, 0, 0, 0],  // empty\\n    // Level 1: X first moves (corner, edge, center)\\n    B: [1, 0, 0, 0, 0, 0, 0, 0, 0],  // X__/___/___  (corner)\\n    C: [0, 1, 0, 0, 0, 0, 0, 0, 0],  // _X_/___/___  (edge)\\n    D: [0, 0, 0, 0, 1, 0, 0, 0, 0],  // ___/_X_/___  (center)\\n    // Children of B (corner X) - O responses\\n    E: [1, 0, 0, 2, 0, 0, 0, 0, 0],  // X__/O__/___\\n    F: [1, 0, 0, 0, 0, 0, 2, 0, 0],  // X__/___/O__\\n    G: [1, 0, 0, 0, 2, 0, 0, 0, 0],  // X__/_O_/___\\n    H: [1, 0, 0, 0, 0, 0, 0, 2, 0],  // X__/___/_O_\\n    I: [1, 0, 0, 0, 0, 0, 0, 0, 2],  // X__/___/__O\\n    // Children of C (edge X) - O responses\\n    J: [2, 1, 0, 0, 0, 0, 0, 0, 0],  // OX_/___/___\\n    K: [0, 1, 0, 2, 0, 0, 0, 0, 0],  // _X_/O__/___\\n    L: [0, 1, 0, 0, 0, 0, 2, 0, 0],  // _X_/___/O__\\n    M: [0, 1, 0, 0, 2, 0, 0, 0, 0],  // _X_/_O_/___\\n    N: [0, 1, 0, 0, 0, 0, 0, 2, 0],  // _X_/___/_O_\\n    // Children of D (center X) - O responses\\n    O: [2, 0, 0, 0, 1, 0, 0, 0, 0],  // O__/_X_/___\\n    P: [0, 2, 0, 0, 1, 0, 0, 0, 0],  // _O_/_X_/___\\n  };\\n\\n  // Tree structure: each level 1 node has children at level 2\\n  const tree = [\\n    { board: 'B', children: ['E', 'F', 'G', 'H', 'I'] },\\n    { board: 'C', children: ['J', 'K', 'L', 'M', 'N'] },\\n    { board: 'D', children: ['O', 'P'] }\\n  ];\\n\\n  // Calculate total width needed for level 2\\n  const level2Widths = tree.map(node =\u003e node.children.length * level2BoardSize + (node.children.length - 1) * boardGap);\\n  const groupGap = level2BoardSize * 0.75; // Gap between groups\\n  const totalLevel2Width = level2Widths.reduce((a, b) =\u003e a + b, 0) + (tree.length - 1) * groupGap;\\n\\n  // Canvas dimensions\\n  const canvasWidth = Math.max(width, totalLevel2Width + level2BoardSize);\\n  const height = level0BoardSize + levelHeight * 2 + level2BoardSize + baseCellSize * 2;\\n  canvas.width = canvasWidth;\\n  canvas.height = height;\\n\\n  // Get theme colors\\n  const fgColor = api.getColor('foreground');\\n  const mutedColor = api.getColor('muted-foreground');\\n\\n  // Draw a single tic-tac-toe board (no label)\\n  // cellSz: cell size for this board\\n  function drawBoard(x, y, state, cellSz) {\\n    const brdSize = cellSz * 3;\\n\\n    // Draw grid\\n    ctx.strokeStyle = mutedColor;\\n    ctx.lineWidth = 1;\\n\\n    for (let i = 1; i \u003c 3; i++) {\\n      ctx.beginPath();\\n      ctx.moveTo(x + i * cellSz, y);\\n      ctx.lineTo(x + i * cellSz, y + brdSize);\\n      ctx.stroke();\\n\\n      ctx.beginPath();\\n      ctx.moveTo(x, y + i * cellSz);\\n      ctx.lineTo(x + brdSize, y + i * cellSz);\\n      ctx.stroke();\\n    }\\n\\n    // Draw X's and O's\\n    for (let i = 0; i \u003c 9; i++) {\\n      const row = Math.floor(i / 3);\\n      const col = i % 3;\\n      const cellX = x + col * cellSz + cellSz / 2;\\n      const cellY = y + row * cellSz + cellSz / 2;\\n\\n      if (state[i] === 1) {\\n        ctx.strokeStyle = fgColor;\\n        ctx.lineWidth = 2;\\n        const offset = cellSz * 0.25;\\n        ctx.beginPath();\\n        ctx.moveTo(cellX - offset, cellY - offset);\\n        ctx.lineTo(cellX + offset, cellY + offset);\\n        ctx.stroke();\\n        ctx.beginPath();\\n        ctx.moveTo(cellX + offset, cellY - offset);\\n        ctx.lineTo(cellX - offset, cellY + offset);\\n        ctx.stroke();\\n      } else if (state[i] === 2) {\\n        ctx.strokeStyle = fgColor;\\n        ctx.lineWidth = 2;\\n        const radius = cellSz * 0.25;\\n        ctx.beginPath();\\n        ctx.arc(cellX, cellY, radius, 0, Math.PI * 2);\\n        ctx.stroke();\\n      }\\n    }\\n\\n    return { x: x + brdSize / 2, y: y + brdSize / 2, size: brdSize };\\n  }\\n\\n  // Padding between board edges and connector lines\\n  const connectorPadding = baseCellSize * 0.4;\\n\\n  // Draw connecting line (paler using reduced opacity)\\n  function drawLine(x1, y1, x2, y2) {\\n    ctx.strokeStyle = fgColor;\\n    ctx.globalAlpha = 0.6;\\n    ctx.lineWidth = 1;\\n    ctx.beginPath();\\n    ctx.moveTo(x1, y1);\\n    ctx.lineTo(x2, y2);\\n    ctx.stroke();\\n    ctx.globalAlpha = 1.0;\\n  }\\n\\n  // Calculate positions for level 2 first (bottom-up layout)\\n  const level2Y = level0BoardSize + levelHeight * 2 - level2BoardSize;\\n  let currentX = (canvasWidth - totalLevel2Width) / 2;\\n\\n  const level2Positions = [];\\n  const level1Centers = [];\\n\\n  tree.forEach((node, groupIndex) =\u003e {\\n    const groupPositions = [];\\n    node.children.forEach((childBoard, childIndex) =\u003e {\\n      const x = currentX + childIndex * (level2BoardSize + boardGap);\\n      groupPositions.push({ board: childBoard, x, y: level2Y });\\n    });\\n    level2Positions.push(groupPositions);\\n\\n    // Calculate level 1 center (above the middle of its children)\\n    const groupLeft = currentX;\\n    const groupRight = currentX + (node.children.length - 1) * (level2BoardSize + boardGap) + level2BoardSize;\\n    const level1CenterX = (groupLeft + groupRight) / 2;\\n    level1Centers.push({ board: node.board, centerX: level1CenterX });\\n\\n    currentX = groupRight + groupGap;\\n  });\\n\\n  // Level 1 Y position\\n  const level1Y = level0BoardSize + levelHeight - level1BoardSize / 2;\\n\\n  // Level 0 (root) position - centered above level 1\\n  const rootX = canvasWidth / 2 - level0BoardSize / 2;\\n  const rootY = baseCellSize;\\n  const rootCenter = drawBoard(rootX, rootY, boards.A, level0CellSize);\\n\\n  // Draw level 1 nodes and lines from root\\n  const level1Positions = level1Centers.map(item =\u003e ({\\n    board: item.board,\\n    x: item.centerX - level1BoardSize / 2,\\n    y: level1Y\\n  }));\\n\\n  // Draw level 1 nodes with fanned-out lines from root\\n  const level1SpreadWidth = level0BoardSize * 0.6;\\n  level1Positions.forEach((pos, index) =\u003e {\\n    const center = drawBoard(pos.x, pos.y, boards[pos.board], level1CellSize);\\n    // Calculate spread-out start position on root board\\n    const numChildren = level1Positions.length;\\n    const startX = numChildren === 1\\n      ? rootCenter.x\\n      : rootCenter.x - level1SpreadWidth / 2 + (index * level1SpreadWidth / (numChildren - 1));\\n    drawLine(startX, rootCenter.y + level0BoardSize / 2 + connectorPadding, center.x, center.y - level1BoardSize / 2 - connectorPadding);\\n  });\\n\\n  // Draw level 2 nodes and lines from level 1 with fanned-out connections\\n  // Spread width scales with number of children (max spread for 5 children)\\n  const maxSpreadWidth = level1BoardSize * 0.6;\\n  level2Positions.forEach((group, groupIndex) =\u003e {\\n    const parentPos = level1Positions[groupIndex];\\n    const parentCenter = { x: parentPos.x + level1BoardSize / 2, y: parentPos.y + level1BoardSize / 2 };\\n\\n    const numChildren = group.length;\\n    // Scale spread based on number of children (fewer children = narrower spread)\\n    const level2SpreadWidth = numChildren \u003c= 1 ? 0 : maxSpreadWidth * (numChildren - 1) / 4;\\n\\n    group.forEach((pos, childIndex) =\u003e {\\n      const center = drawBoard(pos.x, pos.y, boards[pos.board], level2CellSize);\\n      // Calculate spread-out start position on parent board\\n      const startX = numChildren === 1\\n        ? parentCenter.x\\n        : parentCenter.x - level2SpreadWidth / 2 + (childIndex * level2SpreadWidth / (numChildren - 1));\\n      drawLine(startX, parentCenter.y + level1BoardSize / 2 + connectorPadding, center.x, center.y - level2BoardSize / 2 - connectorPadding);\\n    });\\n\\n    // Draw \\\"...\\\" below each group\\n    ctx.fillStyle = mutedColor;\\n    ctx.font = `${Math.max(12, baseCellSize)}px ${api.getFont('default')}`;\\n    ctx.textAlign = 'center';\\n    ctx.fillText('...', parentCenter.x, level2Y + level2BoardSize + baseCellSize);\\n  });\\n}\\n```\\n:::\\n\\n:::component[coin-game-tree]\\n```js\\nfunction draw(options) {\\n  const { canvas, api, width, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Stage: 1 = neutral, 2 = leaves colored + sample node, 3 = all colored\\n  const stage = props.stage || 1;\\n\\n  // Theme colors\\n  const fgColor = api.getColor('foreground');\\n  const mutedColor = api.getColor('muted-foreground');\\n  const isLight = api.theme === 'light';\\n  const playerAColor = isLight ? api.getColor('red-600', { chroma: 0.05 }) : api.getColor('red-300', { chroma: 0.05 });\\n  const playerBColor = isLight ? api.getColor('blue-600', { chroma: 0.05 }) : api.getColor('blue-300', { chroma: 0.05 });\\n\\n  // Responsive sizing\\n  const baseUnit = Math.max(12, Math.min(28, width / 30));\\n  const nodeRadius = baseUnit * 1.2;\\n  const font = api.getFont('default');\\n\\n  // Tree data structure\\n  // winner: who ultimately wins from this position (computed via backward induction)\\n  // leafWinner: only on leaf nodes, who won the game at that terminal state\\n  const tree = {\\n    coins: 4, player: 'A', winner: 'A', children: [\\n      { coins: 3, player: 'B', winner: 'A', children: [\\n        { coins: 2, player: 'A', winner: 'A', annotation: true, children: [\\n          { coins: 1, player: 'B', winner: 'B', children: [\\n            { coins: 0, isLeaf: true, leafWinner: 'B' }\\n          ]},\\n          { coins: 0, isLeaf: true, leafWinner: 'A' }\\n        ]},\\n        { coins: 1, player: 'A', winner: 'A', children: [\\n          { coins: 0, isLeaf: true, leafWinner: 'A' }\\n        ]}\\n      ]},\\n      { coins: 2, player: 'B', winner: 'B', children: [\\n        { coins: 1, player: 'A', winner: 'A', children: [\\n          { coins: 0, isLeaf: true, leafWinner: 'A' }\\n        ]},\\n        { coins: 0, isLeaf: true, leafWinner: 'B' }\\n      ]}\\n    ]\\n  };\\n\\n  // Determine node color based on stage\\n  function getNodeColor(node) {\\n    if (stage === 1) return null; // neutral\\n    if (stage === 2) {\\n      if (node.isLeaf) return node.leafWinner === 'A' ? playerAColor : playerBColor;\\n      // Color internal nodes only if all descendants agree on winner\\n      const allDescendants = [];\\n      function collect(n) {\\n        if (n.isLeaf) { allDescendants.push(n.leafWinner); return; }\\n        if (n.children) n.children.forEach(collect);\\n      }\\n      collect(node);\\n      const allSame = allDescendants.every(w =\u003e w === allDescendants[0]);\\n      if (allSame) return allDescendants[0] === 'A' ? playerAColor : playerBColor;\\n      return null;\\n    }\\n    // stage 3: all nodes colored by winner\\n    if (node.isLeaf) return node.leafWinner === 'A' ? playerAColor : playerBColor;\\n    return node.winner === 'A' ? playerAColor : playerBColor;\\n  }\\n\\n  // Layout calculations\\n  function countLeaves(node) {\\n    if (!node.children || node.children.length === 0) return 1;\\n    return node.children.reduce((sum, c) =\u003e sum + countLeaves(c), 0);\\n  }\\n\\n  function getDepth(node) {\\n    if (!node.children || node.children.length === 0) return 0;\\n    return 1 + Math.max(...node.children.map(getDepth));\\n  }\\n\\n  const totalLeaves = countLeaves(tree);\\n  const maxDepth = getDepth(tree);\\n\\n  const hSpacing = nodeRadius * 4;\\n  const vSpacing = nodeRadius * 5;\\n  const topPadding = nodeRadius * 2;\\n  const bottomPadding = nodeRadius * 3;\\n  const annotationSpace = stage === 2 ? nodeRadius * 4 : 0;\\n\\n  const treeWidth = (totalLeaves - 1) * hSpacing;\\n  const treeHeight = maxDepth * vSpacing;\\n\\n  const canvasWidth = Math.max(width, treeWidth + nodeRadius * 4 + annotationSpace);\\n  const canvasHeight = treeHeight + topPadding + bottomPadding;\\n  canvas.width = canvasWidth;\\n  canvas.height = canvasHeight;\\n\\n  // Assign positions bottom-up\\n  let leafIndex = 0;\\n  const treeLeft = (canvasWidth - treeWidth) / 2;\\n\\n  function assignPositions(node, depth) {\\n    const y = topPadding + depth * vSpacing;\\n    if (!node.children || node.children.length === 0) {\\n      node.x = treeLeft + leafIndex * hSpacing;\\n      node.y = y;\\n      leafIndex++;\\n      return;\\n    }\\n    node.children.forEach(c =\u003e assignPositions(c, depth + 1));\\n    const childXs = node.children.map(c =\u003e c.x);\\n    node.x = (Math.min(...childXs) + Math.max(...childXs)) / 2;\\n    node.y = y;\\n  }\\n\\n  assignPositions(tree, 0);\\n\\n  // Draw arrow with arrowhead\\n  function drawArrow(x1, y1, x2, y2, color) {\\n    const headLen = baseUnit * 0.4;\\n    const angle = Math.atan2(y2 - y1, x2 - x1);\\n    const tipX = x2;\\n    const tipY = y2;\\n\\n    ctx.strokeStyle = color;\\n    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);\\n    ctx.beginPath();\\n    ctx.moveTo(x1, y1);\\n    ctx.lineTo(tipX - headLen * Math.cos(angle), tipY - headLen * Math.sin(angle));\\n    ctx.stroke();\\n\\n    // Arrowhead\\n    ctx.fillStyle = color;\\n    ctx.beginPath();\\n    ctx.moveTo(tipX, tipY);\\n    ctx.lineTo(tipX - headLen * Math.cos(angle - 0.35), tipY - headLen * Math.sin(angle - 0.35));\\n    ctx.lineTo(tipX - headLen * Math.cos(angle + 0.35), tipY - headLen * Math.sin(angle + 0.35));\\n    ctx.closePath();\\n    ctx.fill();\\n  }\\n\\n  // Draw edges\\n  function drawEdges(node) {\\n    if (!node.children) return;\\n    node.children.forEach(child =\u003e {\\n      const edgeColor = node.player === 'A' ? playerAColor : playerBColor;\\n      drawArrow(node.x, node.y + nodeRadius, child.x, child.y - nodeRadius, edgeColor);\\n\\n      // Edge label: at midpoint of the line, offset to the side\\n      const coinsTaken = node.coins - child.coins;\\n      const labelSize = Math.max(9, baseUnit * 0.42);\\n      const lineHeight = labelSize * 1.4;\\n      ctx.font = `${labelSize}px ${font}`;\\n      ctx.fillStyle = edgeColor;\\n      ctx.textBaseline = 'middle';\\n      const midX = (node.x + child.x) / 2;\\n      const midY = (node.y + nodeRadius + child.y - nodeRadius) / 2;\\n      const numChildren = node.children.length;\\n      if (numChildren === 1) {\\n        // Single child: label to the right of the midpoint\\n        ctx.textAlign = 'left';\\n        ctx.fillText(`take ${coinsTaken}`, midX + lineHeight * 0.5, midY);\\n      } else {\\n        // Two children: left child label on left, right child label on right\\n        const isLeftChild = child.x \u003c node.x || (child.x === node.x \u0026\u0026 node.children.indexOf(child) === 0);\\n        if (isLeftChild) {\\n          ctx.textAlign = 'right';\\n          ctx.fillText(`take ${coinsTaken}`, midX - lineHeight, midY);\\n        } else {\\n          ctx.textAlign = 'left';\\n          ctx.fillText(`take ${coinsTaken}`, midX + lineHeight, midY);\\n        }\\n      }\\n\\n      drawEdges(child);\\n    });\\n  }\\n\\n  drawEdges(tree);\\n\\n  // Draw nodes\\n  function drawNode(node) {\\n    const { x, y } = node;\\n    const color = getNodeColor(node);\\n    const strokeColor = color || fgColor;\\n    const fillBgColor = color || fgColor;\\n\\n    // Circle background\\n    ctx.fillStyle = fillBgColor;\\n    ctx.globalAlpha = color ? 0.15 : 0.04;\\n    ctx.beginPath();\\n    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n    ctx.globalAlpha = 1.0;\\n\\n    // Circle border\\n    ctx.strokeStyle = strokeColor;\\n    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);\\n    ctx.beginPath();\\n    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);\\n    ctx.stroke();\\n\\n    // Coin count number\\n    const numSize = Math.max(12, baseUnit * 0.7);\\n    ctx.font = `bold ${numSize}px ${font}`;\\n    ctx.fillStyle = color || fgColor;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'middle';\\n    ctx.fillText(`${node.coins}`, x, y - numSize * 0.15);\\n\\n    // \\\"coins\\\" label below the number (inside the circle)\\n    const coinsLabelSize = Math.max(8, baseUnit * 0.38);\\n    ctx.font = `${coinsLabelSize}px ${font}`;\\n    ctx.fillStyle = color || fgColor;\\n    ctx.fillText(node.coins === 1 ? 'coin' : 'coins', x, y + numSize * 0.45);\\n\\n    // Below-node label: \\\"A wins\\\" / \\\"B wins\\\" for leaf nodes\\n    if (node.isLeaf) {\\n      const winColor = node.leafWinner === 'A' ? playerAColor : playerBColor;\\n      const winSize = Math.max(8, baseUnit * 0.4);\\n      ctx.font = `bold ${winSize}px ${font}`;\\n      ctx.fillStyle = stage === 1 ? fgColor : winColor;\\n      ctx.fillText(node.leafWinner === 'A' ? 'You win' : 'Opponent wins', x, y + nodeRadius + winSize * 1.2);\\n    }\\n\\n    // Annotation arrow for sample node (stage 2 only)\\n    if (node.annotation \u0026\u0026 stage === 2) {\\n      const arrowStartX = x - nodeRadius - baseUnit * 2;\\n      const arrowEndX = x - nodeRadius - baseUnit * 0.4;\\n      const arrowY = y;\\n\\n      ctx.strokeStyle = fgColor;\\n      ctx.lineWidth = Math.max(1, baseUnit * 0.06);\\n      ctx.beginPath();\\n      ctx.moveTo(arrowStartX, arrowY);\\n      ctx.lineTo(arrowEndX, arrowY);\\n      ctx.stroke();\\n\\n      // Arrowhead pointing right (toward node)\\n      const headSize = baseUnit * 0.25;\\n      ctx.fillStyle = fgColor;\\n      ctx.beginPath();\\n      ctx.moveTo(arrowEndX, arrowY);\\n      ctx.lineTo(arrowEndX - headSize, arrowY - headSize * 0.6);\\n      ctx.lineTo(arrowEndX - headSize, arrowY + headSize * 0.6);\\n      ctx.closePath();\\n      ctx.fill();\\n\\n      const annotSize = Math.max(8, baseUnit * 0.42);\\n      ctx.font = `italic ${annotSize}px ${font}`;\\n      ctx.fillStyle = fgColor;\\n      ctx.textAlign = 'right';\\n      ctx.textBaseline = 'middle';\\n      ctx.fillText('Node S', arrowStartX - baseUnit * 0.3, arrowY);\\n    }\\n\\n    if (node.children) node.children.forEach(drawNode);\\n  }\\n\\n  drawNode(tree);\\n}\\n```\\n:::\\n\",\"dynamicBlocks\",[34,44,51,55],{\"_35\":36,\"_37\":38,\"_39\":40,\"_15\":41,\"_42\":43},\"type\",\"dynamic\",\"mode\",\"component\",\"componentId\",\"#tic-tac-toe-tree\",\"Tic-tac-toe game tree showing first two levels of moves\",\"sourceFile\",\"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/expeditions/adversarial-games.md\",{\"_35\":36,\"_37\":38,\"_39\":45,\"_46\":47,\"_15\":50,\"_42\":43},\"#coin-game-tree\",\"props\",{\"_48\":49},\"stage\",1,\"Game tree for the stack of coins game with 4 coins\",{\"_35\":36,\"_37\":38,\"_39\":45,\"_46\":52,\"_15\":54,\"_42\":43},{\"_48\":53},2,\"Game tree with leaf nodes and simple branches colored\",{\"_35\":36,\"_37\":38,\"_39\":45,\"_46\":56,\"_15\":58,\"_42\":43},{\"_48\":57},3,\"Fully colored game tree showing winning positions\",\"inlineComponents\",{\"_61\":62,\"_67\":68},\"tic-tac-toe-tree\",{\"_13\":61,\"_63\":64,\"_65\":66},\"code\",\"function draw(options) {\\n  const { canvas, api, width } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Calculate responsive sizing - base unit for level 2 (smallest boards)\\n  const baseCellSize = Math.max(10, Math.min(30, width / 50));\\n\\n  // Different sizes for each level\\n  const level2CellSize = baseCellSize;          // Level 2: base size (1x)\\n  const level1CellSize = baseCellSize * 1.5;      // Level 1: 1.5x bigger\\n  const level0CellSize = baseCellSize * 2;      // Level 0 (root): 2x bigger\\n\\n  const level2BoardSize = level2CellSize * 3;\\n  const level1BoardSize = level1CellSize * 3;\\n  const level0BoardSize = level0CellSize * 3;\\n\\n  const boardGap = level2CellSize * 0.5; // Gap between boards at level 2\\n  const levelHeight = level0BoardSize * 1.4; // Space between levels\\n\\n  // Board state definitions (0 = empty, 1 = X, 2 = O)\\n  // Grid positions: 0=top-left, 1=top-mid, 2=top-right, 3=mid-left, 4=center, 5=mid-right, 6=bot-left, 7=bot-mid, 8=bot-right\\n  const boards = {\\n    A: [0, 0, 0, 0, 0, 0, 0, 0, 0],  // empty\\n    // Level 1: X first moves (corner, edge, center)\\n    B: [1, 0, 0, 0, 0, 0, 0, 0, 0],  // X__/___/___  (corner)\\n    C: [0, 1, 0, 0, 0, 0, 0, 0, 0],  // _X_/___/___  (edge)\\n    D: [0, 0, 0, 0, 1, 0, 0, 0, 0],  // ___/_X_/___  (center)\\n    // Children of B (corner X) - O responses\\n    E: [1, 0, 0, 2, 0, 0, 0, 0, 0],  // X__/O__/___\\n    F: [1, 0, 0, 0, 0, 0, 2, 0, 0],  // X__/___/O__\\n    G: [1, 0, 0, 0, 2, 0, 0, 0, 0],  // X__/_O_/___\\n    H: [1, 0, 0, 0, 0, 0, 0, 2, 0],  // X__/___/_O_\\n    I: [1, 0, 0, 0, 0, 0, 0, 0, 2],  // X__/___/__O\\n    // Children of C (edge X) - O responses\\n    J: [2, 1, 0, 0, 0, 0, 0, 0, 0],  // OX_/___/___\\n    K: [0, 1, 0, 2, 0, 0, 0, 0, 0],  // _X_/O__/___\\n    L: [0, 1, 0, 0, 0, 0, 2, 0, 0],  // _X_/___/O__\\n    M: [0, 1, 0, 0, 2, 0, 0, 0, 0],  // _X_/_O_/___\\n    N: [0, 1, 0, 0, 0, 0, 0, 2, 0],  // _X_/___/_O_\\n    // Children of D (center X) - O responses\\n    O: [2, 0, 0, 0, 1, 0, 0, 0, 0],  // O__/_X_/___\\n    P: [0, 2, 0, 0, 1, 0, 0, 0, 0],  // _O_/_X_/___\\n  };\\n\\n  // Tree structure: each level 1 node has children at level 2\\n  const tree = [\\n    { board: 'B', children: ['E', 'F', 'G', 'H', 'I'] },\\n    { board: 'C', children: ['J', 'K', 'L', 'M', 'N'] },\\n    { board: 'D', children: ['O', 'P'] }\\n  ];\\n\\n  // Calculate total width needed for level 2\\n  const level2Widths = tree.map(node =\u003e node.children.length * level2BoardSize + (node.children.length - 1) * boardGap);\\n  const groupGap = level2BoardSize * 0.75; // Gap between groups\\n  const totalLevel2Width = level2Widths.reduce((a, b) =\u003e a + b, 0) + (tree.length - 1) * groupGap;\\n\\n  // Canvas dimensions\\n  const canvasWidth = Math.max(width, totalLevel2Width + level2BoardSize);\\n  const height = level0BoardSize + levelHeight * 2 + level2BoardSize + baseCellSize * 2;\\n  canvas.width = canvasWidth;\\n  canvas.height = height;\\n\\n  // Get theme colors\\n  const fgColor = api.getColor('foreground');\\n  const mutedColor = api.getColor('muted-foreground');\\n\\n  // Draw a single tic-tac-toe board (no label)\\n  // cellSz: cell size for this board\\n  function drawBoard(x, y, state, cellSz) {\\n    const brdSize = cellSz * 3;\\n\\n    // Draw grid\\n    ctx.strokeStyle = mutedColor;\\n    ctx.lineWidth = 1;\\n\\n    for (let i = 1; i \u003c 3; i++) {\\n      ctx.beginPath();\\n      ctx.moveTo(x + i * cellSz, y);\\n      ctx.lineTo(x + i * cellSz, y + brdSize);\\n      ctx.stroke();\\n\\n      ctx.beginPath();\\n      ctx.moveTo(x, y + i * cellSz);\\n      ctx.lineTo(x + brdSize, y + i * cellSz);\\n      ctx.stroke();\\n    }\\n\\n    // Draw X's and O's\\n    for (let i = 0; i \u003c 9; i++) {\\n      const row = Math.floor(i / 3);\\n      const col = i % 3;\\n      const cellX = x + col * cellSz + cellSz / 2;\\n      const cellY = y + row * cellSz + cellSz / 2;\\n\\n      if (state[i] === 1) {\\n        ctx.strokeStyle = fgColor;\\n        ctx.lineWidth = 2;\\n        const offset = cellSz * 0.25;\\n        ctx.beginPath();\\n        ctx.moveTo(cellX - offset, cellY - offset);\\n        ctx.lineTo(cellX + offset, cellY + offset);\\n        ctx.stroke();\\n        ctx.beginPath();\\n        ctx.moveTo(cellX + offset, cellY - offset);\\n        ctx.lineTo(cellX - offset, cellY + offset);\\n        ctx.stroke();\\n      } else if (state[i] === 2) {\\n        ctx.strokeStyle = fgColor;\\n        ctx.lineWidth = 2;\\n        const radius = cellSz * 0.25;\\n        ctx.beginPath();\\n        ctx.arc(cellX, cellY, radius, 0, Math.PI * 2);\\n        ctx.stroke();\\n      }\\n    }\\n\\n    return { x: x + brdSize / 2, y: y + brdSize / 2, size: brdSize };\\n  }\\n\\n  // Padding between board edges and connector lines\\n  const connectorPadding = baseCellSize * 0.4;\\n\\n  // Draw connecting line (paler using reduced opacity)\\n  function drawLine(x1, y1, x2, y2) {\\n    ctx.strokeStyle = fgColor;\\n    ctx.globalAlpha = 0.6;\\n    ctx.lineWidth = 1;\\n    ctx.beginPath();\\n    ctx.moveTo(x1, y1);\\n    ctx.lineTo(x2, y2);\\n    ctx.stroke();\\n    ctx.globalAlpha = 1.0;\\n  }\\n\\n  // Calculate positions for level 2 first (bottom-up layout)\\n  const level2Y = level0BoardSize + levelHeight * 2 - level2BoardSize;\\n  let currentX = (canvasWidth - totalLevel2Width) / 2;\\n\\n  const level2Positions = [];\\n  const level1Centers = [];\\n\\n  tree.forEach((node, groupIndex) =\u003e {\\n    const groupPositions = [];\\n    node.children.forEach((childBoard, childIndex) =\u003e {\\n      const x = currentX + childIndex * (level2BoardSize + boardGap);\\n      groupPositions.push({ board: childBoard, x, y: level2Y });\\n    });\\n    level2Positions.push(groupPositions);\\n\\n    // Calculate level 1 center (above the middle of its children)\\n    const groupLeft = currentX;\\n    const groupRight = currentX + (node.children.length - 1) * (level2BoardSize + boardGap) + level2BoardSize;\\n    const level1CenterX = (groupLeft + groupRight) / 2;\\n    level1Centers.push({ board: node.board, centerX: level1CenterX });\\n\\n    currentX = groupRight + groupGap;\\n  });\\n\\n  // Level 1 Y position\\n  const level1Y = level0BoardSize + levelHeight - level1BoardSize / 2;\\n\\n  // Level 0 (root) position - centered above level 1\\n  const rootX = canvasWidth / 2 - level0BoardSize / 2;\\n  const rootY = baseCellSize;\\n  const rootCenter = drawBoard(rootX, rootY, boards.A, level0CellSize);\\n\\n  // Draw level 1 nodes and lines from root\\n  const level1Positions = level1Centers.map(item =\u003e ({\\n    board: item.board,\\n    x: item.centerX - level1BoardSize / 2,\\n    y: level1Y\\n  }));\\n\\n  // Draw level 1 nodes with fanned-out lines from root\\n  const level1SpreadWidth = level0BoardSize * 0.6;\\n  level1Positions.forEach((pos, index) =\u003e {\\n    const center = drawBoard(pos.x, pos.y, boards[pos.board], level1CellSize);\\n    // Calculate spread-out start position on root board\\n    const numChildren = level1Positions.length;\\n    const startX = numChildren === 1\\n      ? rootCenter.x\\n      : rootCenter.x - level1SpreadWidth / 2 + (index * level1SpreadWidth / (numChildren - 1));\\n    drawLine(startX, rootCenter.y + level0BoardSize / 2 + connectorPadding, center.x, center.y - level1BoardSize / 2 - connectorPadding);\\n  });\\n\\n  // Draw level 2 nodes and lines from level 1 with fanned-out connections\\n  // Spread width scales with number of children (max spread for 5 children)\\n  const maxSpreadWidth = level1BoardSize * 0.6;\\n  level2Positions.forEach((group, groupIndex) =\u003e {\\n    const parentPos = level1Positions[groupIndex];\\n    const parentCenter = { x: parentPos.x + level1BoardSize / 2, y: parentPos.y + level1BoardSize / 2 };\\n\\n    const numChildren = group.length;\\n    // Scale spread based on number of children (fewer children = narrower spread)\\n    const level2SpreadWidth = numChildren \u003c= 1 ? 0 : maxSpreadWidth * (numChildren - 1) / 4;\\n\\n    group.forEach((pos, childIndex) =\u003e {\\n      const center = drawBoard(pos.x, pos.y, boards[pos.board], level2CellSize);\\n      // Calculate spread-out start position on parent board\\n      const startX = numChildren === 1\\n        ? parentCenter.x\\n        : parentCenter.x - level2SpreadWidth / 2 + (childIndex * level2SpreadWidth / (numChildren - 1));\\n      drawLine(startX, parentCenter.y + level1BoardSize / 2 + connectorPadding, center.x, center.y - level2BoardSize / 2 - connectorPadding);\\n    });\\n\\n    // Draw \\\"...\\\" below each group\\n    ctx.fillStyle = mutedColor;\\n    ctx.font = `${Math.max(12, baseCellSize)}px ${api.getFont('default')}`;\\n    ctx.textAlign = 'center';\\n    ctx.fillText('...', parentCenter.x, level2Y + level2BoardSize + baseCellSize);\\n  });\\n}\",\"startLine\",136,\"coin-game-tree\",{\"_13\":67,\"_63\":69,\"_65\":70},\"function draw(options) {\\n  const { canvas, api, width, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Stage: 1 = neutral, 2 = leaves colored + sample node, 3 = all colored\\n  const stage = props.stage || 1;\\n\\n  // Theme colors\\n  const fgColor = api.getColor('foreground');\\n  const mutedColor = api.getColor('muted-foreground');\\n  const isLight = api.theme === 'light';\\n  const playerAColor = isLight ? api.getColor('red-600', { chroma: 0.05 }) : api.getColor('red-300', { chroma: 0.05 });\\n  const playerBColor = isLight ? api.getColor('blue-600', { chroma: 0.05 }) : api.getColor('blue-300', { chroma: 0.05 });\\n\\n  // Responsive sizing\\n  const baseUnit = Math.max(12, Math.min(28, width / 30));\\n  const nodeRadius = baseUnit * 1.2;\\n  const font = api.getFont('default');\\n\\n  // Tree data structure\\n  // winner: who ultimately wins from this position (computed via backward induction)\\n  // leafWinner: only on leaf nodes, who won the game at that terminal state\\n  const tree = {\\n    coins: 4, player: 'A', winner: 'A', children: [\\n      { coins: 3, player: 'B', winner: 'A', children: [\\n        { coins: 2, player: 'A', winner: 'A', annotation: true, children: [\\n          { coins: 1, player: 'B', winner: 'B', children: [\\n            { coins: 0, isLeaf: true, leafWinner: 'B' }\\n          ]},\\n          { coins: 0, isLeaf: true, leafWinner: 'A' }\\n        ]},\\n        { coins: 1, player: 'A', winner: 'A', children: [\\n          { coins: 0, isLeaf: true, leafWinner: 'A' }\\n        ]}\\n      ]},\\n      { coins: 2, player: 'B', winner: 'B', children: [\\n        { coins: 1, player: 'A', winner: 'A', children: [\\n          { coins: 0, isLeaf: true, leafWinner: 'A' }\\n        ]},\\n        { coins: 0, isLeaf: true, leafWinner: 'B' }\\n      ]}\\n    ]\\n  };\\n\\n  // Determine node color based on stage\\n  function getNodeColor(node) {\\n    if (stage === 1) return null; // neutral\\n    if (stage === 2) {\\n      if (node.isLeaf) return node.leafWinner === 'A' ? playerAColor : playerBColor;\\n      // Color internal nodes only if all descendants agree on winner\\n      const allDescendants = [];\\n      function collect(n) {\\n        if (n.isLeaf) { allDescendants.push(n.leafWinner); return; }\\n        if (n.children) n.children.forEach(collect);\\n      }\\n      collect(node);\\n      const allSame = allDescendants.every(w =\u003e w === allDescendants[0]);\\n      if (allSame) return allDescendants[0] === 'A' ? playerAColor : playerBColor;\\n      return null;\\n    }\\n    // stage 3: all nodes colored by winner\\n    if (node.isLeaf) return node.leafWinner === 'A' ? playerAColor : playerBColor;\\n    return node.winner === 'A' ? playerAColor : playerBColor;\\n  }\\n\\n  // Layout calculations\\n  function countLeaves(node) {\\n    if (!node.children || node.children.length === 0) return 1;\\n    return node.children.reduce((sum, c) =\u003e sum + countLeaves(c), 0);\\n  }\\n\\n  function getDepth(node) {\\n    if (!node.children || node.children.length === 0) return 0;\\n    return 1 + Math.max(...node.children.map(getDepth));\\n  }\\n\\n  const totalLeaves = countLeaves(tree);\\n  const maxDepth = getDepth(tree);\\n\\n  const hSpacing = nodeRadius * 4;\\n  const vSpacing = nodeRadius * 5;\\n  const topPadding = nodeRadius * 2;\\n  const bottomPadding = nodeRadius * 3;\\n  const annotationSpace = stage === 2 ? nodeRadius * 4 : 0;\\n\\n  const treeWidth = (totalLeaves - 1) * hSpacing;\\n  const treeHeight = maxDepth * vSpacing;\\n\\n  const canvasWidth = Math.max(width, treeWidth + nodeRadius * 4 + annotationSpace);\\n  const canvasHeight = treeHeight + topPadding + bottomPadding;\\n  canvas.width = canvasWidth;\\n  canvas.height = canvasHeight;\\n\\n  // Assign positions bottom-up\\n  let leafIndex = 0;\\n  const treeLeft = (canvasWidth - treeWidth) / 2;\\n\\n  function assignPositions(node, depth) {\\n    const y = topPadding + depth * vSpacing;\\n    if (!node.children || node.children.length === 0) {\\n      node.x = treeLeft + leafIndex * hSpacing;\\n      node.y = y;\\n      leafIndex++;\\n      return;\\n    }\\n    node.children.forEach(c =\u003e assignPositions(c, depth + 1));\\n    const childXs = node.children.map(c =\u003e c.x);\\n    node.x = (Math.min(...childXs) + Math.max(...childXs)) / 2;\\n    node.y = y;\\n  }\\n\\n  assignPositions(tree, 0);\\n\\n  // Draw arrow with arrowhead\\n  function drawArrow(x1, y1, x2, y2, color) {\\n    const headLen = baseUnit * 0.4;\\n    const angle = Math.atan2(y2 - y1, x2 - x1);\\n    const tipX = x2;\\n    const tipY = y2;\\n\\n    ctx.strokeStyle = color;\\n    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);\\n    ctx.beginPath();\\n    ctx.moveTo(x1, y1);\\n    ctx.lineTo(tipX - headLen * Math.cos(angle), tipY - headLen * Math.sin(angle));\\n    ctx.stroke();\\n\\n    // Arrowhead\\n    ctx.fillStyle = color;\\n    ctx.beginPath();\\n    ctx.moveTo(tipX, tipY);\\n    ctx.lineTo(tipX - headLen * Math.cos(angle - 0.35), tipY - headLen * Math.sin(angle - 0.35));\\n    ctx.lineTo(tipX - headLen * Math.cos(angle + 0.35), tipY - headLen * Math.sin(angle + 0.35));\\n    ctx.closePath();\\n    ctx.fill();\\n  }\\n\\n  // Draw edges\\n  function drawEdges(node) {\\n    if (!node.children) return;\\n    node.children.forEach(child =\u003e {\\n      const edgeColor = node.player === 'A' ? playerAColor : playerBColor;\\n      drawArrow(node.x, node.y + nodeRadius, child.x, child.y - nodeRadius, edgeColor);\\n\\n      // Edge label: at midpoint of the line, offset to the side\\n      const coinsTaken = node.coins - child.coins;\\n      const labelSize = Math.max(9, baseUnit * 0.42);\\n      const lineHeight = labelSize * 1.4;\\n      ctx.font = `${labelSize}px ${font}`;\\n      ctx.fillStyle = edgeColor;\\n      ctx.textBaseline = 'middle';\\n      const midX = (node.x + child.x) / 2;\\n      const midY = (node.y + nodeRadius + child.y - nodeRadius) / 2;\\n      const numChildren = node.children.length;\\n      if (numChildren === 1) {\\n        // Single child: label to the right of the midpoint\\n        ctx.textAlign = 'left';\\n        ctx.fillText(`take ${coinsTaken}`, midX + lineHeight * 0.5, midY);\\n      } else {\\n        // Two children: left child label on left, right child label on right\\n        const isLeftChild = child.x \u003c node.x || (child.x === node.x \u0026\u0026 node.children.indexOf(child) === 0);\\n        if (isLeftChild) {\\n          ctx.textAlign = 'right';\\n          ctx.fillText(`take ${coinsTaken}`, midX - lineHeight, midY);\\n        } else {\\n          ctx.textAlign = 'left';\\n          ctx.fillText(`take ${coinsTaken}`, midX + lineHeight, midY);\\n        }\\n      }\\n\\n      drawEdges(child);\\n    });\\n  }\\n\\n  drawEdges(tree);\\n\\n  // Draw nodes\\n  function drawNode(node) {\\n    const { x, y } = node;\\n    const color = getNodeColor(node);\\n    const strokeColor = color || fgColor;\\n    const fillBgColor = color || fgColor;\\n\\n    // Circle background\\n    ctx.fillStyle = fillBgColor;\\n    ctx.globalAlpha = color ? 0.15 : 0.04;\\n    ctx.beginPath();\\n    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n    ctx.globalAlpha = 1.0;\\n\\n    // Circle border\\n    ctx.strokeStyle = strokeColor;\\n    ctx.lineWidth = Math.max(1.5, baseUnit * 0.08);\\n    ctx.beginPath();\\n    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);\\n    ctx.stroke();\\n\\n    // Coin count number\\n    const numSize = Math.max(12, baseUnit * 0.7);\\n    ctx.font = `bold ${numSize}px ${font}`;\\n    ctx.fillStyle = color || fgColor;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'middle';\\n    ctx.fillText(`${node.coins}`, x, y - numSize * 0.15);\\n\\n    // \\\"coins\\\" label below the number (inside the circle)\\n    const coinsLabelSize = Math.max(8, baseUnit * 0.38);\\n    ctx.font = `${coinsLabelSize}px ${font}`;\\n    ctx.fillStyle = color || fgColor;\\n    ctx.fillText(node.coins === 1 ? 'coin' : 'coins', x, y + numSize * 0.45);\\n\\n    // Below-node label: \\\"A wins\\\" / \\\"B wins\\\" for leaf nodes\\n    if (node.isLeaf) {\\n      const winColor = node.leafWinner === 'A' ? playerAColor : playerBColor;\\n      const winSize = Math.max(8, baseUnit * 0.4);\\n      ctx.font = `bold ${winSize}px ${font}`;\\n      ctx.fillStyle = stage === 1 ? fgColor : winColor;\\n      ctx.fillText(node.leafWinner === 'A' ? 'You win' : 'Opponent wins', x, y + nodeRadius + winSize * 1.2);\\n    }\\n\\n    // Annotation arrow for sample node (stage 2 only)\\n    if (node.annotation \u0026\u0026 stage === 2) {\\n      const arrowStartX = x - nodeRadius - baseUnit * 2;\\n      const arrowEndX = x - nodeRadius - baseUnit * 0.4;\\n      const arrowY = y;\\n\\n      ctx.strokeStyle = fgColor;\\n      ctx.lineWidth = Math.max(1, baseUnit * 0.06);\\n      ctx.beginPath();\\n      ctx.moveTo(arrowStartX, arrowY);\\n      ctx.lineTo(arrowEndX, arrowY);\\n      ctx.stroke();\\n\\n      // Arrowhead pointing right (toward node)\\n      const headSize = baseUnit * 0.25;\\n      ctx.fillStyle = fgColor;\\n      ctx.beginPath();\\n      ctx.moveTo(arrowEndX, arrowY);\\n      ctx.lineTo(arrowEndX - headSize, arrowY - headSize * 0.6);\\n      ctx.lineTo(arrowEndX - headSize, arrowY + headSize * 0.6);\\n      ctx.closePath();\\n      ctx.fill();\\n\\n      const annotSize = Math.max(8, baseUnit * 0.42);\\n      ctx.font = `italic ${annotSize}px ${font}`;\\n      ctx.fillStyle = fgColor;\\n      ctx.textAlign = 'right';\\n      ctx.textBaseline = 'middle';\\n      ctx.fillText('Node S', arrowStartX - baseUnit * 0.3, arrowY);\\n    }\\n\\n    if (node.children) node.children.forEach(drawNode);\\n  }\\n\\n  drawNode(tree);\\n}\",353,\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>