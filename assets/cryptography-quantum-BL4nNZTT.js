const s={slug:"cryptography-quantum",metadata:{title:"Post-Quantum Cryptography",questionPreview:`Quantum computers will break RSA and most current encryption. What mathematical problems can resist even quantum attacks?
`,concepts:["cryptography","computational-complexity","quantum-computing"],difficulty:"master",tags:["series","quantum-resistant","modern-cryptography"],dateCreated:"2025-10-22T00:00:00.000Z",lastUpdated:"2025-10-22T00:00:00.000Z",previousPuzzle:"cryptography-rsa"},content:`<h2 class="markdown-h1">The Quantum Threat</h2>
<p>Shor's algorithm (1994) proved that a sufficiently powerful quantum computer can:</p>
<ul>
<li>Factor large numbers in polynomial time (breaking RSA)</li>
<li>Solve discrete logarithm problems (breaking Diffie-Hellman, elliptic curve cryptography)</li>
</ul>
<p>This threatens virtually all current public-key cryptography. When large-scale quantum computers exist, encrypted data — including data encrypted today — will be vulnerable.</p>
<h2 class="markdown-h1">Post-Quantum Cryptography</h2>
<p>Cryptographers are developing encryption methods based on problems believed to be hard even for quantum computers:</p>
<ol>
<li><strong>Lattice-based cryptography</strong> — Problems about high-dimensional lattices</li>
<li><strong>Code-based cryptography</strong> — Decoding random linear codes</li>
<li><strong>Hash-based signatures</strong> — Using cryptographic hash functions</li>
<li><strong>Multivariate polynomial cryptography</strong> — Solving systems of polynomials</li>
<li><strong>Isogeny-based cryptography</strong> — Computing isogenies between elliptic curves</li>
</ol>
<h2 class="markdown-h1">The Challenge</h2>
<p>Explore the hardness foundations of post-quantum cryptography:</p>
<p><strong>Part A</strong>: The <strong>Shortest Vector Problem (SVP)</strong> asks: given a lattice (a discrete grid of points in n-dimensional space), find the shortest non-zero vector. Why is this problem believed to be hard for both classical and quantum computers?</p>
<p><strong>Part B</strong>: The <strong>Learning With Errors (LWE)</strong> problem is the foundation of many lattice-based schemes. Given many linear equations with small random errors added, recover the secret. Explain why adding small errors transforms an easy problem (solving linear equations) into a presumably hard one.</p>
<p><strong>Part C</strong>: <strong>NIST Post-Quantum Cryptography Standardization</strong> (2016-2024) selected algorithms for standardisation. Research what NIST chose and explain the trade-offs between security level, key size, and performance.</p>
<p><strong>Part D</strong>: What is "harvest now, decrypt later"? Why does this threat require migrating to post-quantum cryptography before large quantum computers exist?</p>
<details class="hint-block" data-type="hint"><summary class="hint-label">Hint</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>For Part A, consider that SVP is believed to be NP-hard. Quantum computers provide speedup for some problems but not all NP-hard problems.</p></div></details>
<details class="hint-block" data-type="hint"><summary class="hint-label">Hint</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>Grover's algorithm gives quantum computers a quadratic speedup for unstructured search, but this only requires doubling key sizes for symmetric encryption.</p></div></details>
<details class="hint-block" data-type="hint"><summary class="hint-label">Hint</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>For Part B, think about how noise in measurements affects what information can be extracted. Small errors compound in surprising ways.</p></div></details>
<details class="hint-block" data-type="hint"><summary class="hint-label">Hint</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>For Part C, NIST selected CRYSTALS-Kyber for encryption and CRYSTALS-Dilithium, Falcon, and SPHINCS+ for signatures. Research their properties.</p></div></details>
<details class="solution-block" data-type="solution"><summary class="solution-label">Solution</summary><div class="solution-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p><strong>Answer</strong>: A) SVP is NP-hard under certain reductions; quantum algorithms don't solve all NP-hard problems efficiently. B) Errors prevent using Gaussian elimination; recovering the secret requires solving an exponentially hard problem. C) See detailed comparison below. D) Adversaries can record encrypted data now and decrypt it later once quantum computers exist.</p><h3 class="markdown-h2">Part A: Shortest Vector Problem</h3><p>The <strong>Shortest Vector Problem (SVP)</strong>: Given a basis for an n-dimensional lattice, find the shortest non-zero vector in the lattice.</p><p><strong>Example (2D)</strong>:
Consider a lattice generated by basis vectors v₁ = (1, 0) and v₂ = (1, 2). The lattice consists of all points a·v₁ + b·v₂ where a, b are integers. The shortest non-zero vector is (1, 0) with length 1.</p><p>For poorly chosen bases in high dimensions, finding the shortest vector becomes extraordinarily difficult.</p><p><strong>Why It's Hard</strong>:</p><ol>
<li><strong>Worst-case hardness</strong>: SVP is NP-hard under randomised reductions (Ajtai, 1996)</li>
<li><strong>No quantum shortcut</strong>: Known quantum algorithms (including Grover's) provide at most a modest speedup, not the exponential speedup that breaks RSA</li>
<li><strong>Best known algorithms</strong>: The fastest algorithms (like sieving methods) require time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">2^{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> for dimension n, even on quantum computers</li>
<li><strong>High dimensions</strong>: Post-quantum schemes use dimensions n ≈ 500-1000, making attacks infeasible</li>
</ol><p><strong>Quantum resistance</strong>: While quantum computers excel at problems with hidden structure (like factoring), lattice problems appear to lack exploitable structure. After decades of research, no efficient quantum algorithm for SVP exists.</p><h3 class="markdown-h2">Part B: Learning With Errors (LWE)</h3><p><strong>Setup</strong>: Alice has a secret vector <strong>s</strong> = (s₁, s₂, ..., sₙ) with entries in ℤq (integers mod q).</p><p><strong>Without errors</strong>: Bob gives Alice many vectors <strong>aᵢ</strong> and receives:
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi mathvariant="bold">a</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="bold">s</mi><mo stretchy="false">⟩</mo><mspace></mspace><mspace width="0.4444em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"></mspace><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle \\pmod{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathbf">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">s</span><span class="mclose">⟩</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p><p>This is just a system of linear equations. Using Gaussian elimination, Bob can recover <strong>s</strong> in polynomial time.</p><p><strong>With errors</strong>: Alice adds small random errors eᵢ:
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi mathvariant="bold">a</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="bold">s</mi><mo stretchy="false">⟩</mo><mo>+</mo><msub><mi>e</mi><mi>i</mi></msub><mspace></mspace><mspace width="0.4444em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"></mspace><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle + e_i \\pmod{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathbf">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf">s</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p><p>where each |eᵢ| is small (say, |eᵢ| &#x3C; q/10).</p><p><strong>Why this is hard</strong>: The small errors prevent direct application of linear algebra. The problem becomes:</p><ul>
<li>Given many "approximate" linear equations</li>
<li>Separate the signal (secret <strong>s</strong>) from the noise (errors <strong>e</strong>)</li>
<li>Known attacks require exponential time</li>
</ul><p><strong>Intuition</strong>: Each equation gives a "fuzzy hyperplane" in n-dimensional space. The secret <strong>s</strong> lies near all these hyperplanes, but the noise makes it impossible to locate precisely without exponential search.</p><p><strong>Reductions</strong>: LWE is provably as hard as solving worst-case lattice problems (Regev, 2005). If you can solve LWE efficiently, you can solve SVP for any lattice — giving quantum resistance.</p><h3 class="markdown-h2">Part C: NIST Post-Quantum Standards</h3><p>After 8 years of competition, NIST selected (2022-2024):</p><p><strong>For Encryption/Key Exchange</strong>:</p><ul>
<li><strong>CRYSTALS-Kyber</strong> (now standardised as ML-KEM)
<ul>
<li>Based on: Module Learning With Errors (Module-LWE)</li>
<li>Public key: ~1 KB</li>
<li>Ciphertext: ~1 KB</li>
<li>Security levels: 128, 192, 256-bit equivalent</li>
<li>Performance: Very fast, suitable for TLS</li>
</ul>
</li>
</ul><p><strong>For Digital Signatures</strong>:</p><ul>
<li>
<p><strong>CRYSTALS-Dilithium</strong> (now ML-DSA)</p>
<ul>
<li>Based on: Module-LWE</li>
<li>Public key: ~1-2 KB</li>
<li>Signature: ~2-4 KB</li>
<li>Fast signing and verification</li>
</ul>
</li>
<li>
<p><strong>Falcon</strong></p>
<ul>
<li>Based on: NTRU lattices</li>
<li>Public key: ~1 KB</li>
<li>Signature: ~700 bytes (smallest signatures)</li>
<li>Slower signing (requires floating-point)</li>
</ul>
</li>
<li>
<p><strong>SPHINCS+</strong> (now SLH-DSA)</p>
<ul>
<li>Based on: Hash functions (stateless hash-based signatures)</li>
<li>Public key: ~32-64 bytes (tiny!)</li>
<li>Signature: ~8-50 KB (very large)</li>
<li>Slowest but conservative (only assumes hash functions are secure)</li>
</ul>
</li>
</ul><p><strong>Trade-offs</strong>:</p><table>
<thead>
<tr>
<th>Property</th>
<th>Kyber</th>
<th>Dilithium</th>
<th>Falcon</th>
<th>SPHINCS+</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Hardness assumption</strong></td>
<td>Module-LWE</td>
<td>Module-LWE</td>
<td>NTRU</td>
<td>Hash functions</td>
</tr>
<tr>
<td><strong>Key size</strong></td>
<td>Medium</td>
<td>Medium</td>
<td>Medium</td>
<td>Tiny</td>
</tr>
<tr>
<td><strong>Signature/CT size</strong></td>
<td>Medium</td>
<td>Large</td>
<td>Small</td>
<td>Huge</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Fast</td>
<td>Fast</td>
<td>Medium</td>
<td>Slow</td>
</tr>
<tr>
<td><strong>Simplicity</strong></td>
<td>Moderate</td>
<td>Moderate</td>
<td>Complex</td>
<td>Simple</td>
</tr>
<tr>
<td><strong>Quantum security</strong></td>
<td>Strong</td>
<td>Strong</td>
<td>Strong</td>
<td>Strongest</td>
</tr>
</tbody>
</table><p><strong>NIST's strategy</strong>: Diversify! Different algorithms based on different hard problems, allowing migration if one assumption breaks.</p><h3 class="markdown-h2">Part D: Harvest Now, Decrypt Later</h3><p><strong>Threat model</strong>: An adversary with resources (e.g., nation-state) can:</p><ol>
<li><strong>Today</strong>: Record all encrypted internet traffic</li>
<li><strong>Store it</strong>: Data remains encrypted and unreadable</li>
<li><strong>Wait</strong>: 10-20 years for large quantum computers</li>
<li><strong>Decrypt</strong>: Use Shor's algorithm to break RSA/ECC and read historical data</li>
</ol><p><strong>Vulnerable data</strong>:</p><ul>
<li>Government communications</li>
<li>Medical records</li>
<li>Financial data</li>
<li>Trade secrets</li>
<li>Personal communications</li>
</ul><p><strong>Timeline pressure</strong>: Even though large quantum computers don't exist yet, sensitive data encrypted with RSA today is at risk. Once quantum computers arrive, all that stored data becomes readable.</p><p><strong>Migration imperative</strong>: Organisations must migrate to post-quantum cryptography <strong>now</strong>, before quantum computers exist, to protect data being encrypted today.</p><p><strong>Current status (2025)</strong>:</p><ul>
<li>Major internet companies deploying post-quantum TLS</li>
<li>Governments mandating post-quantum migration timelines</li>
<li>Cryptographic libraries implementing NIST standards</li>
<li>Hardware accelerators for lattice cryptography in development</li>
</ul><p>The race is on: will we migrate to quantum-resistant cryptography before quantum computers capable of breaking current encryption are built?</p></div></details>`,rawContent:`
# The Quantum Threat

Shor's algorithm (1994) proved that a sufficiently powerful quantum computer can:
- Factor large numbers in polynomial time (breaking RSA)
- Solve discrete logarithm problems (breaking Diffie-Hellman, elliptic curve cryptography)

This threatens virtually all current public-key cryptography. When large-scale quantum computers exist, encrypted data — including data encrypted today — will be vulnerable.

# Post-Quantum Cryptography

Cryptographers are developing encryption methods based on problems believed to be hard even for quantum computers:

1. **Lattice-based cryptography** — Problems about high-dimensional lattices
2. **Code-based cryptography** — Decoding random linear codes
3. **Hash-based signatures** — Using cryptographic hash functions
4. **Multivariate polynomial cryptography** — Solving systems of polynomials
5. **Isogeny-based cryptography** — Computing isogenies between elliptic curves

# The Challenge

Explore the hardness foundations of post-quantum cryptography:

**Part A**: The **Shortest Vector Problem (SVP)** asks: given a lattice (a discrete grid of points in n-dimensional space), find the shortest non-zero vector. Why is this problem believed to be hard for both classical and quantum computers?

**Part B**: The **Learning With Errors (LWE)** problem is the foundation of many lattice-based schemes. Given many linear equations with small random errors added, recover the secret. Explain why adding small errors transforms an easy problem (solving linear equations) into a presumably hard one.

**Part C**: **NIST Post-Quantum Cryptography Standardization** (2016-2024) selected algorithms for standardisation. Research what NIST chose and explain the trade-offs between security level, key size, and performance.

**Part D**: What is "harvest now, decrypt later"? Why does this threat require migrating to post-quantum cryptography before large quantum computers exist?

:::hint
For Part A, consider that SVP is believed to be NP-hard. Quantum computers provide speedup for some problems but not all NP-hard problems.
:::

:::hint
Grover's algorithm gives quantum computers a quadratic speedup for unstructured search, but this only requires doubling key sizes for symmetric encryption.
:::

:::hint
For Part B, think about how noise in measurements affects what information can be extracted. Small errors compound in surprising ways.
:::

:::hint
For Part C, NIST selected CRYSTALS-Kyber for encryption and CRYSTALS-Dilithium, Falcon, and SPHINCS+ for signatures. Research their properties.
:::

:::solution
**Answer**: A) SVP is NP-hard under certain reductions; quantum algorithms don't solve all NP-hard problems efficiently. B) Errors prevent using Gaussian elimination; recovering the secret requires solving an exponentially hard problem. C) See detailed comparison below. D) Adversaries can record encrypted data now and decrypt it later once quantum computers exist.

## Part A: Shortest Vector Problem

The **Shortest Vector Problem (SVP)**: Given a basis for an n-dimensional lattice, find the shortest non-zero vector in the lattice.

**Example (2D)**:
Consider a lattice generated by basis vectors v₁ = (1, 0) and v₂ = (1, 2). The lattice consists of all points a·v₁ + b·v₂ where a, b are integers. The shortest non-zero vector is (1, 0) with length 1.

For poorly chosen bases in high dimensions, finding the shortest vector becomes extraordinarily difficult.

**Why It's Hard**:

1. **Worst-case hardness**: SVP is NP-hard under randomised reductions (Ajtai, 1996)
2. **No quantum shortcut**: Known quantum algorithms (including Grover's) provide at most a modest speedup, not the exponential speedup that breaks RSA
3. **Best known algorithms**: The fastest algorithms (like sieving methods) require time $2^{O(n)}$ for dimension n, even on quantum computers
4. **High dimensions**: Post-quantum schemes use dimensions n ≈ 500-1000, making attacks infeasible

**Quantum resistance**: While quantum computers excel at problems with hidden structure (like factoring), lattice problems appear to lack exploitable structure. After decades of research, no efficient quantum algorithm for SVP exists.

## Part B: Learning With Errors (LWE)

**Setup**: Alice has a secret vector **s** = (s₁, s₂, ..., sₙ) with entries in ℤq (integers mod q).

**Without errors**: Bob gives Alice many vectors **aᵢ** and receives:
$$b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle \\pmod{q}$$

This is just a system of linear equations. Using Gaussian elimination, Bob can recover **s** in polynomial time.

**With errors**: Alice adds small random errors eᵢ:
$$b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle + e_i \\pmod{q}$$

where each |eᵢ| is small (say, |eᵢ| < q/10).

**Why this is hard**: The small errors prevent direct application of linear algebra. The problem becomes:
- Given many "approximate" linear equations
- Separate the signal (secret **s**) from the noise (errors **e**)
- Known attacks require exponential time

**Intuition**: Each equation gives a "fuzzy hyperplane" in n-dimensional space. The secret **s** lies near all these hyperplanes, but the noise makes it impossible to locate precisely without exponential search.

**Reductions**: LWE is provably as hard as solving worst-case lattice problems (Regev, 2005). If you can solve LWE efficiently, you can solve SVP for any lattice — giving quantum resistance.

## Part C: NIST Post-Quantum Standards

After 8 years of competition, NIST selected (2022-2024):

**For Encryption/Key Exchange**:
- **CRYSTALS-Kyber** (now standardised as ML-KEM)
  - Based on: Module Learning With Errors (Module-LWE)
  - Public key: ~1 KB
  - Ciphertext: ~1 KB
  - Security levels: 128, 192, 256-bit equivalent
  - Performance: Very fast, suitable for TLS

**For Digital Signatures**:
- **CRYSTALS-Dilithium** (now ML-DSA)
  - Based on: Module-LWE
  - Public key: ~1-2 KB
  - Signature: ~2-4 KB
  - Fast signing and verification

- **Falcon**
  - Based on: NTRU lattices
  - Public key: ~1 KB
  - Signature: ~700 bytes (smallest signatures)
  - Slower signing (requires floating-point)

- **SPHINCS+** (now SLH-DSA)
  - Based on: Hash functions (stateless hash-based signatures)
  - Public key: ~32-64 bytes (tiny!)
  - Signature: ~8-50 KB (very large)
  - Slowest but conservative (only assumes hash functions are secure)

**Trade-offs**:

| Property | Kyber | Dilithium | Falcon | SPHINCS+ |
|----------|-------|-----------|--------|----------|
| **Hardness assumption** | Module-LWE | Module-LWE | NTRU | Hash functions |
| **Key size** | Medium | Medium | Medium | Tiny |
| **Signature/CT size** | Medium | Large | Small | Huge |
| **Speed** | Fast | Fast | Medium | Slow |
| **Simplicity** | Moderate | Moderate | Complex | Simple |
| **Quantum security** | Strong | Strong | Strong | Strongest |

**NIST's strategy**: Diversify! Different algorithms based on different hard problems, allowing migration if one assumption breaks.

## Part D: Harvest Now, Decrypt Later

**Threat model**: An adversary with resources (e.g., nation-state) can:
1. **Today**: Record all encrypted internet traffic
2. **Store it**: Data remains encrypted and unreadable
3. **Wait**: 10-20 years for large quantum computers
4. **Decrypt**: Use Shor's algorithm to break RSA/ECC and read historical data

**Vulnerable data**:
- Government communications
- Medical records
- Financial data
- Trade secrets
- Personal communications

**Timeline pressure**: Even though large quantum computers don't exist yet, sensitive data encrypted with RSA today is at risk. Once quantum computers arrive, all that stored data becomes readable.

**Migration imperative**: Organisations must migrate to post-quantum cryptography **now**, before quantum computers exist, to protect data being encrypted today.

**Current status (2025)**:
- Major internet companies deploying post-quantum TLS
- Governments mandating post-quantum migration timelines
- Cryptographic libraries implementing NIST standards
- Hardware accelerators for lattice cryptography in development

The race is on: will we migrate to quantum-resistant cryptography before quantum computers capable of breaking current encryption are built?
:::
`,dynamicBlocks:[]};export{s as default};
