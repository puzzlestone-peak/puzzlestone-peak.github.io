const n={slug:"vanishing-square",metadata:{id:"puzzle-72",title:"Vanishing Square",concepts:["geometry"],difficulty:{concepts:"easy",reasoning:"easy"},tags:["has-solution"],nextPuzzle:"infinite-chocolate-bar",dateCreated:"2026-02-05",lastUpdated:"2026-02-05",credit:`Classic puzzle. Question and solution written by Puzzlestone Peak.
`,preview:"The diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap,...",websitePreview:"The diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap,..."},content:`<p>The diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap, while the second does not. Where did the additional area go?</p>
<p>Here’s the first arrangement:</p>
<div class="dynamic-block-placeholder" data-dynamic-block-id="0" data-mode="component"><p class="text-muted-foreground text-sm">[Interactive content: component mode]</p></div>
<p>And here’s the rearranged version without the gap:</p>
<div class="dynamic-block-placeholder" data-dynamic-block-id="1" data-mode="component"><p class="text-muted-foreground text-sm">[Interactive content: component mode]</p></div>
<details class="content-block solution-block" data-type="solution"><summary class="solution-label">Solution</summary><div class="solution-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>Neither arrangement actually forms a true triangle. The “hypotenuse” isn’t a straight line in either case—it’s slightly bent, but the bend is so subtle that it’s hard to notice without close inspection.</p><p>The key is in the slopes of the two triangular pieces:</p><div class="dynamic-block-placeholder" data-dynamic-block-id="2" data-mode="component"><p class="text-muted-foreground text-sm">[Interactive content: component mode]</p></div><p>Big triangle: 3 units tall by 8 units wide, giving a slope of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>3</mn><mn>8</mn></mfrac><mo>=</mo><mn>0.375</mn></mrow><annotation>\\frac{3}{8} = 0.375</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.375</span></span></span></span>.
Small triangle: 2 units tall by 5 units wide, giving a slope of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac><mo>=</mo><mn>0.400</mn></mrow><annotation>\\frac{2}{5} = 0.400</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.400</span></span></span></span>.</p><p>Since <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>3</mn><mn>8</mn></mfrac><mo>≠</mo><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow><annotation>\\frac{3}{8} \\ne \\frac{2}{5}</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, the two triangular pieces don’t have the same slope. When placed together, they create a very slight bend in what appears to be the hypotenuse.</p><div class="dynamic-block-placeholder" data-dynamic-block-id="3" data-mode="component"><p class="text-muted-foreground text-sm">[Interactive content: component mode]</p></div><p>In the first arrangement, the “hypotenuse” bends very slightly inward, while in the second arrangement, it bends very slightly outward. This gap accounts for the 1 unit² of area difference.</p></div></details>
<div class="inline-component-definition" style="display: none;"></div>`,rawContent:`
The diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap, while the second does not. Where did the additional area go?

Here’s the first arrangement:

:::dynamic
\`\`\`yaml
title: "Triangle puzzle - Arrangement A with gap"
use: '#vanishing-square-diagram'
props:
  mode: arrangement-a
\`\`\`
:::

And here’s the rearranged version without the gap:

:::dynamic
\`\`\`yaml
title: "Triangle puzzle - Arrangement B"
use: '#vanishing-square-diagram'
props:
  mode: arrangement-b
\`\`\`
:::

::::solution
Neither arrangement actually forms a true triangle. The “hypotenuse” isn’t a straight line in either case—it’s slightly bent, but the bend is so subtle that it’s hard to notice without close inspection.

The key is in the slopes of the two triangular pieces:

:::dynamic
\`\`\`yaml
title: "Slope comparison diagram"
use: '#vanishing-square-diagram'
props:
  mode: diagram
\`\`\`
:::

Big triangle: 3 units tall by 8 units wide, giving a slope of $\\frac{3}{8} = 0.375$.
Small triangle: 2 units tall by 5 units wide, giving a slope of $\\frac{2}{5} = 0.400$.

Since $\\frac{3}{8} \\ne \\frac{2}{5}$, the two triangular pieces don’t have the same slope. When placed together, they create a very slight bend in what appears to be the hypotenuse.

:::dynamic
\`\`\`yaml
title: "Overlay showing the true hypotenuse difference"
use: '#vanishing-square-diagram'
props:
  mode: solution
\`\`\`
:::

In the first arrangement, the “hypotenuse” bends very slightly inward, while in the second arrangement, it bends very slightly outward. This gap accounts for the 1 unit² of area difference.
::::


:::component[vanishing-square-diagram]
\`\`\`js
function draw(options) {
  const { canvas, api, width, props } = options;
  const ctx = canvas.getContext('2d');
  const mode = props.mode;

  // Padding constants per mode (in grid units)
  const PADDING = {
    'arrangement-a': { top: 1, bottom: 1, left: 1, right: 1 },
    'arrangement-b': { top: 1, bottom: 1, left: 1, right: 1 },
    'solution': { top: 1, bottom: 1, left: 1, right: 1 },
    'diagram': { top: 1.5, bottom: 1.5, left: 1, right: 2 }
  };
  const pad = PADDING[mode];

  // Content dimensions (in grid units)
  const contentWidth = mode === 'diagram' ? 15 : 13;
  const contentHeight = mode === 'diagram' ? 3 : 5;
  const totalWidth = pad.left + contentWidth + pad.right;
  const totalHeight = pad.top + contentHeight + pad.bottom;

  // Responsive sizing (solution mode scales larger for visibility)
  const maxGridSize = mode === 'solution' ? 60 : 40;
  const gridSize = Math.min(width / totalWidth, maxGridSize);
  const canvasWidth = totalWidth * gridSize;
  const canvasHeight = totalHeight * gridSize;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Theme colors
  const isDark = api.theme === 'dark';
  const bgColor = api.getColor('background');
  const gridColor = api.getColor(isDark ? 'neutral-200' : 'neutral-600');
  const textColor = api.getColor('foreground');

  // Piece colors - distinct palette hues, theme-adapted
  const colorBigTri = api.getColor(isDark ? 'emerald-500' : 'emerald-600');
  const colorSmallTri = api.getColor(isDark ? 'sky-500' : 'sky-600');
  const colorBlock1 = api.getColor(isDark ? 'violet-500' : 'violet-600');
  const colorBlock2 = api.getColor(isDark ? 'amber-500' : 'amber-500');

  // Clear canvas
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, canvas.width, canvasHeight);

  // Calculate pixel offsets from padding
  const padX = pad.left * gridSize;
  const padY = pad.top * gridSize;

  if (mode === 'arrangement-a') {
    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_A, padX, padY);
  } else if (mode === 'arrangement-b') {
    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_B, padX, padY);
  } else if (mode === 'solution') {
    drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY);
  } else if (mode === 'diagram') {
    drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY);
  }
}

// Piece definitions (relative coordinates)
const PIECES = {
  bigTriangle: [[8, 0], [8, 3], [0, 3]],
  smallTriangle: [[5, 0], [5, 2], [0, 2]],
  block1: [[0, 0], [5, 0], [5, 1], [2, 1], [2, 2], [0, 2]],
  block2: [[0, 1], [2, 1], [2, 0], [5, 0], [5, 2], [0, 2]]
};

// Arrangement positions
const ARRANGEMENT_A = {
  bigTriangle: [5, 0],
  smallTriangle: [0, 3],
  block1: [5, 3],
  block2: [8, 3]
};

const ARRANGEMENT_B = {
  bigTriangle: [0, 2],
  smallTriangle: [8, 0],
  block1: [8, 2],
  block2: [8, 3]
};

function drawPolygon(ctx, offsetX, offsetY, gridSize, points, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(offsetX + points[0][0] * gridSize, offsetY + points[0][1] * gridSize);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(offsetX + points[i][0] * gridSize, offsetY + points[i][1] * gridSize);
  }
  ctx.closePath();
  ctx.fill();
}

function drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, arrangement, padX, padY) {
  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);

  drawPolygon(ctx, padX + arrangement.bigTriangle[0] * gridSize, padY + arrangement.bigTriangle[1] * gridSize, gridSize, PIECES.bigTriangle, colorBigTri);
  drawPolygon(ctx, padX + arrangement.smallTriangle[0] * gridSize, padY + arrangement.smallTriangle[1] * gridSize, gridSize, PIECES.smallTriangle, colorSmallTri);
  drawPolygon(ctx, padX + arrangement.block1[0] * gridSize, padY + arrangement.block1[1] * gridSize, gridSize, PIECES.block1, colorBlock1);
  drawPolygon(ctx, padX + arrangement.block2[0] * gridSize, padY + arrangement.block2[1] * gridSize, gridSize, PIECES.block2, colorBlock2);

  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);
}

function drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY) {
  const isDark = api.theme === 'dark';

  // Draw grid first
  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);

  // Draw two translucent dotted triangles overlaid
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 3;
  ctx.globalAlpha = 0.6;

  // Arrangement A triangle: (0,5) -> (5,3) -> (13,0) (bends inward)
  ctx.strokeStyle = api.getColor(isDark ? 'sky-400' : 'sky-600');
  ctx.beginPath();
  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left
  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right
  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right
  ctx.lineTo(padX + 5 * gridSize, padY + 3 * gridSize);   // bend point
  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)
  ctx.stroke();

  // Arrangement B triangle: (0,5) -> (8,2) -> (13,0) (bulges outward)
  ctx.strokeStyle = api.getColor(isDark ? 'rose-400' : 'rose-600');
  ctx.beginPath();
  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left
  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right
  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right
  ctx.lineTo(padX + 8 * gridSize, padY + 2 * gridSize);   // bend point
  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)
  ctx.stroke();

  // Reset drawing state
  ctx.setLineDash([]);
  ctx.globalAlpha = 1.0;

  // Redraw grid
  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);
}

function drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY) {
  // Draw big triangle with stroke
  ctx.strokeStyle = api.getColor('foreground');
  ctx.lineWidth = 2;
  drawPolygon(ctx, padX, padY, gridSize, PIECES.bigTriangle, colorBigTri);
  ctx.beginPath();
  for (let i = 0; i < PIECES.bigTriangle.length; i++) {
    const [x, y] = PIECES.bigTriangle[i];
    if (i === 0) ctx.moveTo(padX + x * gridSize, padY + y * gridSize);
    else ctx.lineTo(padX + x * gridSize, padY + y * gridSize);
  }
  ctx.closePath();
  ctx.stroke();

  // Draw small triangle with stroke (moved down 0.5 blocks)
  const offsetX2 = padX + 10 * gridSize;
  const offsetY2 = padY + 0.5 * gridSize;
  drawPolygon(ctx, offsetX2, offsetY2, gridSize, PIECES.smallTriangle, colorSmallTri);
  ctx.beginPath();
  for (let i = 0; i < PIECES.smallTriangle.length; i++) {
    const [x, y] = PIECES.smallTriangle[i];
    if (i === 0) ctx.moveTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);
    else ctx.lineTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);
  }
  ctx.closePath();
  ctx.stroke();

  // Labels (dimensions only, no slope calculations)
  ctx.font = \`bold \${Math.max(12, gridSize * 0.35)}px \${api.getFont('default')}\`;
  ctx.fillStyle = textColor;

  // Big triangle labels
  ctx.fillText('8', padX + 4 * gridSize, padY + 3 * gridSize + 18);
  ctx.fillText('3', padX + 8 * gridSize + 8, padY + 1.5 * gridSize);

  // Small triangle labels
  ctx.fillText('5', offsetX2 + 2.5 * gridSize, offsetY2 + 2 * gridSize + 18);
  ctx.fillText('2', offsetX2 + 5 * gridSize + 8, offsetY2 + gridSize);
}

function drawGrid(ctx, offsetX, offsetY, cols, rows, gridSize, gridColor) {
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1;

  for (let i = 0; i <= cols; i++) {
    ctx.beginPath();
    ctx.moveTo(offsetX + i * gridSize, offsetY);
    ctx.lineTo(offsetX + i * gridSize, offsetY + rows * gridSize);
    ctx.stroke();
  }

  for (let i = 0; i <= rows; i++) {
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY + i * gridSize);
    ctx.lineTo(offsetX + cols * gridSize, offsetY + i * gridSize);
    ctx.stroke();
  }
}
\`\`\`
::::
`,dynamicBlocks:[{type:"dynamic",mode:"component",componentId:"#vanishing-square-diagram",props:{mode:"arrangement-a"},title:"Triangle puzzle - Arrangement A with gap",sourceFile:"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/vanishing-square.md"},{type:"dynamic",mode:"component",componentId:"#vanishing-square-diagram",props:{mode:"arrangement-b"},title:"Triangle puzzle - Arrangement B",sourceFile:"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/vanishing-square.md"},{type:"dynamic",mode:"component",componentId:"#vanishing-square-diagram",props:{mode:"diagram"},title:"Slope comparison diagram",sourceFile:"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/vanishing-square.md"},{type:"dynamic",mode:"component",componentId:"#vanishing-square-diagram",props:{mode:"solution"},title:"Overlay showing the true hypotenuse difference",sourceFile:"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/vanishing-square.md"}],inlineComponents:{"vanishing-square-diagram":{id:"vanishing-square-diagram",code:`function draw(options) {
  const { canvas, api, width, props } = options;
  const ctx = canvas.getContext('2d');
  const mode = props.mode;

  // Padding constants per mode (in grid units)
  const PADDING = {
    'arrangement-a': { top: 1, bottom: 1, left: 1, right: 1 },
    'arrangement-b': { top: 1, bottom: 1, left: 1, right: 1 },
    'solution': { top: 1, bottom: 1, left: 1, right: 1 },
    'diagram': { top: 1.5, bottom: 1.5, left: 1, right: 2 }
  };
  const pad = PADDING[mode];

  // Content dimensions (in grid units)
  const contentWidth = mode === 'diagram' ? 15 : 13;
  const contentHeight = mode === 'diagram' ? 3 : 5;
  const totalWidth = pad.left + contentWidth + pad.right;
  const totalHeight = pad.top + contentHeight + pad.bottom;

  // Responsive sizing (solution mode scales larger for visibility)
  const maxGridSize = mode === 'solution' ? 60 : 40;
  const gridSize = Math.min(width / totalWidth, maxGridSize);
  const canvasWidth = totalWidth * gridSize;
  const canvasHeight = totalHeight * gridSize;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Theme colors
  const isDark = api.theme === 'dark';
  const bgColor = api.getColor('background');
  const gridColor = api.getColor(isDark ? 'neutral-200' : 'neutral-600');
  const textColor = api.getColor('foreground');

  // Piece colors - distinct palette hues, theme-adapted
  const colorBigTri = api.getColor(isDark ? 'emerald-500' : 'emerald-600');
  const colorSmallTri = api.getColor(isDark ? 'sky-500' : 'sky-600');
  const colorBlock1 = api.getColor(isDark ? 'violet-500' : 'violet-600');
  const colorBlock2 = api.getColor(isDark ? 'amber-500' : 'amber-500');

  // Clear canvas
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, canvas.width, canvasHeight);

  // Calculate pixel offsets from padding
  const padX = pad.left * gridSize;
  const padY = pad.top * gridSize;

  if (mode === 'arrangement-a') {
    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_A, padX, padY);
  } else if (mode === 'arrangement-b') {
    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_B, padX, padY);
  } else if (mode === 'solution') {
    drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY);
  } else if (mode === 'diagram') {
    drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY);
  }
}

// Piece definitions (relative coordinates)
const PIECES = {
  bigTriangle: [[8, 0], [8, 3], [0, 3]],
  smallTriangle: [[5, 0], [5, 2], [0, 2]],
  block1: [[0, 0], [5, 0], [5, 1], [2, 1], [2, 2], [0, 2]],
  block2: [[0, 1], [2, 1], [2, 0], [5, 0], [5, 2], [0, 2]]
};

// Arrangement positions
const ARRANGEMENT_A = {
  bigTriangle: [5, 0],
  smallTriangle: [0, 3],
  block1: [5, 3],
  block2: [8, 3]
};

const ARRANGEMENT_B = {
  bigTriangle: [0, 2],
  smallTriangle: [8, 0],
  block1: [8, 2],
  block2: [8, 3]
};

function drawPolygon(ctx, offsetX, offsetY, gridSize, points, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(offsetX + points[0][0] * gridSize, offsetY + points[0][1] * gridSize);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(offsetX + points[i][0] * gridSize, offsetY + points[i][1] * gridSize);
  }
  ctx.closePath();
  ctx.fill();
}

function drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, arrangement, padX, padY) {
  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);

  drawPolygon(ctx, padX + arrangement.bigTriangle[0] * gridSize, padY + arrangement.bigTriangle[1] * gridSize, gridSize, PIECES.bigTriangle, colorBigTri);
  drawPolygon(ctx, padX + arrangement.smallTriangle[0] * gridSize, padY + arrangement.smallTriangle[1] * gridSize, gridSize, PIECES.smallTriangle, colorSmallTri);
  drawPolygon(ctx, padX + arrangement.block1[0] * gridSize, padY + arrangement.block1[1] * gridSize, gridSize, PIECES.block1, colorBlock1);
  drawPolygon(ctx, padX + arrangement.block2[0] * gridSize, padY + arrangement.block2[1] * gridSize, gridSize, PIECES.block2, colorBlock2);

  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);
}

function drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY) {
  const isDark = api.theme === 'dark';

  // Draw grid first
  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);

  // Draw two translucent dotted triangles overlaid
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 3;
  ctx.globalAlpha = 0.6;

  // Arrangement A triangle: (0,5) -> (5,3) -> (13,0) (bends inward)
  ctx.strokeStyle = api.getColor(isDark ? 'sky-400' : 'sky-600');
  ctx.beginPath();
  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left
  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right
  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right
  ctx.lineTo(padX + 5 * gridSize, padY + 3 * gridSize);   // bend point
  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)
  ctx.stroke();

  // Arrangement B triangle: (0,5) -> (8,2) -> (13,0) (bulges outward)
  ctx.strokeStyle = api.getColor(isDark ? 'rose-400' : 'rose-600');
  ctx.beginPath();
  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left
  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right
  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right
  ctx.lineTo(padX + 8 * gridSize, padY + 2 * gridSize);   // bend point
  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)
  ctx.stroke();

  // Reset drawing state
  ctx.setLineDash([]);
  ctx.globalAlpha = 1.0;

  // Redraw grid
  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);
}

function drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY) {
  // Draw big triangle with stroke
  ctx.strokeStyle = api.getColor('foreground');
  ctx.lineWidth = 2;
  drawPolygon(ctx, padX, padY, gridSize, PIECES.bigTriangle, colorBigTri);
  ctx.beginPath();
  for (let i = 0; i < PIECES.bigTriangle.length; i++) {
    const [x, y] = PIECES.bigTriangle[i];
    if (i === 0) ctx.moveTo(padX + x * gridSize, padY + y * gridSize);
    else ctx.lineTo(padX + x * gridSize, padY + y * gridSize);
  }
  ctx.closePath();
  ctx.stroke();

  // Draw small triangle with stroke (moved down 0.5 blocks)
  const offsetX2 = padX + 10 * gridSize;
  const offsetY2 = padY + 0.5 * gridSize;
  drawPolygon(ctx, offsetX2, offsetY2, gridSize, PIECES.smallTriangle, colorSmallTri);
  ctx.beginPath();
  for (let i = 0; i < PIECES.smallTriangle.length; i++) {
    const [x, y] = PIECES.smallTriangle[i];
    if (i === 0) ctx.moveTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);
    else ctx.lineTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);
  }
  ctx.closePath();
  ctx.stroke();

  // Labels (dimensions only, no slope calculations)
  ctx.font = \`bold \${Math.max(12, gridSize * 0.35)}px \${api.getFont('default')}\`;
  ctx.fillStyle = textColor;

  // Big triangle labels
  ctx.fillText('8', padX + 4 * gridSize, padY + 3 * gridSize + 18);
  ctx.fillText('3', padX + 8 * gridSize + 8, padY + 1.5 * gridSize);

  // Small triangle labels
  ctx.fillText('5', offsetX2 + 2.5 * gridSize, offsetY2 + 2 * gridSize + 18);
  ctx.fillText('2', offsetX2 + 5 * gridSize + 8, offsetY2 + gridSize);
}

function drawGrid(ctx, offsetX, offsetY, cols, rows, gridSize, gridColor) {
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1;

  for (let i = 0; i <= cols; i++) {
    ctx.beginPath();
    ctx.moveTo(offsetX + i * gridSize, offsetY);
    ctx.lineTo(offsetX + i * gridSize, offsetY + rows * gridSize);
    ctx.stroke();
  }

  for (let i = 0; i <= rows; i++) {
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY + i * gridSize);
    ctx.lineTo(offsetX + cols * gridSize, offsetY + i * gridSize);
    ctx.stroke();
  }
}`,startLine:76}}};export{n as default};
