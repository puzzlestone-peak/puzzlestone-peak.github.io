[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","egg-dropping","puzzle",{"_7":8,"_11":12,"_37":38,"_39":40,"_41":42,"_247":248},"metadata",{"_13":14,"_15":16,"_17":18,"_19":20,"_22":23,"_26":27,"_29":30,"_31":30,"_32":33,"_34":35,"_36":35},"id","puzzle-39","title","Egg Dropping","questionPreview","You’ve devised an egg-protection device for a school project. With two prototypes and a 100-storey building, what’s the fewest drops to find the break floor?\n","concepts",[21],"optimisation","difficulty",{"_19":24,"_25":24},"medium","reasoning","tags",[28],"has-solution","dateCreated","2026-02-02","lastUpdated","credit","Classic puzzle.\nQuestion and solution by Puzzlestone Peak.\n","preview","For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when...","websitePreview","content","<p>For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.</p>\n<p>Near your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.</p>\n<p>What is the minimum number of drops you’d ever need in the <strong>worst case</strong> to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.</p>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint 1</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Experiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.</p></div></details>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint 2</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>If you only had 1 device, you cannot do better than 100 drops in the worst case. Why?</p><details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Let’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.</p><p>This means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.</p></div></details><p>Now consider what happens when you have 2 devices.</p></div></details>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint 3</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>If your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?</p><details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>You would have to do 50 drops in the worst case scenario.</p><p><strong>Case 1</strong>: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.</p><p><strong>Case 2</strong>: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.</p></div></details></div></details>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><strong>Answer</strong>: 14 drops.</p><p>Let’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?</p><p>First, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:</p><ul>\n<li>First drop: Drop from floor 3.\n<ul>\n<li>If it breaks, test floor 1, then 2. Worst case: 3 moves.</li>\n<li>If it doesn’t break, drop from floor 6.\n<ul>\n<li>If it breaks, test floor 4, then 5. Worst case: 4 moves.</li>\n<li>If it doesn’t break, then we know the device survives all 6 floors.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul><p>This gives us a worst case of 4 moves.</p><p>Let’s come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>When the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we’re left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>We can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let’s try a different strategy:</p><ul>\n<li>First drop: Drop from floor 2.\n<ul>\n<li>If it breaks, test floor 1. Worst case: 2 moves.</li>\n<li>If it doesn’t break, drop from floor 4.\n<ul>\n<li>If it breaks, test floor 3. Worst case: 3 moves.</li>\n<li>If it doesn’t break, test floor 6.\n<ul>\n<li>If it breaks, test floor 5. Worst case: 4 moves</li>\n<li>If it doesn’t break, then we know the device survives all 6 floors.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Hmm, we’re still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we’ve found the optimal number of drops?</p><p>No! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2) and (Start → 3 → 6 without breaking). In version 2, we have (Start → 2 → 1), (Start → 2 → 4 → 3), and (Start → 2 → 4 → 6 without breaking). If we could make these longer in order to shorten the worst-case path, we’ll find a better solution. And in fact, we can!</p><ul>\n<li>First drop: Drop from floor 3.\n<ul>\n<li>If it breaks, test floor 1, then 2. Worst case: 3 moves.</li>\n<li>If it doesn’t break, drop from floor 5.\n<ul>\n<li>If it breaks, test floor 4. Worst case: 3 moves.</li>\n<li>If it doesn’t break, test floor 6. Worst case: 3 moves.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"3\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>No matter which path we take, we’ll always end up with 3 moves in the worst case.</p><p>With this visualisation in mind, let’s explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"4\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Oof, that’s rough. It seems like we’re not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.</p><p>How about steps of 10? This time, we’ll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"5\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>In the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let’s lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>14</mn><mo>+</mo><mn>13</mn><mo>=</mo><mn>27</mn></mrow><annotation>14 + 13 = 27</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">14</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">13</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">27</span></span></span></span>. Then the following drop should be <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>27</mn><mo>+</mo><mn>12</mn><mo>=</mo><mn>39</mn></mrow><annotation>27 + 12 = 39</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">27</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">12</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">39</span></span></span></span>. Continuing this way, we get a chart of:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"6\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>In the worst case scenario, we have 14 moves, and we can’t do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"7\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><div class=\"content-block note-block note-note\" data-type=\"note\" data-note-type=\"note\"><div class=\"note-header note-note-header\">An Extension</div><div class=\"note-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Now that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:</p><ol>\n<li>For 2 devices, what is the minimum worst-case number of drops for a building of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation>n</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> storeys?</li>\n<li>For 2 devices, what is the maximum building height coverable with at most <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation>k</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> drops in the worst case?</li>\n<li>For <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi></mrow><annotation>d</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> devices and an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation>n</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-storey building, what is the minimum worst-case number of drops?</li>\n</ol></div></div></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nFor a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.\n\nNear your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.\n\nWhat is the minimum number of drops you’d ever need in the **worst case** to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.\n\n\n:::hint[Hint 1]\nExperiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.\n:::\n\n::::hint[Hint 2]\nIf you only had 1 device, you cannot do better than 100 drops in the worst case. Why?\n\n:::solution\nLet’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.\n\nThis means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.\n:::\n\nNow consider what happens when you have 2 devices.\n::::\n\n::::hint[Hint 3]\nIf your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?\n\n:::solution\nYou would have to do 50 drops in the worst case scenario.\n\n**Case 1**: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.\n\n**Case 2**: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.\n:::\n::::\n\n::::solution\n**Answer**: 14 drops.\n\nLet’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?\n\nFirst, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:\n\n- First drop: Drop from floor 3.\n    - If it breaks, test floor 1, then 2. Worst case: 3 moves.\n    - If it doesn’t break, drop from floor 6.\n        - If it breaks, test floor 4, then 5. Worst case: 4 moves.\n        - If it doesn’t break, then we know the device survives all 6 floors.\n\nThis gives us a worst case of 4 moves.\n\nLet’s come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Simple strategy: drop from floor 3, then floor 6\"\nariaLabel: Three nodes in a horizontal chain — start, floor 3, floor 6\nprops:\n  columns:\n    - \"S\"\n    - \"3\"\n    - \"6\"\n```\n:::\n\nWhen the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we’re left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Strategy tree: floors 3 and 6 with fallback chains\"\nariaLabel: Strategy tree with start node, floor 3 with chain 1 and 2 below, floor 6 with chain 4 and 5 below\nprops:\n  columns:\n    - \"S\"\n    - label: \"3\"\n      chain: [1, 2]\n    - label: \"6\"\n      chain: [4, 5]\n  showDepth: true\n  minWidth: 280\n```\n:::\n\nWe can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let’s try a different strategy:\n\n- First drop: Drop from floor 2.\n    - If it breaks, test floor 1. Worst case: 2 moves.\n    - If it doesn’t break, drop from floor 4.\n        - If it breaks, test floor 3. Worst case: 3 moves.\n        - If it doesn’t break, test floor 6.\n            - If it breaks, test floor 5. Worst case: 4 moves\n            - If it doesn’t break, then we know the device survives all 6 floors.\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Strategy tree: floors 2, 4, and 6 with single fallbacks\"\nariaLabel: Strategy tree with start, floor 2 dropping to 1, floor 4 dropping to 3, floor 6 dropping to 5\nprops:\n  columns:\n    - \"S\"\n    - label: \"2\"\n      chain: [1]\n    - label: \"4\"\n      chain: [3]\n    - label: \"6\"\n      chain: [5]\n  showDepth: true\n  minWidth: 320\n```\n:::\n\nHmm, we’re still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we’ve found the optimal number of drops?\n\nNo! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2) and (Start → 3 → 6 without breaking). In version 2, we have (Start → 2 → 1), (Start → 2 → 4 → 3), and (Start → 2 → 4 → 6 without breaking). If we could make these longer in order to shorten the worst-case path, we’ll find a better solution. And in fact, we can!\n\n- First drop: Drop from floor 3.\n    - If it breaks, test floor 1, then 2. Worst case: 3 moves.\n    - If it doesn’t break, drop from floor 5.\n        - If it breaks, test floor 4. Worst case: 3 moves.\n        - If it doesn’t break, test floor 6. Worst case: 3 moves.\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Optimal strategy tree for 6 floors\"\nariaLabel: Strategy tree with start, floor 3 dropping to 2 then 1, floor 5 dropping to 4, floor 6 with no chain\nprops:\n  columns:\n    - \"S\"\n    - label: \"3\"\n      chain: [1, 2]\n    - label: \"5\"\n      chain: [4]\n    - \"6\"\n  showDepth: true\n```\n:::\n\nNo matter which path we take, we’ll always end up with 3 moves in the worst case.\n\nWith this visualisation in mind, let’s explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:\n\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Strategy tree: binary split from floor 50\"\nariaLabel: Strategy tree showing drops from floors 50, 75, and 100 with long fallback chains\nprops:\n  columns:\n    - \"S\"\n    - label: \"50\"\n      chain: [1, 2, \"...\", \"...\", \"...\", \"...\", 49]\n    - label: \"75\"\n      chain: [51, 52, \"...\", 74]\n    - label: \"100\"\n      chain: [76, 77, \"...\", 98, 99]\n  showDepth: true\n  minWidth: 320\n```\n:::\n\nOof, that’s rough. It seems like we’re not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.\n\nHow about steps of 10? This time, we’ll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Strategy tree: steps of 10\"\nariaLabel: Strategy tree showing drops from floors 10, 20, 30 with full fallback chains of 9 floors each\nprops:\n  columns:\n    - \"S\"\n    - label: \"10\"\n      chain: { from: 1, to: 9 }\n    - label: \"20\"\n      chain: { from: 11, to: 19 }\n    - label: \"30\"\n      chain: { from: 21, to: 29 }\n    - \"...\"\n    - label: \"80\"\n      chain: { from: 71, to: 79 }\n      depth: 17\n    - label: \"90\"\n      chain: { from: 81, to: 89 }\n      depth: 18\n    - label: \"100\"\n      chain: { from: 91, to: 99 }\n      depth: 19\n  showDepth: true\n  minWidth: 800\n```\n:::\n\nIn the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let’s lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be $14 + 13 = 27$. Then the following drop should be $27 + 12 = 39$. Continuing this way, we get a chart of:\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Optimal strategy tree for 100 floors\"\nariaLabel: Strategy tree with decreasing jumps starting at floor 14, covering all 100 floors in at most 14 drops\nprops:\n  columns:\n    - \"S\"\n    - label: \"14\"\n      chain: { from: 1, to: 13 }\n    - label: \"27\"\n      chain: { from: 15, to: 26 }\n    - label: \"39\"\n      chain: { from: 28, to: 38 }\n    - label: \"50\"\n      chain: { from: 40, to: 49 }\n    - label: \"60\"\n      chain: { from: 51, to: 59 }\n    - label: \"69\"\n      chain: { from: 61, to: 68 }\n    - label: \"77\"\n      chain: { from: 70, to: 76 }\n    - label: \"84\"\n      chain: { from: 78, to: 83 }\n    - label: \"90\"\n      chain: { from: 85, to: 89 }\n    - label: \"95\"\n      chain: { from: 91, to: 94 }\n    - label: \"99\"\n      chain: { from: 96, to: 98 }\n    - \"100\"\n  showDepth: true\n  minWidth: 1100\n```\n:::\n\nIn the worst case scenario, we have 14 moves, and we can’t do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.\n\n:::dynamic\n```yaml\nuse: '#strategy-tree'\ntitle: \"Maximum building height with 14 drops: 105 floors\"\nariaLabel: Strategy tree for 14 drops covering up to 105 floors, with every path exactly 14 steps\nprops:\n  columns:\n    - \"S\"\n    - label: \"14\"\n      chain: { from: 1, to: 13 }\n    - label: \"27\"\n      chain: { from: 15, to: 26 }\n    - label: \"39\"\n      chain: { from: 28, to: 38 }\n    - label: \"50\"\n      chain: { from: 40, to: 49 }\n    - label: \"60\"\n      chain: { from: 51, to: 59 }\n    - label: \"69\"\n      chain: { from: 61, to: 68 }\n    - label: \"77\"\n      chain: { from: 70, to: 76 }\n    - label: \"84\"\n      chain: { from: 78, to: 83 }\n    - label: \"90\"\n      chain: { from: 85, to: 89 }\n    - label: \"95\"\n      chain: { from: 91, to: 94 }\n    - label: \"99\"\n      chain: { from: 96, to: 98 }\n    - label: \"102\"\n      chain: [100, 101]\n    - label: \"104\"\n      chain: [103]\n    - \"105\"\n  showDepth: true\n  minWidth: 800\n```\n:::\n\n:::note[An Extension]\nNow that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:\n\n1. For 2 devices, what is the minimum worst-case number of drops for a building of $n$ storeys?\n2. For 2 devices, what is the maximum building height coverable with at most $k$ drops in the worst case?\n3. For $d$ devices and an $n$-storey building, what is the minimum worst-case number of drops?\n:::\n\n::::\n\n\n:::component[strategy-tree]\n```yaml\nmode: canvas\ntitle: Strategy tree diagram\nariaLabel: Horizontal chain of decision nodes with vertical fallback chains descending below\n```\n\n```js\n// Normalize columns: expand ranges, compute full chain length\nfunction normalizeColumns(rawColumns) {\n  return rawColumns.map(col => {\n    // Handle shorthand: plain string → { label: \"X\" }\n    if (typeof col === 'string') {\n      return { label: col, chain: [], fullChainLength: 0, depth: null };\n    }\n\n    const { label, chain, depth } = col;\n    let chainLabels = [];\n    let fullLength = 0;\n\n    if (!chain) {\n      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };\n    }\n\n    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]\n    if (typeof chain === 'object' && !Array.isArray(chain)) {\n      const { from, to } = chain;\n      fullLength = to - from + 1;\n      for (let i = from; i <= to; i++) {\n        chainLabels.push(String(i));\n      }\n    } else {\n      chainLabels = chain.map(String);\n      // Derive full length from first and last numeric items\n      const nums = chainLabels.filter(l => l !== '...').map(Number);\n      if (nums.length >= 2) {\n        fullLength = nums[nums.length - 1] - nums[0] + 1;\n      } else {\n        fullLength = nums.length;\n      }\n    }\n\n    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };\n  });\n}\n\n// Compute layout parameters based on columns and container width\nfunction computeLayout(columns, containerWidth, options) {\n  const { showDepth, minWidth } = options;\n  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;\n  const numCols = columns.length;\n\n  // Column spacing (+1 for right-side padding so last node isn't clipped)\n  const totalSpacing = numCols + 1;\n  const spacing = Math.min(effectiveWidth / totalSpacing, 100);\n  const radius = Math.min(spacing * 0.35, 20);\n\n  // Vertical spacing\n  const verticalSpacing = radius * 3;\n\n  // Calculate height needed\n  let maxVisibleChainLength = 0;\n  for (const col of columns) {\n    if (col.chain.length > maxVisibleChainLength) {\n      maxVisibleChainLength = col.chain.length;\n    }\n  }\n\n  const topRowY = radius * 2.5;\n  const chainStartY = topRowY + verticalSpacing;\n  let canvasHeight;\n\n  if (maxVisibleChainLength > 0) {\n    // Bottom of the deepest chain node circle\n    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;\n  } else {\n    // No chains: bottom of top row circles\n    canvasHeight = topRowY + radius;\n  }\n\n  if (showDepth) {\n    // Depth labels: radius gap below circle + up to 2 lines of text\n    canvasHeight += radius * 3;\n  }\n\n  canvasHeight += radius; // Bottom padding\n\n  // Calculate canvas width with extra space for \"(if no breaks)\" label\n  let canvasWidth = totalSpacing * spacing;\n\n  // Check if we need to add space for the \"(if no breaks)\" label\n  if (showDepth) {\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =>\n      col.label !== '...' ? i : idx, 0);\n    const lastCol = columns[lastNonEllipsisIndex];\n    const maxFloor = Math.max(\n      ...columns.filter(c => c.label !== '...' && !isNaN(c.label)).map(c => Number(c.label)),\n      ...columns.flatMap(c => c.chain.filter(l => l !== '...' && !isNaN(l)).map(Number))\n    );\n\n    const shouldShowLabel = lastCol.label !== '...'\n      && lastCol.chain.length > 0\n      && Number(lastCol.label) === maxFloor;\n\n    if (shouldShowLabel) {\n      // Count horizontal moves to calculate label width\n      let lastEllipsisIndex = -1;\n      for (let i = columns.length - 1; i >= 0; i--) {\n        if (columns[i] === '...' || columns[i].label === '...') {\n          lastEllipsisIndex = i;\n          break;\n        }\n      }\n\n      let horizontalMoves = 0;\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i <= lastNonEllipsisIndex; i++) {\n        if (columns[i] !== '...' && columns[i].label !== '...') {\n          horizontalMoves++;\n        }\n      }\n\n      // Calculate actual label width for two-line format: \"X moves\" / \"(if no breaks)\"\n      // We need to estimate based on character count since we don't have canvas context here\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\n      const firstLine = `${horizontalMoves} ${word}`;\n      const secondLine = '(if no breaks)';\n\n      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7\n      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace\n      const firstLineWidth = firstLine.length * avgCharWidth;\n      const secondLineWidth = secondLine.length * avgCharWidth;\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\n\n      // Add label width + spacing + padding\n      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;\n    }\n  }\n\n  return {\n    spacing,\n    radius,\n    verticalSpacing,\n    topRowY,\n    chainStartY,\n    canvasHeight,\n    canvasWidth\n  };\n}\n\n// Draw a circle with centered label\nfunction drawCircleNode(ctx, x, y, radius, label, colors, fonts) {\n  const { fill, stroke, text } = colors;\n  const { fontFamily } = fonts;\n\n  // Circle\n  ctx.beginPath();\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\n  ctx.fillStyle = fill;\n  ctx.fill();\n  ctx.strokeStyle = stroke;\n  ctx.lineWidth = 1.5;\n  ctx.stroke();\n\n  // Label\n  ctx.fillStyle = text;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n\n  // Font size based on label length\n  let fontSize;\n  if (label.length <= 2) {\n    fontSize = radius * 0.9;\n  } else if (label.length === 3) {\n    fontSize = radius * 0.75;\n  } else {\n    fontSize = radius * 0.6;\n  }\n\n  ctx.font = `bold ${fontSize}px ${fontFamily}`;\n  ctx.fillText(label, x, y);\n}\n\n// Draw an arrowhead at the given tip position and angle\nfunction drawArrowhead(ctx, tipX, tipY, angle, radius) {\n  const size = Math.max(3, radius * 0.3);\n  ctx.save();\n  ctx.translate(tipX, tipY);\n  ctx.rotate(angle);\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(-size, -size * 0.6);\n  ctx.lineTo(-size, size * 0.6);\n  ctx.closePath();\n  ctx.fill();\n  ctx.restore();\n}\n\n// Draw a connection line between two nodes with optional arrowhead\nfunction drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {\n  const { stroke } = colors;\n  ctx.strokeStyle = stroke;\n  ctx.lineWidth = 1.5;\n  ctx.lineCap = 'round';\n\n  // Calculate start and end points at circle boundary\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dist = Math.sqrt(dx * dx + dy * dy);\n  const angle = Math.atan2(dy, dx);\n\n  const startX = x1 + (dx / dist) * radius;\n  const startY = y1 + (dy / dist) * radius;\n  const endX = x2 - (dx / dist) * radius;\n  const endY = y2 - (dy / dist) * radius;\n\n  // Draw line\n  ctx.beginPath();\n  ctx.moveTo(startX, startY);\n  ctx.lineTo(endX, endY);\n  ctx.stroke();\n\n  // Draw arrowhead\n  if (showArrows) {\n    ctx.fillStyle = stroke;\n    drawArrowhead(ctx, endX, endY, angle, radius);\n  }\n}\n\n// Draw three vertical ellipsis dots\nfunction drawVerticalEllipsis(ctx, x, y, color, radius) {\n  ctx.fillStyle = color;\n  const dotRadius = Math.max(1.5, radius * 0.125);\n  const gap = Math.max(5, radius * 0.4);\n\n  for (let i = -1; i <= 1; i++) {\n    ctx.beginPath();\n    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\n// Draw three horizontal ellipsis dots\nfunction drawHorizontalEllipsis(ctx, x, y, color, radius) {\n  ctx.fillStyle = color;\n  const dotRadius = Math.max(1.5, radius * 0.125);\n  const gap = Math.max(5, radius * 0.4);\n\n  for (let i = -1; i <= 1; i++) {\n    ctx.beginPath();\n    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\nfunction draw(options) {\n  const { canvas, api, width: containerWidth, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  // Default props\n  const {\n    columns: rawColumns = [],\n    showDepth = false,\n    showArrows = true,\n    minWidth = 0,\n  } = props;\n\n  if (!rawColumns || rawColumns.length === 0) {\n    canvas.width = containerWidth;\n    canvas.height = 100;\n    ctx.fillStyle = api.getColor('muted-foreground');\n    ctx.font = `14px ${api.getFont('default')}`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('No columns provided', containerWidth / 2, 50);\n    api.requestResize(100);\n    return;\n  }\n\n  // Normalize columns\n  const columns = normalizeColumns(rawColumns);\n\n  // Compute layout\n  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });\n  const {\n    spacing,\n    radius,\n    verticalSpacing,\n    topRowY,\n    chainStartY,\n    canvasHeight,\n    canvasWidth\n  } = layout;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Colors (theme-aware)\n  const foreground = api.getColor('foreground');\n  const cardBg = api.getColor('card');\n  const mutedBg = api.getColor('muted');\n  const mutedFg = api.getColor('muted-foreground');\n  const primaryColor = api.getColor('primary');\n\n  const colors = {\n    stroke: foreground,\n    fill: cardBg,\n    mutedFill: mutedBg,\n    text: foreground,\n    ellipsis: mutedFg,\n    depth: primaryColor\n  };\n\n  const fonts = {\n    fontFamily: api.getFont('default'),\n    monoFamily: api.getFont('mono')\n  };\n\n  // Track y-positions for each column's chain\n  const columnYPositions = columns.map(() => []);\n\n  // Draw horizontal chain nodes\n  for (let i = 0; i < columns.length; i++) {\n    const col = columns[i];\n    const x = (i + 1) * spacing;\n    const y = topRowY;\n\n    if (col.label === '...') {\n      // Draw horizontal ellipsis dots instead of a circle\n      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);\n    } else {\n      // First column uses muted background\n      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;\n      const nodeColors = { ...colors, fill: nodeFill };\n      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);\n    }\n\n    // Draw horizontal connection to next column\n    if (i < columns.length - 1) {\n      const nextX = (i + 2) * spacing;\n      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);\n    }\n\n    // Track positions for vertical chains\n    columnYPositions[i].push({ x, y });\n  }\n\n  // Draw vertical chains\n  for (let colIdx = 0; colIdx < columns.length; colIdx++) {\n    const col = columns[colIdx];\n    if (col.chain.length === 0) continue;\n\n    const x = (colIdx + 1) * spacing;\n    let currentY = chainStartY;\n\n    for (let chainIdx = 0; chainIdx < col.chain.length; chainIdx++) {\n      const label = col.chain[chainIdx];\n      const isEllipsis = label === '...';\n\n      if (isEllipsis) {\n        // Draw vertical ellipsis dots centered where the circle would be\n        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);\n        columnYPositions[colIdx].push({ x, y: currentY });\n\n        // Connection from previous\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\n\n        currentY += verticalSpacing;\n      } else {\n        // Draw regular node\n        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);\n        columnYPositions[colIdx].push({ x, y: currentY });\n\n        // Connection from previous\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\n\n        currentY += verticalSpacing;\n      }\n    }\n  }\n\n  // Draw depth labels if enabled (for all columns except start and ellipsis)\n  if (showDepth) {\n    const fontSize = radius * 0.7;\n    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\n    ctx.fillStyle = colors.depth;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n\n    for (let colIdx = 1; colIdx < columns.length; colIdx++) {\n      const col = columns[colIdx];\n      if (col.label === '...') continue;\n      const x = (colIdx + 1) * spacing;\n      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];\n      const depth = col.depth ?? (colIdx + col.fullChainLength);\n      const depthY = lastPos.y + radius * 2;\n      const word = depth === 1 ? 'move' : 'moves';\n      const singleLine = `${depth} ${word}`;\n\n      // Check if single line fits within column spacing\n      const textWidth = ctx.measureText(singleLine).width;\n      if (textWidth < spacing * 0.95) {\n        ctx.fillText(singleLine, x, depthY);\n      } else {\n        ctx.fillText(String(depth), x, depthY);\n        ctx.fillText(word, x, depthY + fontSize * 1.2);\n      }\n    }\n  }\n\n  // Draw \"(if no breaks)\" label to the right of horizontal chain\n  // Show when: last column AND has a chain AND its floor number equals max floor\n  if (showDepth) {\n    // Find last non-ellipsis column index\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =>\n      col.label !== '...' ? i : idx, 0);\n\n    // Find maximum floor number across all columns and chains\n    const maxFloor = Math.max(\n      ...columns.filter(c => c.label !== '...' && !isNaN(c.label)).map(c => Number(c.label)),\n      ...columns.flatMap(c => c.chain.filter(l => l !== '...' && !isNaN(l)).map(Number))\n    );\n\n    const col = columns[lastNonEllipsisIndex];\n    const shouldShowLabel = col.label !== '...'\n      && col.chain.length > 0\n      && Number(col.label) === maxFloor;\n\n    if (shouldShowLabel) {\n      const x = (lastNonEllipsisIndex + 1) * spacing;\n      const y = topRowY;\n      const fontSize = radius * 0.7; // Match the depth label font size\n\n      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\n      ctx.fillStyle = colors.depth;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n\n      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)\n      let lastEllipsisIndex = -1;\n      for (let i = columns.length - 1; i >= 0; i--) {\n        if (columns[i] === '...' || columns[i].label === '...') {\n          lastEllipsisIndex = i;\n          break;\n        }\n      }\n\n      // Count non-start columns from after the last ellipsis to the end\n      let horizontalMoves = 0;\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i <= lastNonEllipsisIndex; i++) {\n        if (columns[i] !== '...' && columns[i].label !== '...') {\n          horizontalMoves++;\n        }\n      }\n\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\n      const firstLine = `${horizontalMoves} ${word}`;\n      const secondLine = '(if no breaks)';\n\n      // Measure both lines to find the widest one\n      const firstLineWidth = ctx.measureText(firstLine).width;\n      const secondLineWidth = ctx.measureText(secondLine).width;\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\n\n      // Position label so it starts after the circle with spacing, centered on maxWidth\n      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;\n      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);\n      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);\n    }\n  }\n\n  // Resize iframe to fit canvas\n  api.requestResize(canvasHeight);\n}\n```\n:::","dynamicBlocks",[43,60,78,92,101,123,160,211],{"_44":45,"_46":47,"_48":49,"_50":51,"_15":57,"_58":59},"type","dynamic","mode","component","componentId","#strategy-tree","props",{"_52":53},"columns",[54,55,56],"S","3","6","Simple strategy: drop from floor 3, then floor 6","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/optimisation/egg-dropping.md",{"_44":45,"_46":47,"_48":49,"_50":61,"_15":77,"_58":59},{"_52":62,"_73":74,"_75":76},[54,63,69],{"_64":55,"_65":66},"label","chain",[67,68],1,2,{"_64":56,"_65":70},[71,72],4,5,"showDepth",true,"minWidth",280,"Strategy tree: floors 3 and 6 with fallback chains",{"_44":45,"_46":47,"_48":49,"_50":79,"_15":91,"_58":59},{"_52":80,"_73":74,"_75":90},[54,81,84,88],{"_64":82,"_65":83},"2",[67],{"_64":85,"_65":86},"4",[87],3,{"_64":56,"_65":89},[72],320,"Strategy tree: floors 2, 4, and 6 with single fallbacks",{"_44":45,"_46":47,"_48":49,"_50":93,"_15":100,"_58":59},{"_52":94,"_73":74},[54,95,97,56],{"_64":55,"_65":96},[67,68],{"_64":98,"_65":99},"5",[71],"Optimal strategy tree for 6 floors",{"_44":45,"_46":47,"_48":49,"_50":102,"_15":122,"_58":59},{"_52":103,"_73":74,"_75":90},[54,104,109,115],{"_64":105,"_65":106},"50",[67,68,107,107,107,107,108],"...",49,{"_64":110,"_65":111},"75",[112,113,107,114],51,52,74,{"_64":116,"_65":117},"100",[118,119,107,120,121],76,77,98,99,"Strategy tree: binary split from floor 50",{"_44":45,"_46":47,"_48":49,"_50":124,"_15":159,"_58":59},{"_52":125,"_73":74,"_75":158},[54,126,132,137,107,142,149,155],{"_64":127,"_65":128},"10",{"_129":67,"_130":131},"from","to",9,{"_64":133,"_65":134},"20",{"_129":135,"_130":136},11,19,{"_64":138,"_65":139},"30",{"_129":140,"_130":141},21,29,{"_64":143,"_65":144,"_147":148},"80",{"_129":145,"_130":146},71,79,"depth",17,{"_64":150,"_65":151,"_147":154},"90",{"_129":152,"_130":153},81,89,18,{"_64":116,"_65":156,"_147":136},{"_129":157,"_130":121},91,800,"Strategy tree: steps of 10",{"_44":45,"_46":47,"_48":49,"_50":161,"_15":210,"_58":59},{"_52":162,"_73":74,"_75":209},[54,163,167,172,177,180,184,189,193,198,201,205,116],{"_64":164,"_65":165},"14",{"_129":67,"_130":166},13,{"_64":168,"_65":169},"27",{"_129":170,"_130":171},15,26,{"_64":173,"_65":174},"39",{"_129":175,"_130":176},28,38,{"_64":105,"_65":178},{"_129":179,"_130":108},40,{"_64":181,"_65":182},"60",{"_129":112,"_130":183},59,{"_64":185,"_65":186},"69",{"_129":187,"_130":188},61,68,{"_64":190,"_65":191},"77",{"_129":192,"_130":118},70,{"_64":194,"_65":195},"84",{"_129":196,"_130":197},78,83,{"_64":150,"_65":199},{"_129":200,"_130":153},85,{"_64":202,"_65":203},"95",{"_129":157,"_130":204},94,{"_64":206,"_65":207},"99",{"_129":208,"_130":120},96,1100,"Optimal strategy tree for 100 floors",{"_44":45,"_46":47,"_48":49,"_50":212,"_15":246,"_58":59},{"_52":213,"_73":74,"_75":158},[54,214,216,218,220,222,224,226,228,230,232,234,236,241,245],{"_64":164,"_65":215},{"_129":67,"_130":166},{"_64":168,"_65":217},{"_129":170,"_130":171},{"_64":173,"_65":219},{"_129":175,"_130":176},{"_64":105,"_65":221},{"_129":179,"_130":108},{"_64":181,"_65":223},{"_129":112,"_130":183},{"_64":185,"_65":225},{"_129":187,"_130":188},{"_64":190,"_65":227},{"_129":192,"_130":118},{"_64":194,"_65":229},{"_129":196,"_130":197},{"_64":150,"_65":231},{"_129":200,"_130":153},{"_64":202,"_65":233},{"_129":157,"_130":204},{"_64":206,"_65":235},{"_129":208,"_130":120},{"_64":237,"_65":238},"102",[239,240],100,101,{"_64":242,"_65":243},"104",[244],103,"105","Maximum building height with 14 drops: 105 floors","inlineComponents",{"_249":250},"strategy-tree",{"_13":249,"_251":252,"_253":254},"code","// Normalize columns: expand ranges, compute full chain length\nfunction normalizeColumns(rawColumns) {\n  return rawColumns.map(col => {\n    // Handle shorthand: plain string → { label: \"X\" }\n    if (typeof col === 'string') {\n      return { label: col, chain: [], fullChainLength: 0, depth: null };\n    }\n\n    const { label, chain, depth } = col;\n    let chainLabels = [];\n    let fullLength = 0;\n\n    if (!chain) {\n      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };\n    }\n\n    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]\n    if (typeof chain === 'object' && !Array.isArray(chain)) {\n      const { from, to } = chain;\n      fullLength = to - from + 1;\n      for (let i = from; i <= to; i++) {\n        chainLabels.push(String(i));\n      }\n    } else {\n      chainLabels = chain.map(String);\n      // Derive full length from first and last numeric items\n      const nums = chainLabels.filter(l => l !== '...').map(Number);\n      if (nums.length >= 2) {\n        fullLength = nums[nums.length - 1] - nums[0] + 1;\n      } else {\n        fullLength = nums.length;\n      }\n    }\n\n    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };\n  });\n}\n\n// Compute layout parameters based on columns and container width\nfunction computeLayout(columns, containerWidth, options) {\n  const { showDepth, minWidth } = options;\n  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;\n  const numCols = columns.length;\n\n  // Column spacing (+1 for right-side padding so last node isn't clipped)\n  const totalSpacing = numCols + 1;\n  const spacing = Math.min(effectiveWidth / totalSpacing, 100);\n  const radius = Math.min(spacing * 0.35, 20);\n\n  // Vertical spacing\n  const verticalSpacing = radius * 3;\n\n  // Calculate height needed\n  let maxVisibleChainLength = 0;\n  for (const col of columns) {\n    if (col.chain.length > maxVisibleChainLength) {\n      maxVisibleChainLength = col.chain.length;\n    }\n  }\n\n  const topRowY = radius * 2.5;\n  const chainStartY = topRowY + verticalSpacing;\n  let canvasHeight;\n\n  if (maxVisibleChainLength > 0) {\n    // Bottom of the deepest chain node circle\n    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;\n  } else {\n    // No chains: bottom of top row circles\n    canvasHeight = topRowY + radius;\n  }\n\n  if (showDepth) {\n    // Depth labels: radius gap below circle + up to 2 lines of text\n    canvasHeight += radius * 3;\n  }\n\n  canvasHeight += radius; // Bottom padding\n\n  // Calculate canvas width with extra space for \"(if no breaks)\" label\n  let canvasWidth = totalSpacing * spacing;\n\n  // Check if we need to add space for the \"(if no breaks)\" label\n  if (showDepth) {\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =>\n      col.label !== '...' ? i : idx, 0);\n    const lastCol = columns[lastNonEllipsisIndex];\n    const maxFloor = Math.max(\n      ...columns.filter(c => c.label !== '...' && !isNaN(c.label)).map(c => Number(c.label)),\n      ...columns.flatMap(c => c.chain.filter(l => l !== '...' && !isNaN(l)).map(Number))\n    );\n\n    const shouldShowLabel = lastCol.label !== '...'\n      && lastCol.chain.length > 0\n      && Number(lastCol.label) === maxFloor;\n\n    if (shouldShowLabel) {\n      // Count horizontal moves to calculate label width\n      let lastEllipsisIndex = -1;\n      for (let i = columns.length - 1; i >= 0; i--) {\n        if (columns[i] === '...' || columns[i].label === '...') {\n          lastEllipsisIndex = i;\n          break;\n        }\n      }\n\n      let horizontalMoves = 0;\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i <= lastNonEllipsisIndex; i++) {\n        if (columns[i] !== '...' && columns[i].label !== '...') {\n          horizontalMoves++;\n        }\n      }\n\n      // Calculate actual label width for two-line format: \"X moves\" / \"(if no breaks)\"\n      // We need to estimate based on character count since we don't have canvas context here\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\n      const firstLine = `${horizontalMoves} ${word}`;\n      const secondLine = '(if no breaks)';\n\n      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7\n      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace\n      const firstLineWidth = firstLine.length * avgCharWidth;\n      const secondLineWidth = secondLine.length * avgCharWidth;\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\n\n      // Add label width + spacing + padding\n      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;\n    }\n  }\n\n  return {\n    spacing,\n    radius,\n    verticalSpacing,\n    topRowY,\n    chainStartY,\n    canvasHeight,\n    canvasWidth\n  };\n}\n\n// Draw a circle with centered label\nfunction drawCircleNode(ctx, x, y, radius, label, colors, fonts) {\n  const { fill, stroke, text } = colors;\n  const { fontFamily } = fonts;\n\n  // Circle\n  ctx.beginPath();\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\n  ctx.fillStyle = fill;\n  ctx.fill();\n  ctx.strokeStyle = stroke;\n  ctx.lineWidth = 1.5;\n  ctx.stroke();\n\n  // Label\n  ctx.fillStyle = text;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n\n  // Font size based on label length\n  let fontSize;\n  if (label.length <= 2) {\n    fontSize = radius * 0.9;\n  } else if (label.length === 3) {\n    fontSize = radius * 0.75;\n  } else {\n    fontSize = radius * 0.6;\n  }\n\n  ctx.font = `bold ${fontSize}px ${fontFamily}`;\n  ctx.fillText(label, x, y);\n}\n\n// Draw an arrowhead at the given tip position and angle\nfunction drawArrowhead(ctx, tipX, tipY, angle, radius) {\n  const size = Math.max(3, radius * 0.3);\n  ctx.save();\n  ctx.translate(tipX, tipY);\n  ctx.rotate(angle);\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(-size, -size * 0.6);\n  ctx.lineTo(-size, size * 0.6);\n  ctx.closePath();\n  ctx.fill();\n  ctx.restore();\n}\n\n// Draw a connection line between two nodes with optional arrowhead\nfunction drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {\n  const { stroke } = colors;\n  ctx.strokeStyle = stroke;\n  ctx.lineWidth = 1.5;\n  ctx.lineCap = 'round';\n\n  // Calculate start and end points at circle boundary\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dist = Math.sqrt(dx * dx + dy * dy);\n  const angle = Math.atan2(dy, dx);\n\n  const startX = x1 + (dx / dist) * radius;\n  const startY = y1 + (dy / dist) * radius;\n  const endX = x2 - (dx / dist) * radius;\n  const endY = y2 - (dy / dist) * radius;\n\n  // Draw line\n  ctx.beginPath();\n  ctx.moveTo(startX, startY);\n  ctx.lineTo(endX, endY);\n  ctx.stroke();\n\n  // Draw arrowhead\n  if (showArrows) {\n    ctx.fillStyle = stroke;\n    drawArrowhead(ctx, endX, endY, angle, radius);\n  }\n}\n\n// Draw three vertical ellipsis dots\nfunction drawVerticalEllipsis(ctx, x, y, color, radius) {\n  ctx.fillStyle = color;\n  const dotRadius = Math.max(1.5, radius * 0.125);\n  const gap = Math.max(5, radius * 0.4);\n\n  for (let i = -1; i <= 1; i++) {\n    ctx.beginPath();\n    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\n// Draw three horizontal ellipsis dots\nfunction drawHorizontalEllipsis(ctx, x, y, color, radius) {\n  ctx.fillStyle = color;\n  const dotRadius = Math.max(1.5, radius * 0.125);\n  const gap = Math.max(5, radius * 0.4);\n\n  for (let i = -1; i <= 1; i++) {\n    ctx.beginPath();\n    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n}\n\nfunction draw(options) {\n  const { canvas, api, width: containerWidth, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  // Default props\n  const {\n    columns: rawColumns = [],\n    showDepth = false,\n    showArrows = true,\n    minWidth = 0,\n  } = props;\n\n  if (!rawColumns || rawColumns.length === 0) {\n    canvas.width = containerWidth;\n    canvas.height = 100;\n    ctx.fillStyle = api.getColor('muted-foreground');\n    ctx.font = `14px ${api.getFont('default')}`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('No columns provided', containerWidth / 2, 50);\n    api.requestResize(100);\n    return;\n  }\n\n  // Normalize columns\n  const columns = normalizeColumns(rawColumns);\n\n  // Compute layout\n  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });\n  const {\n    spacing,\n    radius,\n    verticalSpacing,\n    topRowY,\n    chainStartY,\n    canvasHeight,\n    canvasWidth\n  } = layout;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Colors (theme-aware)\n  const foreground = api.getColor('foreground');\n  const cardBg = api.getColor('card');\n  const mutedBg = api.getColor('muted');\n  const mutedFg = api.getColor('muted-foreground');\n  const primaryColor = api.getColor('primary');\n\n  const colors = {\n    stroke: foreground,\n    fill: cardBg,\n    mutedFill: mutedBg,\n    text: foreground,\n    ellipsis: mutedFg,\n    depth: primaryColor\n  };\n\n  const fonts = {\n    fontFamily: api.getFont('default'),\n    monoFamily: api.getFont('mono')\n  };\n\n  // Track y-positions for each column's chain\n  const columnYPositions = columns.map(() => []);\n\n  // Draw horizontal chain nodes\n  for (let i = 0; i < columns.length; i++) {\n    const col = columns[i];\n    const x = (i + 1) * spacing;\n    const y = topRowY;\n\n    if (col.label === '...') {\n      // Draw horizontal ellipsis dots instead of a circle\n      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);\n    } else {\n      // First column uses muted background\n      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;\n      const nodeColors = { ...colors, fill: nodeFill };\n      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);\n    }\n\n    // Draw horizontal connection to next column\n    if (i < columns.length - 1) {\n      const nextX = (i + 2) * spacing;\n      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);\n    }\n\n    // Track positions for vertical chains\n    columnYPositions[i].push({ x, y });\n  }\n\n  // Draw vertical chains\n  for (let colIdx = 0; colIdx < columns.length; colIdx++) {\n    const col = columns[colIdx];\n    if (col.chain.length === 0) continue;\n\n    const x = (colIdx + 1) * spacing;\n    let currentY = chainStartY;\n\n    for (let chainIdx = 0; chainIdx < col.chain.length; chainIdx++) {\n      const label = col.chain[chainIdx];\n      const isEllipsis = label === '...';\n\n      if (isEllipsis) {\n        // Draw vertical ellipsis dots centered where the circle would be\n        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);\n        columnYPositions[colIdx].push({ x, y: currentY });\n\n        // Connection from previous\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\n\n        currentY += verticalSpacing;\n      } else {\n        // Draw regular node\n        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);\n        columnYPositions[colIdx].push({ x, y: currentY });\n\n        // Connection from previous\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\n\n        currentY += verticalSpacing;\n      }\n    }\n  }\n\n  // Draw depth labels if enabled (for all columns except start and ellipsis)\n  if (showDepth) {\n    const fontSize = radius * 0.7;\n    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\n    ctx.fillStyle = colors.depth;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n\n    for (let colIdx = 1; colIdx < columns.length; colIdx++) {\n      const col = columns[colIdx];\n      if (col.label === '...') continue;\n      const x = (colIdx + 1) * spacing;\n      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];\n      const depth = col.depth ?? (colIdx + col.fullChainLength);\n      const depthY = lastPos.y + radius * 2;\n      const word = depth === 1 ? 'move' : 'moves';\n      const singleLine = `${depth} ${word}`;\n\n      // Check if single line fits within column spacing\n      const textWidth = ctx.measureText(singleLine).width;\n      if (textWidth < spacing * 0.95) {\n        ctx.fillText(singleLine, x, depthY);\n      } else {\n        ctx.fillText(String(depth), x, depthY);\n        ctx.fillText(word, x, depthY + fontSize * 1.2);\n      }\n    }\n  }\n\n  // Draw \"(if no breaks)\" label to the right of horizontal chain\n  // Show when: last column AND has a chain AND its floor number equals max floor\n  if (showDepth) {\n    // Find last non-ellipsis column index\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =>\n      col.label !== '...' ? i : idx, 0);\n\n    // Find maximum floor number across all columns and chains\n    const maxFloor = Math.max(\n      ...columns.filter(c => c.label !== '...' && !isNaN(c.label)).map(c => Number(c.label)),\n      ...columns.flatMap(c => c.chain.filter(l => l !== '...' && !isNaN(l)).map(Number))\n    );\n\n    const col = columns[lastNonEllipsisIndex];\n    const shouldShowLabel = col.label !== '...'\n      && col.chain.length > 0\n      && Number(col.label) === maxFloor;\n\n    if (shouldShowLabel) {\n      const x = (lastNonEllipsisIndex + 1) * spacing;\n      const y = topRowY;\n      const fontSize = radius * 0.7; // Match the depth label font size\n\n      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\n      ctx.fillStyle = colors.depth;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n\n      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)\n      let lastEllipsisIndex = -1;\n      for (let i = columns.length - 1; i >= 0; i--) {\n        if (columns[i] === '...' || columns[i].label === '...') {\n          lastEllipsisIndex = i;\n          break;\n        }\n      }\n\n      // Count non-start columns from after the last ellipsis to the end\n      let horizontalMoves = 0;\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i <= lastNonEllipsisIndex; i++) {\n        if (columns[i] !== '...' && columns[i].label !== '...') {\n          horizontalMoves++;\n        }\n      }\n\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\n      const firstLine = `${horizontalMoves} ${word}`;\n      const secondLine = '(if no breaks)';\n\n      // Measure both lines to find the widest one\n      const firstLineWidth = ctx.measureText(firstLine).width;\n      const secondLineWidth = ctx.measureText(secondLine).width;\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\n\n      // Position label so it starts after the circle with spacing, centered on maxWidth\n      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;\n      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);\n      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);\n    }\n  }\n\n  // Resize iframe to fit canvas\n  api.requestResize(canvasHeight);\n}","startLine",314]
