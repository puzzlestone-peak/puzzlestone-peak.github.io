<!DOCTYPE html><html lang="en" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1LM5FNK1VX"></script><meta name="color-scheme" content="dark light"/><link rel="preload" href="/assets/poppins-400-cpxAROuN.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-500-C8OXljZJ.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-600-zEkxB9Mr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-700-Qrb0O0WB.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Equal Shape Cutting 3 - Puzzlestone Peak</title><meta name="description" content="Cut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size."/><meta property="og:title" content="Equal Shape Cutting 3 - Puzzlestone Peak"/><meta property="og:description" content="Cut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size."/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Equal Shape Cutting 3 - Puzzlestone Peak"/><meta name="twitter:description" content="Cut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size."/><meta name="keywords" content="geometry, easy, logic puzzle"/><link rel="modulepreload" href="/assets/manifest-c98cd44b.js"/><link rel="modulepreload" href="/assets/entry.client-BQEHofJp.js"/><link rel="modulepreload" href="/assets/index-DIth0oIc.js"/><link rel="modulepreload" href="/assets/root-DXbBOY7W.js"/><link rel="modulepreload" href="/assets/Logo-BRp-LhsU.js"/><link rel="modulepreload" href="/assets/use-dark-mode-mdHJdo6o.js"/><link rel="modulepreload" href="/assets/card-fxtljBLB.js"/><link rel="modulepreload" href="/assets/NavHeightContext-BwIQMGhB.js"/><link rel="modulepreload" href="/assets/difficulty-types-Yz_I7Ggm.js"/><link rel="modulepreload" href="/assets/expeditionIndex-fN_P2HPz.js"/><link rel="modulepreload" href="/assets/puzzleIndex-BCAd8ZEm.js"/><link rel="modulepreload" href="/assets/loader-circle-liqmjHjk.js"/><link rel="modulepreload" href="/assets/puzzle-detail-CXwS6aRw.js"/><link rel="modulepreload" href="/assets/useBack-pagEjglP.js"/><link rel="modulepreload" href="/assets/ItemCardList-C-RxMh7h.js"/><link rel="modulepreload" href="/assets/ErrorBoundary-B5mn_yui.js"/><link rel="modulepreload" href="/assets/chevron-left-ClYT8ZkK.js"/><script>
              (function initTheme() {
                if (localStorage.getItem('darkmode') === '1') {
                  document.documentElement.classList.add('dark');
                }
              })();
            </script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-1LM5FNK1VX');
            </script><link rel="stylesheet" href="/assets/root-DX3mS3gq.css"/><link rel="stylesheet" href="/assets/useBack-CyAuISp2.css"/></head><body><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><div class="min-h-screen bg-background"><nav class="sticky top-0 z-[1000] border-b border-border bg-card"><div class="container mx-auto px-6"><div class="flex h-16 items-center justify-between"><a class="flex items-center gap-3 text-nav-foreground no-underline" href="/" data-discover="true"><svg class="h-10 w-10 text-nav-foreground" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2211.37 2208.98" aria-label="Puzzlestone Peak Logo"><g><g><path fill="currentColor" d="M1108.28,0c649.77,5.24,1114.13,533.8,1102.89,1120-11.85,618.13-493.23,1100.61-1128,1088.81C450,2197-8.61,1690.25.12,1087.2,8.81,487.59,492.57,4.1,1108.28,0ZM121.13,1114.76c1.14,543.44,432.5,984.51,996.37,978.51,557.06-5.93,978-444.2,971.35-995.6C2082,528.37,1628.73,114,1095.67,118.84,573.44,123.64,121,538.05,121.13,1114.76Z"></path><path fill="currentColor" d="M2021.18,1304.81c-125.17-118.57-243.11-238.8-364.9-359.1-2.56,14.24,1.92,24,3.82,33.95,4.41,23.07,11.61,45.81,13.73,69.05,4,43.53,24.59,76.14,55.56,106,57.17,55,111.85,112.69,167.64,169.19,3.08,3.11,6.78,5.62,13.43,11.07l-29.92-94c24.62,13.75,40.06,32.2,57.87,47.59,20.91,18.06,40.77,37.34,61.77,55.28,8.84,7.54,10.58,14.7,7.36,25.8-20.06,69.13-47.63,135-81.34,198.6-9.36,17.65-14.91,9.53-22.48,0q-90.9-114.8-181.89-229.53-95.47-120.15-191.27-240c-1-1.26-2.64-2-7-5.25,9.72,71.9,28.35,139.3,37.91,208.53-107.81-169.7-206.63-344.59-311.28-516-9.22,3.51-3.87,12.13-10,16-12-7.35-18.72-20.06-27.45-30.66q-45.4-55.15-89.63-111.28c-9.15-11.66-14.16-9.84-23.87.14-12.63,13-13.15,24.45-6.86,40.56,17.11,43.76,35.07,87.25,48.64,132.33,1,3.28,1.72,6.64,3.84,14.9L1022.35,771.4l-2.78,2.64c13.51,22.36,26.89,44.8,40.55,67.06,24.58,40.09,49,80.27,74.21,120,6,9.48,6,15.92-1.51,24.54-28.26,32.31-55.84,65.21-83.61,97.95-15.86,18.69-15.92,18.85,1.06,35.86q114.7,114.87,229.51,229.63c2.84,2.84,5.41,6,11.73,12.92-46.79-8.28-88.16-19-132.09-25.8l298,291.64,3.93-2.17L1430.53,1306c23.59,34.58,44.25,64.91,65,95.22q123.36,180.63,251.43,357.94c1.38,1.9,2.39,4.13,4,5.79,13.32,13.77,9.47,24-4.25,35.81-47.75,41.22-98,78.83-151.9,111.65-8.1,4.94-16.34,5.41-25.27,5.45-104.54.45-203.43-26.94-300.81-61.29-107-37.74-210.39-84.76-315.67-126.92-149.26-59.78-302.65-102.49-463-118.55-55.13-5.53-110.43-4.65-165.7-3.63-9.28.18-16.45-.49-22-10-61.64-105.06-105-216.59-122.31-337.73-1.51-10.61,1.49-17.46,8.71-24.81q184.24-187.54,367.82-375.72c10-10.28,15.36-7.56,23.67,1.12,35.77,37.39,72.31,74.05,108,111.53,8.31,8.73,13.08,10.25,21.86.21Q871.5,787.48,1033.71,603.54c21-23.84,42.59-47.13,63.21-71.27,8.62-10.09,13.52-8.08,21.52,1q195.46,222.81,391.26,445.32c9.78,11.18,14.44,10.28,23.92.32,36.07-37.91,73.29-74.72,109.47-112.54,8.26-8.63,13.09-7.71,20.87.25q175.07,179.21,350.85,357.7c13.23,13.39,20.15,25.9,13.9,44.57C2025.39,1278.84,2024.3,1289.49,2021.18,1304.81ZM564.41,931.41c0,18.05-1.59,31,.28,43.31,7.16,47.25-7.05,85.12-43.68,116.5-15.75,13.5-32.89,30.56-38.74,49.32-11,35.33-14.27,73.08-20.87,110.49,8.29-1,11-6.85,14.51-11.08q84.69-101.51,174.52-198.49c8.71-9.46,11.86-16.15.08-25.48-9.14-7.24-16.56-16.62-24.93-24.86C606.56,972.43,587.42,953.86,564.41,931.41Z"></path><path fill="currentColor" d="M1258,2036.19c-156.22,31.67-307.68,13.84-456-37.14-128-44-242.37-111.53-346.16-205.19,33.78-3.18,62.72.36,91.57,3.41,177.71,18.78,340.49,86.11,502.68,155.25,63.74,27.17,127.88,53.3,193.63,75.29C1248.52,2029.42,1254.05,2029.85,1258,2036.19Z"></path><path fill="currentColor" d="M1461.61,671.32c.48-75.58,59.09-133.3,135-132.91,69.62.35,129.18,61.43,128.77,132.05-.43,74-59.91,132.06-134.66,131.48C1518.42,801.37,1461.15,743.42,1461.61,671.32Z"></path></g></g></svg><span class="text-[1.25rem] font-semibold leading-none">Puzzlestone Peak</span></a><div class="hidden items-center gap-6 md:flex"><ul class="flex items-center gap-8"><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/progress" data-discover="true">Progress</a></li></ul><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div><button class="flex h-8 w-8 cursor-pointer flex-col justify-around border-none bg-transparent p-1 text-nav-foreground md:hidden" aria-label="Toggle mobile menu" aria-expanded="false" aria-controls="mobile-menu"><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span></button></div></div></nav><div id="mobile-menu" class="fixed left-0 right-0 top-16 z-[999] border-b border-border bg-card shadow-lg transition-all duration-300 md:hidden pointer-events-none -translate-y-full opacity-0"><div class="px-6 pb-6 pt-4"><ul class="flex flex-col gap-3"><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/progress" data-discover="true">Progress</a></li></ul><div class="mt-4 flex justify-center border-t border-border pt-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div></div></div><main><div class="container mx-auto px-4 py-6 max-w-4xl"><a class="inline-flex items-center gap-1.5 text-link hover:text-link-hover hover:underline mb-6 cursor-pointer" href="/puzzles" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left size-4" aria-hidden="true"><path d="m15 18-6-6 6-6"></path></svg>Back</a><div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-4"><h1 class="text-4xl font-bold text-foreground sm:flex-1">Equal Shape Cutting 3</h1><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><div class="space-y-4 border-b border-divider pb-6 mb-6"><div><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="text-sm text-muted-foreground"><span>Created: <!-- -->February 2, 2026</span></div></div><div class="my-6"><h2 class="text-lg font-semibold mb-3">Previous puzzle in this series</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/equal-shape-cutting-2" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Equal Shape Cutting 2</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Cut the L-shape into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.</p></div></a></div></div><div class="markdown-content prose max-w-none space-y-4"><div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Stone */
  --color-stone-50: oklch(0.98 0.010 250);
  --color-stone-100: oklch(0.95 0.015 250);
  --color-stone-200: oklch(0.90 0.025 250);
  --color-stone-300: oklch(0.83 0.035 250);
  --color-stone-400: oklch(0.74 0.045 250);
  --color-stone-500: oklch(0.65 0.055 250);
  --color-stone-600: oklch(0.55 0.060 250);
  --color-stone-700: oklch(0.45 0.055 250);
  --color-stone-800: oklch(0.35 0.045 250);
  --color-stone-900: oklch(0.27 0.035 250);
  --color-stone-950: oklch(0.20 0.025 250);

  /* Teal */
  --color-teal-50: oklch(0.97 0.015 185);
  --color-teal-100: oklch(0.94 0.025 185);
  --color-teal-200: oklch(0.88 0.040 185);
  --color-teal-300: oklch(0.80 0.055 185);
  --color-teal-400: oklch(0.70 0.070 185);
  --color-teal-500: oklch(0.60 0.080 185);
  --color-teal-600: oklch(0.50 0.085 185);
  --color-teal-700: oklch(0.40 0.080 185);
  --color-teal-800: oklch(0.32 0.070 185);
  --color-teal-900: oklch(0.25 0.055 185);
  --color-teal-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-stone-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-stone-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-stone-600);
  --color-input: var(--color-stone-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-stone-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-stone-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-stone-200);
  --color-difficulty-open-foreground: var(--color-stone-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-teal-600);
  --gradient-progress-end: var(--color-teal-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-stone-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-stone-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-stone-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-stone-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-stone-400);
  --color-text-emphasis: var(--color-stone-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-stone-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-stone-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-stone-700);
  --color-difficulty-open-foreground: var(--color-stone-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-teal-600);
  --gradient-progress-end: var(--color-teal-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;mode&quot;:&quot;puzzle&quot;};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/geometry/equal-shape-cutting/equal-shape-cutting-3.md




















































function draw(options) {
  const { canvas, api, theme, width, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  const lineWidth = 2;
  const guideLineWidth = 0.5;
  const solutionLineWidth = 4;
  const padding = 20;
  const maxSize = 400;
  const imageSize = Math.min(width, maxSize);

  // Mode: &#x27;puzzle&#x27;, &#x27;guides&#x27;, or &#x27;solution&#x27;
  const mode = props?.mode || &#x27;puzzle&#x27;;

  // Calculate trapezoid dimensions
  const triangleSize = imageSize / 4;
  const triangleHeight = triangleSize * Math.sqrt(3) / 2;
  const trapezoidHeight = 2 * triangleHeight;

  canvas.width = imageSize;
  canvas.height = trapezoidHeight + 2 * padding;

  // Get colors
  const foregroundColor = api.getColor(&#x27;foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Helper function to draw all triangles
  const drawTriangles = (strokeWidth) =&gt; {
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = strokeWidth;
    ctx.lineCap = &#x27;round&#x27;;
    ctx.lineJoin = &#x27;round&#x27;;

    // Top row: 5 triangles starting at triangleSize (offset by 1 triangle width from trapezoid left edge)
    // Pattern: upright, inverted, upright, inverted, upright
    const topY = padding;

    for (let i = 0; i &lt; 5; i++) {
      const x = triangleSize + i * (triangleSize / 2);
      ctx.beginPath();
      if (i % 2 === 0) {
        // Upright equilateral triangle
        ctx.moveTo(x, topY);
        ctx.lineTo(x + triangleSize / 2, topY + triangleHeight);
        ctx.lineTo(x - triangleSize / 2, topY + triangleHeight);
      } else {
        // Inverted equilateral triangle
        ctx.moveTo(x - triangleSize / 2, topY);
        ctx.lineTo(x + triangleSize / 2, topY);
        ctx.lineTo(x, topY + triangleHeight);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Bottom row: 7 triangles starting at 0
    // Pattern: upright, inverted, upright, inverted, upright, inverted, upright
    const bottomY = padding + triangleHeight;

    for (let i = 0; i &lt; 7; i++) {
      const x = triangleSize / 2 + i * (triangleSize / 2);
      ctx.beginPath();
      if (i % 2 === 0) {
        // Upright equilateral triangle
        ctx.moveTo(x, bottomY);
        ctx.lineTo(x + triangleSize / 2, bottomY + triangleHeight);
        ctx.lineTo(x - triangleSize / 2, bottomY + triangleHeight);
      } else {
        // Inverted equilateral triangle
        ctx.moveTo(x - triangleSize / 2, bottomY);
        ctx.lineTo(x + triangleSize / 2, bottomY);
        ctx.lineTo(x, bottomY + triangleHeight);
      }
      ctx.closePath();
      ctx.stroke();
    }
  };

  // Helper function to draw trapezoid outline
  const drawOutline = () =&gt; {
    const topLeft = triangleSize;
    const topRight = triangleSize + 2 * triangleSize;
    const bottomLeft = 0;
    const bottomRight = imageSize;
    const topY = padding;
    const bottomY = padding + trapezoidHeight;

    ctx.beginPath();
    ctx.moveTo(topLeft, topY);
    ctx.lineTo(topRight, topY);
    ctx.lineTo(bottomRight, bottomY);
    ctx.lineTo(bottomLeft, bottomY);
    ctx.closePath();
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = &#x27;round&#x27;;
    ctx.lineJoin = &#x27;round&#x27;;
    ctx.stroke();
  };

  // Helper function to draw solution groupings
  const drawSolutionGroupings = () =&gt; {
    ctx.strokeStyle = primaryColor;
    ctx.lineWidth = solutionLineWidth;
    ctx.lineCap = &#x27;butt&#x27;;
    ctx.lineJoin = &#x27;miter&#x27;;

    const ts = triangleSize;
    const row0 = padding;
    const row1 = padding + triangleHeight;
    const row2 = padding + trapezoidHeight;

    ctx.beginPath();

    // Line 1: diagonal from (ts, row0) to (1.5*ts, row1)
    ctx.moveTo(ts, row0);
    ctx.lineTo(1.5 * ts, row1);

    // Line 2: horizontal from (1.5*ts, row1) to (2.5*ts, row1)
    ctx.moveTo(1.5 * ts, row1);
    ctx.lineTo(2.5 * ts, row1);

    // Line 3: diagonal from (2.5*ts, row1) to (3*ts, row0)
    ctx.moveTo(2.5 * ts, row1);
    ctx.lineTo(3 * ts, row0);

    // Line 4: diagonal from (ts, row2) to (1.5*ts, row1)
    ctx.moveTo(ts, row2);
    ctx.lineTo(1.5 * ts, row1);

    // Line 5: diagonal from (2.5*ts, row1) to (3*ts, row2)
    ctx.moveTo(2.5 * ts, row1);
    ctx.lineTo(3 * ts, row2);

    ctx.stroke();
  };

  // Mode-based rendering
  if (mode === &#x27;puzzle&#x27;) {
    // Draw only trapezoid outline
    drawOutline();
  } else if (mode === &#x27;guides&#x27;) {
    // Draw all triangles with guide lines + solution cuts + outline on top
    drawTriangles(guideLineWidth);
    drawSolutionGroupings();
    drawOutline();
  } else if (mode === &#x27;solution&#x27;) {
    // Draw solution groupings + outline on top
    drawSolutionGroupings();
    drawOutline();
  }
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Trapezoid"></iframe></div>
<p>Cut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.</p>
<details class="content-block solution-block" data-type="solution"><summary class="solution-label">Solution</summary><div class="solution-content markdown-content prose max-w-none px-4 py-4 space-y-4"><div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Stone */
  --color-stone-50: oklch(0.98 0.010 250);
  --color-stone-100: oklch(0.95 0.015 250);
  --color-stone-200: oklch(0.90 0.025 250);
  --color-stone-300: oklch(0.83 0.035 250);
  --color-stone-400: oklch(0.74 0.045 250);
  --color-stone-500: oklch(0.65 0.055 250);
  --color-stone-600: oklch(0.55 0.060 250);
  --color-stone-700: oklch(0.45 0.055 250);
  --color-stone-800: oklch(0.35 0.045 250);
  --color-stone-900: oklch(0.27 0.035 250);
  --color-stone-950: oklch(0.20 0.025 250);

  /* Teal */
  --color-teal-50: oklch(0.97 0.015 185);
  --color-teal-100: oklch(0.94 0.025 185);
  --color-teal-200: oklch(0.88 0.040 185);
  --color-teal-300: oklch(0.80 0.055 185);
  --color-teal-400: oklch(0.70 0.070 185);
  --color-teal-500: oklch(0.60 0.080 185);
  --color-teal-600: oklch(0.50 0.085 185);
  --color-teal-700: oklch(0.40 0.080 185);
  --color-teal-800: oklch(0.32 0.070 185);
  --color-teal-900: oklch(0.25 0.055 185);
  --color-teal-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-stone-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-stone-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-stone-600);
  --color-input: var(--color-stone-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-stone-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-stone-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-stone-200);
  --color-difficulty-open-foreground: var(--color-stone-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-teal-600);
  --gradient-progress-end: var(--color-teal-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-stone-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-stone-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-stone-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-stone-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-stone-400);
  --color-text-emphasis: var(--color-stone-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-stone-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-stone-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-stone-700);
  --color-difficulty-open-foreground: var(--color-stone-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-teal-600);
  --gradient-progress-end: var(--color-teal-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;mode&quot;:&quot;solution&quot;};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/geometry/equal-shape-cutting/equal-shape-cutting-3.md




















































function draw(options) {
  const { canvas, api, theme, width, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  const lineWidth = 2;
  const guideLineWidth = 0.5;
  const solutionLineWidth = 4;
  const padding = 20;
  const maxSize = 400;
  const imageSize = Math.min(width, maxSize);

  // Mode: &#x27;puzzle&#x27;, &#x27;guides&#x27;, or &#x27;solution&#x27;
  const mode = props?.mode || &#x27;puzzle&#x27;;

  // Calculate trapezoid dimensions
  const triangleSize = imageSize / 4;
  const triangleHeight = triangleSize * Math.sqrt(3) / 2;
  const trapezoidHeight = 2 * triangleHeight;

  canvas.width = imageSize;
  canvas.height = trapezoidHeight + 2 * padding;

  // Get colors
  const foregroundColor = api.getColor(&#x27;foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Helper function to draw all triangles
  const drawTriangles = (strokeWidth) =&gt; {
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = strokeWidth;
    ctx.lineCap = &#x27;round&#x27;;
    ctx.lineJoin = &#x27;round&#x27;;

    // Top row: 5 triangles starting at triangleSize (offset by 1 triangle width from trapezoid left edge)
    // Pattern: upright, inverted, upright, inverted, upright
    const topY = padding;

    for (let i = 0; i &lt; 5; i++) {
      const x = triangleSize + i * (triangleSize / 2);
      ctx.beginPath();
      if (i % 2 === 0) {
        // Upright equilateral triangle
        ctx.moveTo(x, topY);
        ctx.lineTo(x + triangleSize / 2, topY + triangleHeight);
        ctx.lineTo(x - triangleSize / 2, topY + triangleHeight);
      } else {
        // Inverted equilateral triangle
        ctx.moveTo(x - triangleSize / 2, topY);
        ctx.lineTo(x + triangleSize / 2, topY);
        ctx.lineTo(x, topY + triangleHeight);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Bottom row: 7 triangles starting at 0
    // Pattern: upright, inverted, upright, inverted, upright, inverted, upright
    const bottomY = padding + triangleHeight;

    for (let i = 0; i &lt; 7; i++) {
      const x = triangleSize / 2 + i * (triangleSize / 2);
      ctx.beginPath();
      if (i % 2 === 0) {
        // Upright equilateral triangle
        ctx.moveTo(x, bottomY);
        ctx.lineTo(x + triangleSize / 2, bottomY + triangleHeight);
        ctx.lineTo(x - triangleSize / 2, bottomY + triangleHeight);
      } else {
        // Inverted equilateral triangle
        ctx.moveTo(x - triangleSize / 2, bottomY);
        ctx.lineTo(x + triangleSize / 2, bottomY);
        ctx.lineTo(x, bottomY + triangleHeight);
      }
      ctx.closePath();
      ctx.stroke();
    }
  };

  // Helper function to draw trapezoid outline
  const drawOutline = () =&gt; {
    const topLeft = triangleSize;
    const topRight = triangleSize + 2 * triangleSize;
    const bottomLeft = 0;
    const bottomRight = imageSize;
    const topY = padding;
    const bottomY = padding + trapezoidHeight;

    ctx.beginPath();
    ctx.moveTo(topLeft, topY);
    ctx.lineTo(topRight, topY);
    ctx.lineTo(bottomRight, bottomY);
    ctx.lineTo(bottomLeft, bottomY);
    ctx.closePath();
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = &#x27;round&#x27;;
    ctx.lineJoin = &#x27;round&#x27;;
    ctx.stroke();
  };

  // Helper function to draw solution groupings
  const drawSolutionGroupings = () =&gt; {
    ctx.strokeStyle = primaryColor;
    ctx.lineWidth = solutionLineWidth;
    ctx.lineCap = &#x27;butt&#x27;;
    ctx.lineJoin = &#x27;miter&#x27;;

    const ts = triangleSize;
    const row0 = padding;
    const row1 = padding + triangleHeight;
    const row2 = padding + trapezoidHeight;

    ctx.beginPath();

    // Line 1: diagonal from (ts, row0) to (1.5*ts, row1)
    ctx.moveTo(ts, row0);
    ctx.lineTo(1.5 * ts, row1);

    // Line 2: horizontal from (1.5*ts, row1) to (2.5*ts, row1)
    ctx.moveTo(1.5 * ts, row1);
    ctx.lineTo(2.5 * ts, row1);

    // Line 3: diagonal from (2.5*ts, row1) to (3*ts, row0)
    ctx.moveTo(2.5 * ts, row1);
    ctx.lineTo(3 * ts, row0);

    // Line 4: diagonal from (ts, row2) to (1.5*ts, row1)
    ctx.moveTo(ts, row2);
    ctx.lineTo(1.5 * ts, row1);

    // Line 5: diagonal from (2.5*ts, row1) to (3*ts, row2)
    ctx.moveTo(2.5 * ts, row1);
    ctx.lineTo(3 * ts, row2);

    ctx.stroke();
  };

  // Mode-based rendering
  if (mode === &#x27;puzzle&#x27;) {
    // Draw only trapezoid outline
    drawOutline();
  } else if (mode === &#x27;guides&#x27;) {
    // Draw all triangles with guide lines + solution cuts + outline on top
    drawTriangles(guideLineWidth);
    drawSolutionGroupings();
    drawOutline();
  } else if (mode === &#x27;solution&#x27;) {
    // Draw solution groupings + outline on top
    drawSolutionGroupings();
    drawOutline();
  }
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Four trapezoid regions highlighted"></iframe></div><p>You can visualize the solution by dividing the trapezoid into triangles:</p><div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Stone */
  --color-stone-50: oklch(0.98 0.010 250);
  --color-stone-100: oklch(0.95 0.015 250);
  --color-stone-200: oklch(0.90 0.025 250);
  --color-stone-300: oklch(0.83 0.035 250);
  --color-stone-400: oklch(0.74 0.045 250);
  --color-stone-500: oklch(0.65 0.055 250);
  --color-stone-600: oklch(0.55 0.060 250);
  --color-stone-700: oklch(0.45 0.055 250);
  --color-stone-800: oklch(0.35 0.045 250);
  --color-stone-900: oklch(0.27 0.035 250);
  --color-stone-950: oklch(0.20 0.025 250);

  /* Teal */
  --color-teal-50: oklch(0.97 0.015 185);
  --color-teal-100: oklch(0.94 0.025 185);
  --color-teal-200: oklch(0.88 0.040 185);
  --color-teal-300: oklch(0.80 0.055 185);
  --color-teal-400: oklch(0.70 0.070 185);
  --color-teal-500: oklch(0.60 0.080 185);
  --color-teal-600: oklch(0.50 0.085 185);
  --color-teal-700: oklch(0.40 0.080 185);
  --color-teal-800: oklch(0.32 0.070 185);
  --color-teal-900: oklch(0.25 0.055 185);
  --color-teal-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-stone-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-stone-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-stone-600);
  --color-input: var(--color-stone-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-stone-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-stone-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-stone-200);
  --color-difficulty-open-foreground: var(--color-stone-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-teal-600);
  --gradient-progress-end: var(--color-teal-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-stone-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-stone-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-stone-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-stone-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-stone-400);
  --color-text-emphasis: var(--color-stone-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-stone-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-stone-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-stone-700);
  --color-difficulty-open-foreground: var(--color-stone-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-teal-600);
  --gradient-progress-end: var(--color-teal-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;mode&quot;:&quot;guides&quot;};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/geometry/equal-shape-cutting/equal-shape-cutting-3.md




















































function draw(options) {
  const { canvas, api, theme, width, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  const lineWidth = 2;
  const guideLineWidth = 0.5;
  const solutionLineWidth = 4;
  const padding = 20;
  const maxSize = 400;
  const imageSize = Math.min(width, maxSize);

  // Mode: &#x27;puzzle&#x27;, &#x27;guides&#x27;, or &#x27;solution&#x27;
  const mode = props?.mode || &#x27;puzzle&#x27;;

  // Calculate trapezoid dimensions
  const triangleSize = imageSize / 4;
  const triangleHeight = triangleSize * Math.sqrt(3) / 2;
  const trapezoidHeight = 2 * triangleHeight;

  canvas.width = imageSize;
  canvas.height = trapezoidHeight + 2 * padding;

  // Get colors
  const foregroundColor = api.getColor(&#x27;foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Helper function to draw all triangles
  const drawTriangles = (strokeWidth) =&gt; {
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = strokeWidth;
    ctx.lineCap = &#x27;round&#x27;;
    ctx.lineJoin = &#x27;round&#x27;;

    // Top row: 5 triangles starting at triangleSize (offset by 1 triangle width from trapezoid left edge)
    // Pattern: upright, inverted, upright, inverted, upright
    const topY = padding;

    for (let i = 0; i &lt; 5; i++) {
      const x = triangleSize + i * (triangleSize / 2);
      ctx.beginPath();
      if (i % 2 === 0) {
        // Upright equilateral triangle
        ctx.moveTo(x, topY);
        ctx.lineTo(x + triangleSize / 2, topY + triangleHeight);
        ctx.lineTo(x - triangleSize / 2, topY + triangleHeight);
      } else {
        // Inverted equilateral triangle
        ctx.moveTo(x - triangleSize / 2, topY);
        ctx.lineTo(x + triangleSize / 2, topY);
        ctx.lineTo(x, topY + triangleHeight);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Bottom row: 7 triangles starting at 0
    // Pattern: upright, inverted, upright, inverted, upright, inverted, upright
    const bottomY = padding + triangleHeight;

    for (let i = 0; i &lt; 7; i++) {
      const x = triangleSize / 2 + i * (triangleSize / 2);
      ctx.beginPath();
      if (i % 2 === 0) {
        // Upright equilateral triangle
        ctx.moveTo(x, bottomY);
        ctx.lineTo(x + triangleSize / 2, bottomY + triangleHeight);
        ctx.lineTo(x - triangleSize / 2, bottomY + triangleHeight);
      } else {
        // Inverted equilateral triangle
        ctx.moveTo(x - triangleSize / 2, bottomY);
        ctx.lineTo(x + triangleSize / 2, bottomY);
        ctx.lineTo(x, bottomY + triangleHeight);
      }
      ctx.closePath();
      ctx.stroke();
    }
  };

  // Helper function to draw trapezoid outline
  const drawOutline = () =&gt; {
    const topLeft = triangleSize;
    const topRight = triangleSize + 2 * triangleSize;
    const bottomLeft = 0;
    const bottomRight = imageSize;
    const topY = padding;
    const bottomY = padding + trapezoidHeight;

    ctx.beginPath();
    ctx.moveTo(topLeft, topY);
    ctx.lineTo(topRight, topY);
    ctx.lineTo(bottomRight, bottomY);
    ctx.lineTo(bottomLeft, bottomY);
    ctx.closePath();
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = &#x27;round&#x27;;
    ctx.lineJoin = &#x27;round&#x27;;
    ctx.stroke();
  };

  // Helper function to draw solution groupings
  const drawSolutionGroupings = () =&gt; {
    ctx.strokeStyle = primaryColor;
    ctx.lineWidth = solutionLineWidth;
    ctx.lineCap = &#x27;butt&#x27;;
    ctx.lineJoin = &#x27;miter&#x27;;

    const ts = triangleSize;
    const row0 = padding;
    const row1 = padding + triangleHeight;
    const row2 = padding + trapezoidHeight;

    ctx.beginPath();

    // Line 1: diagonal from (ts, row0) to (1.5*ts, row1)
    ctx.moveTo(ts, row0);
    ctx.lineTo(1.5 * ts, row1);

    // Line 2: horizontal from (1.5*ts, row1) to (2.5*ts, row1)
    ctx.moveTo(1.5 * ts, row1);
    ctx.lineTo(2.5 * ts, row1);

    // Line 3: diagonal from (2.5*ts, row1) to (3*ts, row0)
    ctx.moveTo(2.5 * ts, row1);
    ctx.lineTo(3 * ts, row0);

    // Line 4: diagonal from (ts, row2) to (1.5*ts, row1)
    ctx.moveTo(ts, row2);
    ctx.lineTo(1.5 * ts, row1);

    // Line 5: diagonal from (2.5*ts, row1) to (3*ts, row2)
    ctx.moveTo(2.5 * ts, row1);
    ctx.lineTo(3 * ts, row2);

    ctx.stroke();
  };

  // Mode-based rendering
  if (mode === &#x27;puzzle&#x27;) {
    // Draw only trapezoid outline
    drawOutline();
  } else if (mode === &#x27;guides&#x27;) {
    // Draw all triangles with guide lines + solution cuts + outline on top
    drawTriangles(guideLineWidth);
    drawSolutionGroupings();
    drawOutline();
  } else if (mode === &#x27;solution&#x27;) {
    // Draw solution groupings + outline on top
    drawSolutionGroupings();
    drawOutline();
  }
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Trapezoid triangle structure"></iframe></div></div></details>
<div class="inline-component-definition" style="display:none"></div></div><div class="flex justify-center my-8"><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><div class="my-6"><h2 class="text-lg font-semibold mb-3">Next puzzle in this series</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/equal-shape-cutting-4" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Equal Shape Cutting 4</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">With 1 cut, divide the zigzag shape into 2 equal shapes of itself. The cut does not have to be straight, but has to be a connected line. The shapes can be...</p></div></a></div></div><section class="mt-12"><h2 class="mb-6 text-xl font-bold text-foreground lg:text-2xl">Try These Next</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/planting-trees-2" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Planting Trees II</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">A few weeks after your first job, the mathematics professor calls you back. She was so pleased with your creative solution to the four-tree problem that she...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/unfair-heads-and-tails" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Unfair Heads and Tails</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Player A has n+1 fair coins, while player B has n fair coins. Both players flip all their coins simultaneously and count the number of heads. What is the...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/3-bit-sensors" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-hard text-difficulty-hard-foreground">Hard</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">3-Bit Sensors</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">A remote weather station uses two redundant 3-bit sensors to measure atmospheric pressure. Both sensors transmit their readings to a central processor, but...</p></div></a></div></section></div></main></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":false,"unstable_splitRouteModules":false,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-c98cd44b.js";
import * as route0 from "/assets/root-DXbBOY7W.js";
import * as route1 from "/assets/puzzle-detail-CXwS6aRw.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/puzzle-detail":route1};

import("/assets/entry.client-BQEHofJp.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_71\":-5,\"_72\":-5},\"loaderData\",{\"_3\":4},\"routes/puzzle-detail\",{\"_5\":6,\"_7\":8,\"_9\":10},\"status\",\"success\",\"slug\",\"equal-shape-cutting-3\",\"puzzle\",{\"_7\":8,\"_11\":12,\"_37\":38,\"_39\":40,\"_41\":42,\"_63\":64},\"metadata\",{\"_13\":14,\"_15\":16,\"_17\":18,\"_19\":20,\"_22\":23,\"_25\":26,\"_27\":28,\"_29\":28,\"_30\":31,\"_32\":33,\"_34\":35,\"_36\":35},\"id\",\"puzzle-draft-69\",\"title\",\"Equal Shape Cutting 3\",\"difficulty\",\"easy\",\"concepts\",[21],\"geometry\",\"tags\",[24],\"has-solution\",\"credit\",\"Classic geometry puzzle. Question and solution written by Puzzlestone Peak.\",\"dateCreated\",\"2026-02-02\",\"lastUpdated\",\"previousPuzzle\",\"equal-shape-cutting-2\",\"nextPuzzle\",\"equal-shape-cutting-4\",\"preview\",\"Cut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.\",\"websitePreview\",\"content\",\"\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"0\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eCut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.\u003c/p\u003e\\n\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"1\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eYou can visualize the solution by dividing the trapezoid into triangles:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"2\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\",\"rawContent\",\"\\n:::dynamic\\n```yaml\\ntitle: \\\"Trapezoid\\\"\\nuse: '#trapezoid-diagram'\\nprops:\\n  mode: puzzle\\n```\\n:::\\n\\nCut the trapezoid into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.\\n\\n::::solution\\n\\n:::dynamic\\n```yaml\\ntitle: \\\"Four trapezoid regions highlighted\\\"\\nuse: '#trapezoid-diagram'\\nprops:\\n  mode: solution\\n```\\n:::\\n\\nYou can visualize the solution by dividing the trapezoid into triangles:\\n\\n:::dynamic\\n```yaml\\ntitle: \\\"Trapezoid triangle structure\\\"\\nuse: '#trapezoid-diagram'\\nprops:\\n  mode: guides\\n```\\n:::\\n\\n::::\\n\\n\\n:::component[trapezoid-diagram]\\n```js\\nfunction draw(options) {\\n  const { canvas, api, theme, width, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  const lineWidth = 2;\\n  const guideLineWidth = 0.5;\\n  const solutionLineWidth = 4;\\n  const padding = 20;\\n  const maxSize = 400;\\n  const imageSize = Math.min(width, maxSize);\\n\\n  // Mode: 'puzzle', 'guides', or 'solution'\\n  const mode = props?.mode || 'puzzle';\\n\\n  // Calculate trapezoid dimensions\\n  const triangleSize = imageSize / 4;\\n  const triangleHeight = triangleSize * Math.sqrt(3) / 2;\\n  const trapezoidHeight = 2 * triangleHeight;\\n\\n  canvas.width = imageSize;\\n  canvas.height = trapezoidHeight + 2 * padding;\\n\\n  // Get colors\\n  const foregroundColor = api.getColor('foreground');\\n  const primaryColor = api.getColor('primary');\\n\\n  // Clear canvas\\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\\n\\n  // Helper function to draw all triangles\\n  const drawTriangles = (strokeWidth) =\u003e {\\n    ctx.strokeStyle = foregroundColor;\\n    ctx.lineWidth = strokeWidth;\\n    ctx.lineCap = 'round';\\n    ctx.lineJoin = 'round';\\n\\n    // Top row: 5 triangles starting at triangleSize (offset by 1 triangle width from trapezoid left edge)\\n    // Pattern: upright, inverted, upright, inverted, upright\\n    const topY = padding;\\n\\n    for (let i = 0; i \u003c 5; i++) {\\n      const x = triangleSize + i * (triangleSize / 2);\\n      ctx.beginPath();\\n      if (i % 2 === 0) {\\n        // Upright equilateral triangle\\n        ctx.moveTo(x, topY);\\n        ctx.lineTo(x + triangleSize / 2, topY + triangleHeight);\\n        ctx.lineTo(x - triangleSize / 2, topY + triangleHeight);\\n      } else {\\n        // Inverted equilateral triangle\\n        ctx.moveTo(x - triangleSize / 2, topY);\\n        ctx.lineTo(x + triangleSize / 2, topY);\\n        ctx.lineTo(x, topY + triangleHeight);\\n      }\\n      ctx.closePath();\\n      ctx.stroke();\\n    }\\n\\n    // Bottom row: 7 triangles starting at 0\\n    // Pattern: upright, inverted, upright, inverted, upright, inverted, upright\\n    const bottomY = padding + triangleHeight;\\n\\n    for (let i = 0; i \u003c 7; i++) {\\n      const x = triangleSize / 2 + i * (triangleSize / 2);\\n      ctx.beginPath();\\n      if (i % 2 === 0) {\\n        // Upright equilateral triangle\\n        ctx.moveTo(x, bottomY);\\n        ctx.lineTo(x + triangleSize / 2, bottomY + triangleHeight);\\n        ctx.lineTo(x - triangleSize / 2, bottomY + triangleHeight);\\n      } else {\\n        // Inverted equilateral triangle\\n        ctx.moveTo(x - triangleSize / 2, bottomY);\\n        ctx.lineTo(x + triangleSize / 2, bottomY);\\n        ctx.lineTo(x, bottomY + triangleHeight);\\n      }\\n      ctx.closePath();\\n      ctx.stroke();\\n    }\\n  };\\n\\n  // Helper function to draw trapezoid outline\\n  const drawOutline = () =\u003e {\\n    const topLeft = triangleSize;\\n    const topRight = triangleSize + 2 * triangleSize;\\n    const bottomLeft = 0;\\n    const bottomRight = imageSize;\\n    const topY = padding;\\n    const bottomY = padding + trapezoidHeight;\\n\\n    ctx.beginPath();\\n    ctx.moveTo(topLeft, topY);\\n    ctx.lineTo(topRight, topY);\\n    ctx.lineTo(bottomRight, bottomY);\\n    ctx.lineTo(bottomLeft, bottomY);\\n    ctx.closePath();\\n    ctx.strokeStyle = foregroundColor;\\n    ctx.lineWidth = lineWidth;\\n    ctx.lineCap = 'round';\\n    ctx.lineJoin = 'round';\\n    ctx.stroke();\\n  };\\n\\n  // Helper function to draw solution groupings\\n  const drawSolutionGroupings = () =\u003e {\\n    ctx.strokeStyle = primaryColor;\\n    ctx.lineWidth = solutionLineWidth;\\n    ctx.lineCap = 'butt';\\n    ctx.lineJoin = 'miter';\\n\\n    const ts = triangleSize;\\n    const row0 = padding;\\n    const row1 = padding + triangleHeight;\\n    const row2 = padding + trapezoidHeight;\\n\\n    ctx.beginPath();\\n\\n    // Line 1: diagonal from (ts, row0) to (1.5*ts, row1)\\n    ctx.moveTo(ts, row0);\\n    ctx.lineTo(1.5 * ts, row1);\\n\\n    // Line 2: horizontal from (1.5*ts, row1) to (2.5*ts, row1)\\n    ctx.moveTo(1.5 * ts, row1);\\n    ctx.lineTo(2.5 * ts, row1);\\n\\n    // Line 3: diagonal from (2.5*ts, row1) to (3*ts, row0)\\n    ctx.moveTo(2.5 * ts, row1);\\n    ctx.lineTo(3 * ts, row0);\\n\\n    // Line 4: diagonal from (ts, row2) to (1.5*ts, row1)\\n    ctx.moveTo(ts, row2);\\n    ctx.lineTo(1.5 * ts, row1);\\n\\n    // Line 5: diagonal from (2.5*ts, row1) to (3*ts, row2)\\n    ctx.moveTo(2.5 * ts, row1);\\n    ctx.lineTo(3 * ts, row2);\\n\\n    ctx.stroke();\\n  };\\n\\n  // Mode-based rendering\\n  if (mode === 'puzzle') {\\n    // Draw only trapezoid outline\\n    drawOutline();\\n  } else if (mode === 'guides') {\\n    // Draw all triangles with guide lines + solution cuts + outline on top\\n    drawTriangles(guideLineWidth);\\n    drawSolutionGroupings();\\n    drawOutline();\\n  } else if (mode === 'solution') {\\n    // Draw solution groupings + outline on top\\n    drawSolutionGroupings();\\n    drawOutline();\\n  }\\n}\\n```\\n:::\\n\",\"dynamicBlocks\",[43,55,59],{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":51,\"_15\":52,\"_53\":54},\"type\",\"dynamic\",\"mode\",\"component\",\"componentId\",\"#trapezoid-diagram\",\"props\",{\"_46\":9},\"Trapezoid\",\"sourceFile\",\"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/equal-shape-cutting/equal-shape-cutting-3.md\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":56,\"_15\":58,\"_53\":54},{\"_46\":57},\"solution\",\"Four trapezoid regions highlighted\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":60,\"_15\":62,\"_53\":54},{\"_46\":61},\"guides\",\"Trapezoid triangle structure\",\"inlineComponents\",{\"_65\":66},\"trapezoid-diagram\",{\"_13\":65,\"_67\":68,\"_69\":70},\"code\",\"function draw(options) {\\n  const { canvas, api, theme, width, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  const lineWidth = 2;\\n  const guideLineWidth = 0.5;\\n  const solutionLineWidth = 4;\\n  const padding = 20;\\n  const maxSize = 400;\\n  const imageSize = Math.min(width, maxSize);\\n\\n  // Mode: 'puzzle', 'guides', or 'solution'\\n  const mode = props?.mode || 'puzzle';\\n\\n  // Calculate trapezoid dimensions\\n  const triangleSize = imageSize / 4;\\n  const triangleHeight = triangleSize * Math.sqrt(3) / 2;\\n  const trapezoidHeight = 2 * triangleHeight;\\n\\n  canvas.width = imageSize;\\n  canvas.height = trapezoidHeight + 2 * padding;\\n\\n  // Get colors\\n  const foregroundColor = api.getColor('foreground');\\n  const primaryColor = api.getColor('primary');\\n\\n  // Clear canvas\\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\\n\\n  // Helper function to draw all triangles\\n  const drawTriangles = (strokeWidth) =\u003e {\\n    ctx.strokeStyle = foregroundColor;\\n    ctx.lineWidth = strokeWidth;\\n    ctx.lineCap = 'round';\\n    ctx.lineJoin = 'round';\\n\\n    // Top row: 5 triangles starting at triangleSize (offset by 1 triangle width from trapezoid left edge)\\n    // Pattern: upright, inverted, upright, inverted, upright\\n    const topY = padding;\\n\\n    for (let i = 0; i \u003c 5; i++) {\\n      const x = triangleSize + i * (triangleSize / 2);\\n      ctx.beginPath();\\n      if (i % 2 === 0) {\\n        // Upright equilateral triangle\\n        ctx.moveTo(x, topY);\\n        ctx.lineTo(x + triangleSize / 2, topY + triangleHeight);\\n        ctx.lineTo(x - triangleSize / 2, topY + triangleHeight);\\n      } else {\\n        // Inverted equilateral triangle\\n        ctx.moveTo(x - triangleSize / 2, topY);\\n        ctx.lineTo(x + triangleSize / 2, topY);\\n        ctx.lineTo(x, topY + triangleHeight);\\n      }\\n      ctx.closePath();\\n      ctx.stroke();\\n    }\\n\\n    // Bottom row: 7 triangles starting at 0\\n    // Pattern: upright, inverted, upright, inverted, upright, inverted, upright\\n    const bottomY = padding + triangleHeight;\\n\\n    for (let i = 0; i \u003c 7; i++) {\\n      const x = triangleSize / 2 + i * (triangleSize / 2);\\n      ctx.beginPath();\\n      if (i % 2 === 0) {\\n        // Upright equilateral triangle\\n        ctx.moveTo(x, bottomY);\\n        ctx.lineTo(x + triangleSize / 2, bottomY + triangleHeight);\\n        ctx.lineTo(x - triangleSize / 2, bottomY + triangleHeight);\\n      } else {\\n        // Inverted equilateral triangle\\n        ctx.moveTo(x - triangleSize / 2, bottomY);\\n        ctx.lineTo(x + triangleSize / 2, bottomY);\\n        ctx.lineTo(x, bottomY + triangleHeight);\\n      }\\n      ctx.closePath();\\n      ctx.stroke();\\n    }\\n  };\\n\\n  // Helper function to draw trapezoid outline\\n  const drawOutline = () =\u003e {\\n    const topLeft = triangleSize;\\n    const topRight = triangleSize + 2 * triangleSize;\\n    const bottomLeft = 0;\\n    const bottomRight = imageSize;\\n    const topY = padding;\\n    const bottomY = padding + trapezoidHeight;\\n\\n    ctx.beginPath();\\n    ctx.moveTo(topLeft, topY);\\n    ctx.lineTo(topRight, topY);\\n    ctx.lineTo(bottomRight, bottomY);\\n    ctx.lineTo(bottomLeft, bottomY);\\n    ctx.closePath();\\n    ctx.strokeStyle = foregroundColor;\\n    ctx.lineWidth = lineWidth;\\n    ctx.lineCap = 'round';\\n    ctx.lineJoin = 'round';\\n    ctx.stroke();\\n  };\\n\\n  // Helper function to draw solution groupings\\n  const drawSolutionGroupings = () =\u003e {\\n    ctx.strokeStyle = primaryColor;\\n    ctx.lineWidth = solutionLineWidth;\\n    ctx.lineCap = 'butt';\\n    ctx.lineJoin = 'miter';\\n\\n    const ts = triangleSize;\\n    const row0 = padding;\\n    const row1 = padding + triangleHeight;\\n    const row2 = padding + trapezoidHeight;\\n\\n    ctx.beginPath();\\n\\n    // Line 1: diagonal from (ts, row0) to (1.5*ts, row1)\\n    ctx.moveTo(ts, row0);\\n    ctx.lineTo(1.5 * ts, row1);\\n\\n    // Line 2: horizontal from (1.5*ts, row1) to (2.5*ts, row1)\\n    ctx.moveTo(1.5 * ts, row1);\\n    ctx.lineTo(2.5 * ts, row1);\\n\\n    // Line 3: diagonal from (2.5*ts, row1) to (3*ts, row0)\\n    ctx.moveTo(2.5 * ts, row1);\\n    ctx.lineTo(3 * ts, row0);\\n\\n    // Line 4: diagonal from (ts, row2) to (1.5*ts, row1)\\n    ctx.moveTo(ts, row2);\\n    ctx.lineTo(1.5 * ts, row1);\\n\\n    // Line 5: diagonal from (2.5*ts, row1) to (3*ts, row2)\\n    ctx.moveTo(2.5 * ts, row1);\\n    ctx.lineTo(3 * ts, row2);\\n\\n    ctx.stroke();\\n  };\\n\\n  // Mode-based rendering\\n  if (mode === 'puzzle') {\\n    // Draw only trapezoid outline\\n    drawOutline();\\n  } else if (mode === 'guides') {\\n    // Draw all triangles with guide lines + solution cuts + outline on top\\n    drawTriangles(guideLineWidth);\\n    drawSolutionGroupings();\\n    drawOutline();\\n  } else if (mode === 'solution') {\\n    // Draw solution groupings + outline on top\\n    drawSolutionGroupings();\\n    drawOutline();\\n  }\\n}\",\"startLine\",54,\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>