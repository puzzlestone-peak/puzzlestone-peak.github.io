[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","dice-corner","puzzle",{"_7":8,"_11":12,"_35":36,"_37":38,"_39":40,"_53":54},"metadata",{"_13":14,"_15":16,"_17":18,"_19":20,"_21":22,"_24":25,"_27":28,"_29":28,"_30":31,"_32":33,"_34":33},"id","puzzle-39","title","Dice Corner","questionPreview","You’re looking through a hole at the corner of a die. Can you identify at least one of the visible faces?\n","difficulty","easy","concepts",[23],"logic","tags",[26],"has-solution","dateCreated","2026-02-02","lastUpdated","credit","Puzzle found on Wu Riddles.\nQuestion and solution written by Puzzlestone Peak.\n","preview","You’re looking through a hole at the corner of a standard die. The image below shows all you can see through the hole: portions of three faces meeting at the...","websitePreview","content","<p>You’re looking through a hole at the corner of a standard die. The image below shows all you can see through the hole: portions of three faces meeting at the corner.</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"dom\"><p class=\"text-muted-foreground text-sm\">[Interactive content: dom mode]</p></div>\n<p>Can you identify at least one of the three visible faces?</p>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">A property about dice</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>On a standard die, opposite faces sum to 7. At any corner, the three visible faces include one from each opposite pair: (1, 6), (2, 5), and (3, 4).</p></div></details>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><strong>6.</strong></p><p>On a standard die, opposite faces sum to 7: the pairs are (1, 6), (2, 5), and (3, 4). At any corner, the three visible faces include exactly one face from each pair.</p><p>The 1 has a single pip in the centre of the face — far from any corner. If the 1 were visible, its corner would show no pips through the hole. But all three corners show a pip.</p><p>Since the (1, 6) pair must contribute one face, and it can’t be the 1, the visible face must be the <strong>6</strong>.</p></div></details>","rawContent","\nYou’re looking through a hole at the corner of a standard die. The image below shows all you can see through the hole: portions of three faces meeting at the corner.\n\n:::dynamic\n```yaml\ntitle: Die corner view\nariaLabel: Looking through a circular hole at the corner of a die, showing portions of three faces each with one pip visible\n```\n\n```js\nfunction draw(options) {\n  const { canvas, api, width: containerWidth } = options;\n  const ctx = canvas.getContext('2d');\n\n  // === ADJUSTABLE CONSTANTS ===\n  const MAX_SIZE = 280;           // max canvas size in px\n  const HOLE_RATIO = 0.40;        // hole radius as fraction of canvas size\n  const DIE_RATIO = 0.55;         // die edge length as fraction of canvas size (larger = more clipped)\n  const PIP_DISTANCE = 0.45;      // how far pips sit from the corner (0 = at corner, 0.5 = face centre)\n  const PIP_SIZE = 0.2;          // pip radius in face-coordinate units (1.0 = full face edge)\n  // ============================\n\n  const size = Math.min(containerWidth, MAX_SIZE);\n  canvas.width = size;\n  canvas.height = size;\n\n  // Die colours from palette\n  const dieWhite = api.getColor('white');\n  const dieDark = api.getColor('navy-950');\n\n  const cx = size / 2;\n  const cy = size / 2;\n  const holeRadius = size * HOLE_RATIO;\n  const s = size * DIE_RATIO;\n  const cos30 = Math.cos(Math.PI / 6);\n\n  // Frame surround (slightly lighter in dark mode for contrast with background)\n  ctx.fillStyle = api.theme === 'dark'\n    ? api.getColor('navy-950', { lightness: 0.05 })\n    : dieDark;\n  ctx.fillRect(0, 0, size, size);\n\n  // Clip to circular hole\n  ctx.save();\n  ctx.beginPath();\n  ctx.arc(cx, cy, holeRadius, 0, Math.PI * 2);\n  ctx.clip();\n\n  // Fill hole with die white\n  ctx.fillStyle = dieWhite;\n  ctx.fillRect(0, 0, size, size);\n\n  // Isometric die corner vertices (larger than hole so faces extend beyond)\n  const V = { x: cx, y: cy };\n  const A = { x: cx, y: cy - s };\n  const D = { x: cx - s * cos30, y: cy - s * 0.5 };\n  const E = { x: cx + s * cos30, y: cy - s * 0.5 };\n  const B = { x: cx - s * cos30, y: cy + s * 0.5 };\n  const C = { x: cx + s * cos30, y: cy + s * 0.5 };\n  const F = { x: cx, y: cy + s };\n\n  // Face shading — progressively darker via lightness adjustments\n  const topFace = api.getColor('white', { lightness: -0.03 });\n  const leftFace = api.getColor('white', { lightness: -0.10 });\n  const rightFace = api.getColor('white', { lightness: -0.18 });\n\n  const drawFace = (pts, color) => {\n    ctx.beginPath();\n    ctx.moveTo(pts[0].x, pts[0].y);\n    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n  };\n\n  // Three faces: top, left, right\n  drawFace([D, A, E, V], topFace);\n  drawFace([D, V, F, B], leftFace);\n  drawFace([V, E, C, F], rightFace);\n\n  // Draw pips using face-coordinate transforms\n  // Each pip is a circle in face-space that becomes a perspective-correct ellipse\n  const setFaceTransform = (p0, p1, p3) => {\n    ctx.setTransform(\n      p1.x - p0.x, p1.y - p0.y,\n      p3.x - p0.x, p3.y - p0.y,\n      p0.x, p0.y\n    );\n  };\n\n  const pipR = PIP_SIZE;\n\n  const near = PIP_DISTANCE;        // shorthand: near the corner\n  const far = 1 - PIP_DISTANCE;     // shorthand: far from the corner\n\n  // Top face (p0=D, u-axis=A, v-axis=V): V is at (0,1), pip near corner\n  ctx.save();\n  setFaceTransform(D, A, V);\n  ctx.fillStyle = dieDark;\n  ctx.beginPath();\n  ctx.arc(near, far, pipR, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.restore();\n\n  // Left face (p0=D, u-axis=V, v-axis=B): V is at (1,0), pip near corner\n  ctx.save();\n  setFaceTransform(D, V, B);\n  ctx.fillStyle = dieDark;\n  ctx.beginPath();\n  ctx.arc(far, near, pipR, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.restore();\n\n  // Right face (p0=V, u-axis=E, v-axis=F): V is at (0,0), pip near corner\n  ctx.save();\n  setFaceTransform(V, E, F);\n  ctx.fillStyle = dieDark;\n  ctx.beginPath();\n  ctx.arc(near, near, pipR, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.restore();\n\n  // Draw edges (reset transform first)\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.strokeStyle = dieDark;\n  ctx.lineWidth = 1.5;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  // Outer hexagon\n  ctx.beginPath();\n  ctx.moveTo(D.x, D.y);\n  ctx.lineTo(A.x, A.y);\n  ctx.lineTo(E.x, E.y);\n  ctx.lineTo(C.x, C.y);\n  ctx.lineTo(F.x, F.y);\n  ctx.lineTo(B.x, B.y);\n  ctx.closePath();\n  ctx.stroke();\n\n  // Inner edges from vertex V\n  ctx.beginPath();\n  ctx.moveTo(V.x, V.y); ctx.lineTo(D.x, D.y);\n  ctx.moveTo(V.x, V.y); ctx.lineTo(E.x, E.y);\n  ctx.moveTo(V.x, V.y); ctx.lineTo(F.x, F.y);\n  ctx.stroke();\n\n  ctx.restore();\n}\n```\n:::\n\nCan you identify at least one of the three visible faces?\n\n:::hint[A property about dice]\nOn a standard die, opposite faces sum to 7. At any corner, the three visible faces include one from each opposite pair: (1, 6), (2, 5), and (3, 4).\n:::\n\n:::solution\n**6.**\n\nOn a standard die, opposite faces sum to 7: the pairs are (1, 6), (2, 5), and (3, 4). At any corner, the three visible faces include exactly one face from each pair.\n\nThe 1 has a single pip in the centre of the face — far from any corner. If the 1 were visible, its corner would show no pips through the hole. But all three corners show a pip.\n\nSince the (1, 6) pair must contribute one face, and it can’t be the 1, the visible face must be the **6**.\n:::\n","dynamicBlocks",[41],{"_42":43,"_44":45,"_46":47,"_15":48,"_49":50,"_51":52},"type","dynamic","mode","dom","code","function draw(options) {\n  const { canvas, api, width: containerWidth } = options;\n  const ctx = canvas.getContext('2d');\n\n  // === ADJUSTABLE CONSTANTS ===\n  const MAX_SIZE = 280;           // max canvas size in px\n  const HOLE_RATIO = 0.40;        // hole radius as fraction of canvas size\n  const DIE_RATIO = 0.55;         // die edge length as fraction of canvas size (larger = more clipped)\n  const PIP_DISTANCE = 0.45;      // how far pips sit from the corner (0 = at corner, 0.5 = face centre)\n  const PIP_SIZE = 0.2;          // pip radius in face-coordinate units (1.0 = full face edge)\n  // ============================\n\n  const size = Math.min(containerWidth, MAX_SIZE);\n  canvas.width = size;\n  canvas.height = size;\n\n  // Die colours from palette\n  const dieWhite = api.getColor('white');\n  const dieDark = api.getColor('navy-950');\n\n  const cx = size / 2;\n  const cy = size / 2;\n  const holeRadius = size * HOLE_RATIO;\n  const s = size * DIE_RATIO;\n  const cos30 = Math.cos(Math.PI / 6);\n\n  // Frame surround (slightly lighter in dark mode for contrast with background)\n  ctx.fillStyle = api.theme === 'dark'\n    ? api.getColor('navy-950', { lightness: 0.05 })\n    : dieDark;\n  ctx.fillRect(0, 0, size, size);\n\n  // Clip to circular hole\n  ctx.save();\n  ctx.beginPath();\n  ctx.arc(cx, cy, holeRadius, 0, Math.PI * 2);\n  ctx.clip();\n\n  // Fill hole with die white\n  ctx.fillStyle = dieWhite;\n  ctx.fillRect(0, 0, size, size);\n\n  // Isometric die corner vertices (larger than hole so faces extend beyond)\n  const V = { x: cx, y: cy };\n  const A = { x: cx, y: cy - s };\n  const D = { x: cx - s * cos30, y: cy - s * 0.5 };\n  const E = { x: cx + s * cos30, y: cy - s * 0.5 };\n  const B = { x: cx - s * cos30, y: cy + s * 0.5 };\n  const C = { x: cx + s * cos30, y: cy + s * 0.5 };\n  const F = { x: cx, y: cy + s };\n\n  // Face shading — progressively darker via lightness adjustments\n  const topFace = api.getColor('white', { lightness: -0.03 });\n  const leftFace = api.getColor('white', { lightness: -0.10 });\n  const rightFace = api.getColor('white', { lightness: -0.18 });\n\n  const drawFace = (pts, color) => {\n    ctx.beginPath();\n    ctx.moveTo(pts[0].x, pts[0].y);\n    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n  };\n\n  // Three faces: top, left, right\n  drawFace([D, A, E, V], topFace);\n  drawFace([D, V, F, B], leftFace);\n  drawFace([V, E, C, F], rightFace);\n\n  // Draw pips using face-coordinate transforms\n  // Each pip is a circle in face-space that becomes a perspective-correct ellipse\n  const setFaceTransform = (p0, p1, p3) => {\n    ctx.setTransform(\n      p1.x - p0.x, p1.y - p0.y,\n      p3.x - p0.x, p3.y - p0.y,\n      p0.x, p0.y\n    );\n  };\n\n  const pipR = PIP_SIZE;\n\n  const near = PIP_DISTANCE;        // shorthand: near the corner\n  const far = 1 - PIP_DISTANCE;     // shorthand: far from the corner\n\n  // Top face (p0=D, u-axis=A, v-axis=V): V is at (0,1), pip near corner\n  ctx.save();\n  setFaceTransform(D, A, V);\n  ctx.fillStyle = dieDark;\n  ctx.beginPath();\n  ctx.arc(near, far, pipR, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.restore();\n\n  // Left face (p0=D, u-axis=V, v-axis=B): V is at (1,0), pip near corner\n  ctx.save();\n  setFaceTransform(D, V, B);\n  ctx.fillStyle = dieDark;\n  ctx.beginPath();\n  ctx.arc(far, near, pipR, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.restore();\n\n  // Right face (p0=V, u-axis=E, v-axis=F): V is at (0,0), pip near corner\n  ctx.save();\n  setFaceTransform(V, E, F);\n  ctx.fillStyle = dieDark;\n  ctx.beginPath();\n  ctx.arc(near, near, pipR, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.restore();\n\n  // Draw edges (reset transform first)\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.strokeStyle = dieDark;\n  ctx.lineWidth = 1.5;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  // Outer hexagon\n  ctx.beginPath();\n  ctx.moveTo(D.x, D.y);\n  ctx.lineTo(A.x, A.y);\n  ctx.lineTo(E.x, E.y);\n  ctx.lineTo(C.x, C.y);\n  ctx.lineTo(F.x, F.y);\n  ctx.lineTo(B.x, B.y);\n  ctx.closePath();\n  ctx.stroke();\n\n  // Inner edges from vertex V\n  ctx.beginPath();\n  ctx.moveTo(V.x, V.y); ctx.lineTo(D.x, D.y);\n  ctx.moveTo(V.x, V.y); ctx.lineTo(E.x, E.y);\n  ctx.moveTo(V.x, V.y); ctx.lineTo(F.x, F.y);\n  ctx.stroke();\n\n  ctx.restore();\n}","Die corner view","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/logic/dice-corner.md","startLine",25,"inlineComponents",{}]
