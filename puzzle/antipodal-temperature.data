[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","antipodal-temperature","puzzle",{"_7":8,"_11":12,"_38":39,"_40":41,"_42":43,"_124":125},"metadata",{"_13":14,"_15":16,"_17":18,"_19":22,"_24":25,"_27":28,"_29":30,"_31":32,"_33":34,"_35":36,"_37":36},"id","puzzle-54","title","Antipodal Temperature","difficulty",{"_19":20,"_21":20},"concepts","medium","reasoning",[23],"logic","tags",[26],"has-solution","nextPuzzle","antipodal-temperature-and-pressure","credit","Classic puzzle. Question and solution written by Puzzlestone Peak.","dateCreated","2026-02-03","lastUpdated","2026-02-04","preview","Assume the Earth is a perfect sphere. Show that at any given time, there exist two antipodal points (points on exact opposite sides of the Earth) with the same...","websitePreview","content","<p>Assume the Earth is a perfect sphere. Show that at any given time, there exist two antipodal points (points on exact opposite sides of the Earth) with the same temperature.</p>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>You may assume that the temperature is smooth: there are no sudden \"jumps\" in temperature as you walk from one place to another.</p></div></details>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Let’s say you start at point A and walk along a great circle around the Earth. What happens to the temperature at where you are and the temperature at the point directly opposite to you?</p></div></details>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><strong>Answer</strong>: At any given time, there exist two antipodal points with the same temperature.</p><p>Let’s pick any great circle around the Earth, for example, the equator. Choose a starting point A on this circle, and let B be the point directly opposite to A (the antipodal point).</p><p><strong>Case 1</strong>: If point A and B have the same temperature, we're done! But more likely than not, they'll have different temperatures, in which case we consider case 2.</p><p><strong>Case 2</strong>: Point A and B have different temperatures.</p><p>Let's start from point A and walk around the equator. At the same time, we'll have a friend start from point B and walk around the equator in the same direction, always keeping on the opposite side of us. As we do so, each of us carry a thermometer to measure the temperature.</p><p>Eventually, we'll reach point B, and our friend would've reached point A.</p><p><strong>Case 2A</strong>: Point A's temperature is lower than point B's temperature. We started with a lower temperature than our friend, but now we have a higher temperature than our friend. Then at some point, our temperatures would have to “cross” each other.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>We can even cross multiple times:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Or even cross outside our original temperature range:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Notice that since we're always on the opposite side of each other at all times, the crossing point indicates a pair antipodal points with the same temperature.</p><p><strong>Case 2B</strong>: Point A's temperature is higher than point B's temperature. We can use the same argument as case 2B to prove that there's a pair of antipodal points with the same temperature.</p><p>Across case 1, 2A, and 2B, we can always find a pair of antipodal points that have the same temperature. And that's our solution!</p><div class=\"content-block note-block note-note\" data-type=\"note\" data-note-type=\"note\"><div class=\"note-header note-note-header\">Intermediate Value Theorem</div><div class=\"note-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>This solution relies on the principle that continuous changes must pass through all intermediate values. If you start with A warmer than B and end with B warmer than A, you must pass through a moment where they’re equal.</p></div></div></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nAssume the Earth is a perfect sphere. Show that at any given time, there exist two antipodal points (points on exact opposite sides of the Earth) with the same temperature.\n\n:::hint\nYou may assume that the temperature is smooth: there are no sudden \"jumps\" in temperature as you walk from one place to another.\n:::\n\n:::hint\nLet’s say you start at point A and walk along a great circle around the Earth. What happens to the temperature at where you are and the temperature at the point directly opposite to you?\n:::\n\n::::solution\n**Answer**: At any given time, there exist two antipodal points with the same temperature.\n\nLet’s pick any great circle around the Earth, for example, the equator. Choose a starting point A on this circle, and let B be the point directly opposite to A (the antipodal point).\n\n**Case 1**: If point A and B have the same temperature, we're done! But more likely than not, they'll have different temperatures, in which case we consider case 2.\n\n**Case 2**: Point A and B have different temperatures.\n\nLet's start from point A and walk around the equator. At the same time, we'll have a friend start from point B and walk around the equator in the same direction, always keeping on the opposite side of us. As we do so, each of us carry a thermometer to measure the temperature.\n\nEventually, we'll reach point B, and our friend would've reached point A.\n\n**Case 2A**: Point A's temperature is lower than point B's temperature. We started with a lower temperature than our friend, but now we have a higher temperature than our friend. Then at some point, our temperatures would have to “cross” each other.\n\n:::dynamic\n```yaml\ntitle: \"Temperature chart showing two paths crossing\"\nuse: '#ivt-chart'\nprops:\n  seed: 42\n  noiseAmount: 0.2\n  youPoints: [[0, 25], [20, 15], [50, 50], [80, 85], [100, 75]]\n  friendPoints: [[0, 75], [20, 85], [50, 50], [80, 15], [100, 25]]\n```\n:::\n\nWe can even cross multiple times:\n\n:::dynamic\n```yaml\ntitle: \"Temperature chart showing multiple crossings\"\nuse: '#ivt-chart'\nprops:\n  seed: 17\n  noiseAmount: 0.4\n  youPoints: [[0, 25], [25, 60], [50, 35], [75, 70], [100, 75]]\n  friendPoints: [[0, 75], [25, 40], [50, 65], [75, 45], [100, 25]]\n```\n:::\n\nOr even cross outside our original temperature range:\n\n:::dynamic\n```yaml\ntitle: \"Temperature chart with crossing at extreme position\"\nuse: '#ivt-chart'\nprops:\n  seed: 35\n  noiseAmount: 0.3\n  youPoints: [[0, 25], [10, 70], [20, 90], [40, 60], [100, 75]]\n  friendPoints: [[0, 75], [10, 85], [20, 50], [40, 15], [100, 25]]\n```\n:::\n\nNotice that since we're always on the opposite side of each other at all times, the crossing point indicates a pair antipodal points with the same temperature.\n\n**Case 2B**: Point A's temperature is higher than point B's temperature. We can use the same argument as case 2B to prove that there's a pair of antipodal points with the same temperature.\n\nAcross case 1, 2A, and 2B, we can always find a pair of antipodal points that have the same temperature. And that's our solution!\n\n:::note[Intermediate Value Theorem]\nThis solution relies on the principle that continuous changes must pass through all intermediate values. If you start with A warmer than B and end with B warmer than A, you must pass through a moment where they’re equal.\n:::\n::::\n\n\n:::component[ivt-chart]\n```js\n// Simple 1D Perlin noise implementation\nclass PerlinNoise {\n  constructor(seed = 0) {\n    this.p = [];\n    for (let i = 0; i < 256; i++) {\n      this.p[i] = i;\n    }\n\n    // Shuffle using seed\n    for (let i = 255; i > 0; i--) {\n      const j = Math.floor(this.seededRandom(seed + i) * (i + 1));\n      [this.p[i], this.p[j]] = [this.p[j], this.p[i]];\n    }\n\n    // Duplicate for overflow\n    this.p = this.p.concat(this.p);\n  }\n\n  seededRandom(seed) {\n    const x = Math.sin(seed) * 10000;\n    return x - Math.floor(x);\n  }\n\n  fade(t) {\n    return t * t * t * (t * (t * 6 - 15) + 10);\n  }\n\n  lerp(t, a, b) {\n    return a + t * (b - a);\n  }\n\n  grad(hash, x) {\n    return (hash & 1) === 0 ? x : -x;\n  }\n\n  noise(x) {\n    const X = Math.floor(x) & 255;\n    x -= Math.floor(x);\n    const u = this.fade(x);\n    return this.lerp(u, this.grad(this.p[X], x), this.grad(this.p[X + 1], x - 1));\n  }\n}\n\nfunction draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  // Props with defaults\n  // youPoints and friendPoints are arrays of [x, y] where x is 0-100 (%) and y is 0-100 (%)\n  // Example: [[0, 25], [30, 15], [50, 50], [70, 85], [100, 75]]\n  const seed = props?.seed ?? 42;\n  const youPoints = props?.youPoints ?? [[0, 25], [50, 50], [100, 75]];\n  const friendPoints = props?.friendPoints ?? [[0, 75], [50, 50], [100, 25]];\n  const noiseAmount = props?.noiseAmount ?? 0.15;\n\n  // Convert percentage points to 0-1 scale\n  const youCheckpoints = youPoints.map(([x, y]) => ({ x: x / 100, y: y / 100 }));\n  const friendCheckpoints = friendPoints.map(([x, y]) => ({ x: x / 100, y: y / 100 }));\n\n  // Canvas dimensions (capped at 600px width)\n  const maxWidth = 600;\n  const actualWidth = Math.min(width, maxWidth);\n  const aspectRatio = 0.5;\n  const height = actualWidth * aspectRatio;\n  canvas.width = actualWidth;\n  canvas.height = height;\n\n  // Layout\n  const padding = { top: 55, right: 30, bottom: 50, left: 60 };\n  const chartWidth = actualWidth - padding.left - padding.right;\n  const chartHeight = height - padding.top - padding.bottom;\n\n  // Temperature levels for dotted lines (A = low temp line, B = high temp line)\n  const tempA = 0.25;\n  const tempB = 0.75;\n\n  // Clear canvas\n  ctx.clearRect(0, 0, actualWidth, height);\n\n  // Get colors\n  const foreground = api.getColor('foreground');\n  const muted = api.getColor('muted-foreground');\n  const gridColor = api.getColor('border');\n  const redPath = api.getColor('error-600');\n  const bluePath = api.getColor('navy-600');\n\n  // Helper to convert temperature (0-1) to Y coordinate\n  const tempToY = (temp) => {\n    return padding.top + chartHeight * (1 - temp);\n  };\n\n  // Helper to convert X position (0-1) to canvas X\n  const xToCanvas = (x) => {\n    return padding.left + chartWidth * x;\n  };\n\n  // Draw axes\n  ctx.strokeStyle = foreground;\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(padding.left, padding.top);\n  ctx.lineTo(padding.left, padding.top + chartHeight);\n  ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);\n  ctx.stroke();\n\n  // Draw arrowheads\n  const arrowSize = 8;\n  ctx.fillStyle = foreground;\n\n  // Y-axis arrowhead (pointing up)\n  ctx.beginPath();\n  ctx.moveTo(padding.left, padding.top);\n  ctx.lineTo(padding.left - arrowSize / 2, padding.top + arrowSize);\n  ctx.lineTo(padding.left + arrowSize / 2, padding.top + arrowSize);\n  ctx.closePath();\n  ctx.fill();\n\n  // X-axis arrowhead (pointing right)\n  ctx.beginPath();\n  ctx.moveTo(padding.left + chartWidth, padding.top + chartHeight);\n  ctx.lineTo(padding.left + chartWidth - arrowSize, padding.top + chartHeight - arrowSize / 2);\n  ctx.lineTo(padding.left + chartWidth - arrowSize, padding.top + chartHeight + arrowSize / 2);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw dotted horizontal lines for temp A and B\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 1;\n  ctx.setLineDash([5, 5]);\n\n  ctx.beginPath();\n  ctx.moveTo(padding.left, tempToY(tempA));\n  ctx.lineTo(padding.left + chartWidth, tempToY(tempA));\n  ctx.stroke();\n\n  ctx.beginPath();\n  ctx.moveTo(padding.left, tempToY(tempB));\n  ctx.lineTo(padding.left + chartWidth, tempToY(tempB));\n  ctx.stroke();\n\n  ctx.setLineDash([]);\n\n  // Labels for temperature levels\n  ctx.fillStyle = muted;\n  ctx.font = '14px ' + api.getFont('default');\n  ctx.textAlign = 'right';\n  ctx.textBaseline = 'middle';\n\n  const labelA = 'A';\n  const labelB = 'B';\n\n  ctx.fillText(labelA, padding.left - 10, tempToY(tempA));\n  ctx.fillText(labelB, padding.left - 10, tempToY(tempB));\n\n  // Axis labels\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  ctx.fillStyle = foreground;\n  ctx.font = '16px ' + api.getFont('default');\n  ctx.fillText('Distance around circle', padding.left + chartWidth / 2, padding.top + chartHeight + 15);\n\n  ctx.save();\n  ctx.translate(20, padding.top + chartHeight / 2);\n  ctx.rotate(-Math.PI / 2);\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  ctx.fillText('Temperature', 0, 0);\n  ctx.restore();\n\n  // Axis tick labels\n  ctx.fillStyle = muted;\n  ctx.font = '13px ' + api.getFont('default');\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  ctx.fillText('Start', padding.left + 20, padding.top + chartHeight + 5);\n  ctx.fillText('End', padding.left + chartWidth - 20, padding.top + chartHeight + 5);\n\n  // Generate paths using provided checkpoints + seeded noise\n  const perlin = new PerlinNoise(seed);\n  const perlin2 = new PerlinNoise(seed + 100);\n  const numPoints = 200;\n\n  // Cubic Hermite interpolation for smooth curves through checkpoints\n  function hermiteInterpolate(p0, p1, p2, p3, t) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n\n    // Catmull-Rom spline coefficients\n    const h1 = 2*t3 - 3*t2 + 1;\n    const h2 = -2*t3 + 3*t2;\n    const h3 = t3 - 2*t2 + t;\n    const h4 = t3 - t2;\n\n    // Tangents (Catmull-Rom style)\n    const tension = 0.5;\n    const m0 = tension * (p2 - p0);\n    const m1 = tension * (p3 - p1);\n\n    return h1*p1 + h2*p2 + h3*m0 + h4*m1;\n  }\n\n  // Generate smooth path through given checkpoints with seeded noise\n  function generatePathFromCheckpoints(checkpoints, perlinInst, seedOffset) {\n    const path = [];\n\n    for (let i = 0; i <= numPoints; i++) {\n      const x = i / numPoints;\n\n      // Find which segment we're in\n      let segIdx = 0;\n      for (let j = 0; j < checkpoints.length - 1; j++) {\n        if (x >= checkpoints[j].x && x <= checkpoints[j + 1].x) {\n          segIdx = j;\n          break;\n        }\n      }\n\n      // Get 4 points for Hermite interpolation\n      const p0 = checkpoints[Math.max(0, segIdx - 1)].y;\n      const p1 = checkpoints[segIdx].y;\n      const p2 = checkpoints[Math.min(checkpoints.length - 1, segIdx + 1)].y;\n      const p3 = checkpoints[Math.min(checkpoints.length - 1, segIdx + 2)].y;\n\n      // Local t within segment\n      const segStart = checkpoints[segIdx].x;\n      const segEnd = checkpoints[segIdx + 1].x;\n      const t = (x - segStart) / (segEnd - segStart);\n\n      // Interpolated base temperature\n      let baseTemp = hermiteInterpolate(p0, p1, p2, p3, t);\n\n      // Add noise tapered at endpoints (so start/end are exact)\n      const endTaper = Math.pow(4 * x * (1 - x), 0.5);\n      const noise = perlinInst.noise(x * 8 + seedOffset) * noiseAmount * endTaper;\n\n      const temp = baseTemp + noise;\n\n      path.push({ x, temp });\n    }\n\n    // Force exact endpoints\n    path[0].temp = checkpoints[0].y;\n    path[numPoints].temp = checkpoints[checkpoints.length - 1].y;\n\n    return path;\n  }\n\n  // Generate paths from provided checkpoints\n  const youPath = generatePathFromCheckpoints(youCheckpoints, perlin, 0);\n  const friendPath = generatePathFromCheckpoints(friendCheckpoints, perlin2, 50);\n\n  // Draw \"You\" path (red)\n  ctx.strokeStyle = redPath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  for (let i = 0; i < youPath.length; i++) {\n    const point = youPath[i];\n    const canvasX = xToCanvas(point.x);\n    const canvasY = tempToY(point.temp);\n    if (i === 0) {\n      ctx.moveTo(canvasX, canvasY);\n    } else {\n      ctx.lineTo(canvasX, canvasY);\n    }\n  }\n  ctx.stroke();\n\n  // Draw \"Friend\" path (blue)\n  ctx.strokeStyle = bluePath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  for (let i = 0; i < friendPath.length; i++) {\n    const point = friendPath[i];\n    const canvasX = xToCanvas(point.x);\n    const canvasY = tempToY(point.temp);\n    if (i === 0) {\n      ctx.moveTo(canvasX, canvasY);\n    } else {\n      ctx.lineTo(canvasX, canvasY);\n    }\n  }\n  ctx.stroke();\n\n  // Legend\n  const legendX = padding.left + chartWidth - 100;\n  const legendY = 15;\n\n  ctx.strokeStyle = redPath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(legendX, legendY);\n  ctx.lineTo(legendX + 30, legendY);\n  ctx.stroke();\n\n  ctx.fillStyle = foreground;\n  ctx.font = '14px ' + api.getFont('default');\n  ctx.textAlign = 'left';\n  ctx.textBaseline = 'middle';\n  ctx.fillText('You', legendX + 35, legendY);\n\n  ctx.strokeStyle = bluePath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(legendX, legendY + 20);\n  ctx.lineTo(legendX + 30, legendY + 20);\n  ctx.stroke();\n\n  ctx.fillText('Friend', legendX + 35, legendY + 20);\n}\n```\n\n```yaml\nmode: canvas\ntitle: \"Interactive temperature comparison chart\"\nariaLabel: \"Line chart showing two temperature paths crossing, demonstrating the Intermediate Value Theorem. Red path (You) starts low and ends high. Blue path (Friend) starts high and ends low. The paths cross in the middle.\"\n```\n:::\n","dynamicBlocks",[44,83,106],{"_45":46,"_47":48,"_49":50,"_51":52,"_15":80,"_81":82},"type","dynamic","mode","component","componentId","#ivt-chart","props",{"_53":54,"_55":56,"_57":58,"_73":74},"seed",42,"noiseAmount",0.2,"youPoints",[59,62,65,67,70],[60,61],0,25,[63,64],20,15,[66,66],50,[68,69],80,85,[71,72],100,75,"friendPoints",[75,76,77,78,79],[60,72],[63,69],[66,66],[68,64],[71,61],"Temperature chart showing two paths crossing","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/misc/antipodal-temperature.md",{"_45":46,"_47":48,"_49":50,"_51":84,"_15":105,"_81":82},{"_53":85,"_55":86,"_57":87,"_73":96},17,0.4,[88,89,91,93,95],[60,61],[61,90],60,[66,92],35,[72,94],70,[71,72],[97,98,100,102,104],[60,72],[61,99],40,[66,101],65,[72,103],45,[71,61],"Temperature chart showing multiple crossings",{"_45":46,"_47":48,"_49":50,"_51":107,"_15":123,"_81":82},{"_53":92,"_55":108,"_57":109,"_73":117},0.3,[110,111,113,115,116],[60,61],[112,94],10,[63,114],90,[99,90],[71,72],[118,119,120,121,122],[60,72],[112,69],[63,66],[99,64],[71,61],"Temperature chart with crossing at extreme position","inlineComponents",{"_126":127},"ivt-chart",{"_13":126,"_128":129,"_130":131},"code","// Simple 1D Perlin noise implementation\nclass PerlinNoise {\n  constructor(seed = 0) {\n    this.p = [];\n    for (let i = 0; i < 256; i++) {\n      this.p[i] = i;\n    }\n\n    // Shuffle using seed\n    for (let i = 255; i > 0; i--) {\n      const j = Math.floor(this.seededRandom(seed + i) * (i + 1));\n      [this.p[i], this.p[j]] = [this.p[j], this.p[i]];\n    }\n\n    // Duplicate for overflow\n    this.p = this.p.concat(this.p);\n  }\n\n  seededRandom(seed) {\n    const x = Math.sin(seed) * 10000;\n    return x - Math.floor(x);\n  }\n\n  fade(t) {\n    return t * t * t * (t * (t * 6 - 15) + 10);\n  }\n\n  lerp(t, a, b) {\n    return a + t * (b - a);\n  }\n\n  grad(hash, x) {\n    return (hash & 1) === 0 ? x : -x;\n  }\n\n  noise(x) {\n    const X = Math.floor(x) & 255;\n    x -= Math.floor(x);\n    const u = this.fade(x);\n    return this.lerp(u, this.grad(this.p[X], x), this.grad(this.p[X + 1], x - 1));\n  }\n}\n\nfunction draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  // Props with defaults\n  // youPoints and friendPoints are arrays of [x, y] where x is 0-100 (%) and y is 0-100 (%)\n  // Example: [[0, 25], [30, 15], [50, 50], [70, 85], [100, 75]]\n  const seed = props?.seed ?? 42;\n  const youPoints = props?.youPoints ?? [[0, 25], [50, 50], [100, 75]];\n  const friendPoints = props?.friendPoints ?? [[0, 75], [50, 50], [100, 25]];\n  const noiseAmount = props?.noiseAmount ?? 0.15;\n\n  // Convert percentage points to 0-1 scale\n  const youCheckpoints = youPoints.map(([x, y]) => ({ x: x / 100, y: y / 100 }));\n  const friendCheckpoints = friendPoints.map(([x, y]) => ({ x: x / 100, y: y / 100 }));\n\n  // Canvas dimensions (capped at 600px width)\n  const maxWidth = 600;\n  const actualWidth = Math.min(width, maxWidth);\n  const aspectRatio = 0.5;\n  const height = actualWidth * aspectRatio;\n  canvas.width = actualWidth;\n  canvas.height = height;\n\n  // Layout\n  const padding = { top: 55, right: 30, bottom: 50, left: 60 };\n  const chartWidth = actualWidth - padding.left - padding.right;\n  const chartHeight = height - padding.top - padding.bottom;\n\n  // Temperature levels for dotted lines (A = low temp line, B = high temp line)\n  const tempA = 0.25;\n  const tempB = 0.75;\n\n  // Clear canvas\n  ctx.clearRect(0, 0, actualWidth, height);\n\n  // Get colors\n  const foreground = api.getColor('foreground');\n  const muted = api.getColor('muted-foreground');\n  const gridColor = api.getColor('border');\n  const redPath = api.getColor('error-600');\n  const bluePath = api.getColor('navy-600');\n\n  // Helper to convert temperature (0-1) to Y coordinate\n  const tempToY = (temp) => {\n    return padding.top + chartHeight * (1 - temp);\n  };\n\n  // Helper to convert X position (0-1) to canvas X\n  const xToCanvas = (x) => {\n    return padding.left + chartWidth * x;\n  };\n\n  // Draw axes\n  ctx.strokeStyle = foreground;\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  ctx.moveTo(padding.left, padding.top);\n  ctx.lineTo(padding.left, padding.top + chartHeight);\n  ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);\n  ctx.stroke();\n\n  // Draw arrowheads\n  const arrowSize = 8;\n  ctx.fillStyle = foreground;\n\n  // Y-axis arrowhead (pointing up)\n  ctx.beginPath();\n  ctx.moveTo(padding.left, padding.top);\n  ctx.lineTo(padding.left - arrowSize / 2, padding.top + arrowSize);\n  ctx.lineTo(padding.left + arrowSize / 2, padding.top + arrowSize);\n  ctx.closePath();\n  ctx.fill();\n\n  // X-axis arrowhead (pointing right)\n  ctx.beginPath();\n  ctx.moveTo(padding.left + chartWidth, padding.top + chartHeight);\n  ctx.lineTo(padding.left + chartWidth - arrowSize, padding.top + chartHeight - arrowSize / 2);\n  ctx.lineTo(padding.left + chartWidth - arrowSize, padding.top + chartHeight + arrowSize / 2);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw dotted horizontal lines for temp A and B\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 1;\n  ctx.setLineDash([5, 5]);\n\n  ctx.beginPath();\n  ctx.moveTo(padding.left, tempToY(tempA));\n  ctx.lineTo(padding.left + chartWidth, tempToY(tempA));\n  ctx.stroke();\n\n  ctx.beginPath();\n  ctx.moveTo(padding.left, tempToY(tempB));\n  ctx.lineTo(padding.left + chartWidth, tempToY(tempB));\n  ctx.stroke();\n\n  ctx.setLineDash([]);\n\n  // Labels for temperature levels\n  ctx.fillStyle = muted;\n  ctx.font = '14px ' + api.getFont('default');\n  ctx.textAlign = 'right';\n  ctx.textBaseline = 'middle';\n\n  const labelA = 'A';\n  const labelB = 'B';\n\n  ctx.fillText(labelA, padding.left - 10, tempToY(tempA));\n  ctx.fillText(labelB, padding.left - 10, tempToY(tempB));\n\n  // Axis labels\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  ctx.fillStyle = foreground;\n  ctx.font = '16px ' + api.getFont('default');\n  ctx.fillText('Distance around circle', padding.left + chartWidth / 2, padding.top + chartHeight + 15);\n\n  ctx.save();\n  ctx.translate(20, padding.top + chartHeight / 2);\n  ctx.rotate(-Math.PI / 2);\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  ctx.fillText('Temperature', 0, 0);\n  ctx.restore();\n\n  // Axis tick labels\n  ctx.fillStyle = muted;\n  ctx.font = '13px ' + api.getFont('default');\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n  ctx.fillText('Start', padding.left + 20, padding.top + chartHeight + 5);\n  ctx.fillText('End', padding.left + chartWidth - 20, padding.top + chartHeight + 5);\n\n  // Generate paths using provided checkpoints + seeded noise\n  const perlin = new PerlinNoise(seed);\n  const perlin2 = new PerlinNoise(seed + 100);\n  const numPoints = 200;\n\n  // Cubic Hermite interpolation for smooth curves through checkpoints\n  function hermiteInterpolate(p0, p1, p2, p3, t) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n\n    // Catmull-Rom spline coefficients\n    const h1 = 2*t3 - 3*t2 + 1;\n    const h2 = -2*t3 + 3*t2;\n    const h3 = t3 - 2*t2 + t;\n    const h4 = t3 - t2;\n\n    // Tangents (Catmull-Rom style)\n    const tension = 0.5;\n    const m0 = tension * (p2 - p0);\n    const m1 = tension * (p3 - p1);\n\n    return h1*p1 + h2*p2 + h3*m0 + h4*m1;\n  }\n\n  // Generate smooth path through given checkpoints with seeded noise\n  function generatePathFromCheckpoints(checkpoints, perlinInst, seedOffset) {\n    const path = [];\n\n    for (let i = 0; i <= numPoints; i++) {\n      const x = i / numPoints;\n\n      // Find which segment we're in\n      let segIdx = 0;\n      for (let j = 0; j < checkpoints.length - 1; j++) {\n        if (x >= checkpoints[j].x && x <= checkpoints[j + 1].x) {\n          segIdx = j;\n          break;\n        }\n      }\n\n      // Get 4 points for Hermite interpolation\n      const p0 = checkpoints[Math.max(0, segIdx - 1)].y;\n      const p1 = checkpoints[segIdx].y;\n      const p2 = checkpoints[Math.min(checkpoints.length - 1, segIdx + 1)].y;\n      const p3 = checkpoints[Math.min(checkpoints.length - 1, segIdx + 2)].y;\n\n      // Local t within segment\n      const segStart = checkpoints[segIdx].x;\n      const segEnd = checkpoints[segIdx + 1].x;\n      const t = (x - segStart) / (segEnd - segStart);\n\n      // Interpolated base temperature\n      let baseTemp = hermiteInterpolate(p0, p1, p2, p3, t);\n\n      // Add noise tapered at endpoints (so start/end are exact)\n      const endTaper = Math.pow(4 * x * (1 - x), 0.5);\n      const noise = perlinInst.noise(x * 8 + seedOffset) * noiseAmount * endTaper;\n\n      const temp = baseTemp + noise;\n\n      path.push({ x, temp });\n    }\n\n    // Force exact endpoints\n    path[0].temp = checkpoints[0].y;\n    path[numPoints].temp = checkpoints[checkpoints.length - 1].y;\n\n    return path;\n  }\n\n  // Generate paths from provided checkpoints\n  const youPath = generatePathFromCheckpoints(youCheckpoints, perlin, 0);\n  const friendPath = generatePathFromCheckpoints(friendCheckpoints, perlin2, 50);\n\n  // Draw \"You\" path (red)\n  ctx.strokeStyle = redPath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  for (let i = 0; i < youPath.length; i++) {\n    const point = youPath[i];\n    const canvasX = xToCanvas(point.x);\n    const canvasY = tempToY(point.temp);\n    if (i === 0) {\n      ctx.moveTo(canvasX, canvasY);\n    } else {\n      ctx.lineTo(canvasX, canvasY);\n    }\n  }\n  ctx.stroke();\n\n  // Draw \"Friend\" path (blue)\n  ctx.strokeStyle = bluePath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  for (let i = 0; i < friendPath.length; i++) {\n    const point = friendPath[i];\n    const canvasX = xToCanvas(point.x);\n    const canvasY = tempToY(point.temp);\n    if (i === 0) {\n      ctx.moveTo(canvasX, canvasY);\n    } else {\n      ctx.lineTo(canvasX, canvasY);\n    }\n  }\n  ctx.stroke();\n\n  // Legend\n  const legendX = padding.left + chartWidth - 100;\n  const legendY = 15;\n\n  ctx.strokeStyle = redPath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(legendX, legendY);\n  ctx.lineTo(legendX + 30, legendY);\n  ctx.stroke();\n\n  ctx.fillStyle = foreground;\n  ctx.font = '14px ' + api.getFont('default');\n  ctx.textAlign = 'left';\n  ctx.textBaseline = 'middle';\n  ctx.fillText('You', legendX + 35, legendY);\n\n  ctx.strokeStyle = bluePath;\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(legendX, legendY + 20);\n  ctx.lineTo(legendX + 30, legendY + 20);\n  ctx.stroke();\n\n  ctx.fillText('Friend', legendX + 35, legendY + 20);\n}","startLine",96]
