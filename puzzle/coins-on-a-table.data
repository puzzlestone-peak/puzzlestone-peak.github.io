[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","coins-on-a-table","puzzle",{"_7":8,"_11":12,"_40":41,"_42":43,"_44":45,"_62":63},"metadata",{"_13":14,"_15":16,"_17":18,"_19":22,"_25":26,"_30":31,"_32":33,"_34":33,"_35":36,"_37":38,"_39":38},"id","puzzle-18","title","Coins on a Table","difficulty",{"_19":20,"_21":20},"concepts","medium","reasoning",[23,24],"adversarial-game","game-theory","tags",[27,28,29],"has-solution","starter","interactive","credit","Classic game theory puzzle. Question and solution written by Puzzlestone Peak.","dateCreated","2025-11-02","lastUpdated","changelog","2025-11-03: Added to Puzzlestone Peak","preview","You and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put...","websitePreview","content","<p>You and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put identically-sized coins on the table. The coins must be laid flat on the table without extending beyond the table or overlapping another coin. The first person who cannot put down a coin loses. Your friend lets you decide if you’d like to go first or second.</p>\n<p>Should you go first or second? And how do you ensure that you can win?</p>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>If you choose to go first, there’s a strategy for you to guarantee a win.</p></div></details>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>The table doesn’t have to be a circle for this strategy to work. In fact, it can be an oval, a square, a rectangle, or even a hexagon. However, this strategy would fail on a triangular table.</p></div></details>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>You should go first. On your first move, place a coin in the middle of the table. After your friend places a coin, place your coin on the opposite side.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Your strategy involves keeping the table symmetric by a 180° rotation. This means that wherever your friend places a coin, there’ll be an identical spot on the opposite side where you can place a coin too. You can always guarantee a space for your coin until your friend runs out of spots to place his.</p><p>However, if a coin was placed over the midpoint of the table but offset to the side, then you can no longer keep the table symmetric, and the strategy breaks down. This is why you have to go first to place a coin in the exact middle of the table.</p><p>This strategy works on any table with a shape that is symmetric by a 180° rotation. This is why it works on shapes like ovals, squares, rectangles, hexagons, and so on, but not shapes like triangles and pentagons.</p><p>You can face off with this strategy as the second player. You play as the blue player against the red player.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nYou and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put identically-sized coins on the table. The coins must be laid flat on the table without extending beyond the table or overlapping another coin. The first person who cannot put down a coin loses. Your friend lets you decide if you’d like to go first or second.\n\nShould you go first or second? And how do you ensure that you can win?\n\n:::hint\nIf you choose to go first, there’s a strategy for you to guarantee a win.\n:::\n\n:::hint\nThe table doesn’t have to be a circle for this strategy to work. In fact, it can be an oval, a square, a rectangle, or even a hexagon. However, this strategy would fail on a triangular table.\n:::\n\n::::solution\nYou should go first. On your first move, place a coin in the middle of the table. After your friend places a coin, place your coin on the opposite side.\n\n:::dynamic\n```yaml\ntitle: \"Visual demonstration of the winning strategy: Place center coin, then mirror opponent's moves\"\nuse: '#diagram'\nprops:\n  mode: demo\n```\n:::\n\nYour strategy involves keeping the table symmetric by a 180° rotation. This means that wherever your friend places a coin, there’ll be an identical spot on the opposite side where you can place a coin too. You can always guarantee a space for your coin until your friend runs out of spots to place his.\n\nHowever, if a coin was placed over the midpoint of the table but offset to the side, then you can no longer keep the table symmetric, and the strategy breaks down. This is why you have to go first to place a coin in the exact middle of the table.\n\nThis strategy works on any table with a shape that is symmetric by a 180° rotation. This is why it works on shapes like ovals, squares, rectangles, hexagons, and so on, but not shapes like triangles and pentagons.\n\nYou can face off with this strategy as the second player. You play as the blue player against the red player.\n\n:::dynamic\n```yaml\ntitle: \"Interactive game: Try the strategy as the second player (blue) against the first player (red)\"\nuse: '#diagram'\nprops:\n  mode: interactive\n```\n:::\n::::\n\n:::component[diagram]\n\n```html\n<div id=\"container\" class=\"flex justify-center\">\n  <div class=\"relative w-fit\">\n    <canvas id=\"table-canvas\"></canvas>\n    <canvas id=\"action-canvas\" class=\"hidden absolute inset-0\"></canvas>\n  </div>\n</div>\n<div id=\"button-container\" class=\"flex justify-center gap-4 [&:not(:empty)]:mt-4\">\n</div>\n```\n\n```js\nfunction mount(options) {\n  const { props } = options;\n  if (props.mode === 'demo') {\n    mountDemo(options);\n  } else if (props.mode === 'interactive') {\n    mountInteractive(options);\n  }\n}\n\nfunction mountDemo(options) {\n  const { api, props } = options;\n  initColors(api);\n  const containerElem = document.querySelector('#container');\n\n  function draw() {\n    const containerWidth = containerElem.getBoundingClientRect().width;\n    const width = Math.min(800, containerWidth);\n\n    const maxGap = 20;\n    const gapRatio = 0.2; // for smaller screens, the gap should be this much of table diameter\n    const TABLE_COUNT = 3;\n    const gap = Math.min(maxGap, width / ((TABLE_COUNT + (TABLE_COUNT - 1) * gapRatio)) * gapRatio);\n    const tableSize = (width - ((TABLE_COUNT - 1) * gap)) / TABLE_COUNT;\n\n    const canvas = document.querySelector('#table-canvas');\n    canvas.width = width;\n    canvas.height = tableSize;\n    drawConfiguration({\n      canvas,\n      x: tableSize / 2 + (0 * (tableSize + gap)),\n      y: tableSize / 2,\n      radius: tableSize / 2,\n      coins: [\n        { player: 'A', theta: 0, radius: 0, new: true },\n        // { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\n        // { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\n      ],\n    });\n    drawConfiguration({\n      canvas,\n      x: tableSize / 2 + (1 * (tableSize + gap)),\n      y: tableSize / 2,\n      radius: tableSize / 2,\n      coins: [\n        { player: 'A', theta: 0, radius: 0 },\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5, new: true },\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5, new: true },\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\n      ],\n    });\n    drawConfiguration({\n      canvas,\n      x: tableSize / 2 + (2 * (tableSize + gap)),\n      y: tableSize / 2,\n      radius: tableSize / 2,\n      coins: [\n        { player: 'A', theta: 0, radius: 0 },\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\n        { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\n        { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\n      ],\n    });\n  }\n\n  let prevWidth = 0;\n  const observer = new ResizeObserver(entries => {\n    const curWidth = containerElem.getBoundingClientRect().width;\n    if (prevWidth === curWidth) { return; }\n    prevWidth = curWidth;\n    draw();\n  });\n  observer.observe(containerElem);\n  draw();\n}\n\nfunction mountInteractive(options) {\n  const { api, props } = options;\n  initColors(api);\n  const containerElem = document.querySelector('#container');\n  const buttonContainerElem = document.querySelector('#button-container');\n\n  const canvas = document.querySelector('#table-canvas');\n  const actionCanvas = document.querySelector('#action-canvas');\n  actionCanvas.classList.remove('hidden');\n\n  const firstCoin = { player: 'B', theta: 0, radius: 0, new: true };\n  let coins = [firstCoin];\n  let cursorCoin = undefined;\n  let lastInvalidCoin = undefined;\n\n  const undoButton = api.ui.button({ label: 'Undo', variant: 'contained', color: 'primary' });\n  const resetButton = api.ui.button({ label: 'Reset', variant: 'outlined', color: 'destructive' });\n\n  undoButton.classList.add(api.css('w-20'));\n  resetButton.classList.add(api.css('w-20'));\n\n  buttonContainerElem.appendChild(undoButton);\n  buttonContainerElem.appendChild(resetButton);\n\n  function updateControls() {\n    undoButton.disabled = coins.length <= 1;\n    resetButton.disabled = coins.length == 1;\n  }\n\n  function handleUndo() {\n    if (coins.length > 1) {\n      coins = coins.slice(0, -2);\n    }\n    draw();\n    updateControls();\n  }\n\n  function handleReset() {\n    coins = [firstCoin];\n    draw();\n    updateControls();\n  }\n\n  undoButton.addEventListener('click', handleUndo);\n  resetButton.addEventListener('click', handleReset);\n  updateControls();\n\n  let containerWidth = 0;\n  let canvasSize = 0;\n  let tableSize = 0;\n\n  function draw() {\n    containerWidth = containerElem.getBoundingClientRect().width;\n    canvasSize = Math.min(400, containerWidth);\n    tableSize = canvasSize / (1 + COIN_TO_TABLE_RATIO)\n\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n    drawConfiguration({\n      canvas,\n      x: canvasSize / 2,\n      y: canvasSize / 2,\n      radius: tableSize / 2,\n      coins,\n    });\n    drawAction();\n  }\n\n  let prevWidth = 0;\n  const observer = new ResizeObserver(entries => {\n    const curWidth = containerElem.getBoundingClientRect().width;\n    if (prevWidth === curWidth) { return; }\n    prevWidth = curWidth;\n    draw();\n  });\n  observer.observe(containerElem);\n  draw();\n\n  function drawAction() {\n    actionCanvas.width = canvasSize;\n    actionCanvas.height = canvasSize;\n    drawConfiguration({\n      canvas: actionCanvas,\n      x: canvasSize / 2,\n      y: canvasSize / 2,\n      radius: tableSize / 2,\n      hideTable: true,\n      coins: [\n        ...(!!cursorCoin ? [cursorCoin] : []),\n        ...(!!lastInvalidCoin ? [lastInvalidCoin] : []),\n      ],\n    });\n  }\n\n  function checkValidMove(coordinates) {\n    // Check if new coin is within table bounds\n    if (!coordinates.withinTable || coordinates.radius > 1) {\n      return false;\n    }\n\n    const tableRadius = tableSize / 2;\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\n    const maxCoinCenterDistance = tableRadius - coinRadius;\n    const centerX = canvasSize / 2;\n    const centerY = canvasSize / 2;\n\n    // Convert input coordinates to x/y\n    const newCoinDistance = coordinates.radius * maxCoinCenterDistance;\n    const newX = centerX + newCoinDistance * Math.cos(coordinates.theta);\n    const newY = centerY + newCoinDistance * Math.sin(coordinates.theta);\n\n    // Check overlap with existing coins\n    const minDistanceSquared = (2 * coinRadius) * (2 * coinRadius);\n    for (const coin of coins) {\n      const coinDistance = coin.radius * maxCoinCenterDistance;\n      const coinX = centerX + coinDistance * Math.cos(coin.theta);\n      const coinY = centerY + coinDistance * Math.sin(coin.theta);\n\n      const dx = newX - coinX;\n      const dy = newY - coinY;\n      const distanceSquared = dx * dx + dy * dy;\n\n      // Two coins overlap if distance between centers < sum of radii\n      // Compare squared distances to avoid expensive sqrt\n      if (distanceSquared < minDistanceSquared) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function handleMoveCursorCoin(coordinates) {\n    if (!coordinates || !coordinates.withinTable) {\n      cursorCoin = undefined;\n      drawAction();\n      return;\n    }\n\n    cursorCoin = {\n      player: 'A',\n      theta: coordinates.theta,\n      radius: coordinates.radius,\n      state: checkValidMove(coordinates) ? 'attempt' : 'invalid-attempt',\n    };\n    drawAction();\n  }\n\n  function handleClick(coordinates) {\n    if (!coordinates || !coordinates.withinTable) {\n      cursorCoin = undefined;\n      drawAction();\n      return;\n    }\n    const isValidMove = checkValidMove(coordinates);\n    if (!isValidMove) {\n      cursorCoin = {\n        player: 'A',\n        theta: coordinates.theta,\n        radius: coordinates.radius,\n        state: 'error',\n      };\n      drawAction();\n      return;\n    }\n\n    coins.push({\n      player: 'A',\n      theta: coordinates.theta,\n      radius: coordinates.radius,\n    });\n    coins.push({\n      player: 'B',\n      theta: (coordinates.theta + Math.PI) % (2 * Math.PI),\n      radius: coordinates.radius,\n    });\n    draw();\n    updateControls();\n  }\n\n  function getCoordinatesFromEvent(e) {\n    const rect = actionCanvas.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    // Calculate position relative to table center\n    const centerX = canvasSize / 2;\n    const centerY = canvasSize / 2;\n    const dx = mouseX - centerX;\n    const dy = mouseY - centerY;\n\n    // Calculate polar coordinates\n    const tableRadius = tableSize / 2;\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\n    const maxCoinCenterDistance = tableRadius - coinRadius;\n\n    const radius = Math.sqrt(dx * dx + dy * dy);\n    const normalizedRadius = radius / maxCoinCenterDistance;\n    const theta = Math.atan2(dy, dx);\n    const withinTable = radius <= tableRadius;\n\n    return { radius: normalizedRadius, theta, withinTable };\n  }\n\n  // Add hover coordinate logging\n  actionCanvas.addEventListener('mousemove', (e) => {\n    const coords = getCoordinatesFromEvent(e);\n    handleMoveCursorCoin(coords);\n  });\n\n  actionCanvas.addEventListener('click', (e) => {\n    const coords = getCoordinatesFromEvent(e);\n    handleClick(coords);\n  });\n\n  actionCanvas.addEventListener('mouseleave', () => {\n    handleMoveCursorCoin(undefined);\n  });\n}\n\n// Configuration\nconst OUTLINE_THICKNESS = 2;\nconst COIN_TO_TABLE_RATIO = 1 / 8;\n\n// Colors (initialized by initColors)\nlet TABLE_FILL, TABLE_OUTLINE, PLAYER_A_FILL, PLAYER_A_OUTLINE, PLAYER_B_FILL, PLAYER_B_OUTLINE;\n\nfunction initColors(api) {\n  TABLE_FILL = api.getColor('amber-700');\n  TABLE_OUTLINE = api.getColor('amber-900');\n  PLAYER_A_FILL = api.getColor('blue-500');\n  PLAYER_A_OUTLINE = api.getColor('blue-800');\n  PLAYER_B_FILL = api.getColor('red-500');\n  PLAYER_B_OUTLINE = api.getColor('red-800');\n}\nconst NEW_COIN_OUTLINE_THICKNESS = OUTLINE_THICKNESS * 3;\n\n/**\n * Draws a configuration of coins on a circular table\n * @param {Object} params - Configuration parameters\n * @param {HTMLCanvasElement} params.canvas - The canvas element to draw on\n * @param {number} params.x - The x-coordinate of the table center\n * @param {number} params.y - The y-coordinate of the table center\n * @param {number} params.radius - The radius of the table in pixels\n * @param {boolean} [params.hideTable] - Hides the table\n * @param {Array<{player: 'A'|'B', theta: number, radius: number, state?:  }>} params.coins - Array of coin positions\n *   - player: The player who placed the coin ('A' or 'B')\n *   - theta: Angular position in radians (0 to 2π)\n *   - radius: Normalized radial distance from center (0 to 1)\n *   - state: `undefined` for no status | 'new' | 'attempt' | 'invalid-attempt' | 'error'\n */\nfunction drawConfiguration({ canvas, x, y, radius, hideTable, coins }) {\n  const ctx = canvas.getContext('2d');\n\n  if (!hideTable) {\n    // Draw table\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = TABLE_FILL;\n    ctx.fill();\n\n    // Draw table outline (inset by half thickness)\n    ctx.beginPath();\n    ctx.arc(x, y, Math.max(0, radius - OUTLINE_THICKNESS / 2), 0, Math.PI * 2);\n    ctx.lineWidth = OUTLINE_THICKNESS;\n    ctx.strokeStyle = TABLE_OUTLINE;\n    ctx.stroke();\n  }\n\n  // Draw coins\n  const COIN_RADIUS = radius * COIN_TO_TABLE_RATIO;\n  const maxCoinCenterDistance = radius - COIN_RADIUS;\n\n  for (const coin of coins) {\n    // Calculate coin center position\n    const coinCenterDistance = coin.radius * maxCoinCenterDistance;\n    const coinCenterX = x + coinCenterDistance * Math.cos(coin.theta);\n    const coinCenterY = y + coinCenterDistance * Math.sin(coin.theta);\n\n    // Choose colors based on player\n    const fillColor = coin.player === 'A' ? PLAYER_A_FILL : PLAYER_B_FILL;\n    const outlineColor = coin.player === 'A' ? PLAYER_A_OUTLINE : PLAYER_B_OUTLINE;\n\n    ctx.save();\n\n    if (coin.state === 'invalid-attempt' || coin.state === 'error') {\n      ctx.globalAlpha = 0.4;\n    }\n\n    // Draw coin\n    ctx.beginPath();\n    ctx.arc(coinCenterX, coinCenterY, COIN_RADIUS, 0, Math.PI * 2);\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n\n    // Draw coin outline (inset by half thickness)\n    ctx.beginPath();\n    const outlineThickness = coin.state === 'new' ? NEW_COIN_OUTLINE_THICKNESS : OUTLINE_THICKNESS;\n    ctx.arc(coinCenterX, coinCenterY, Math.max(0, COIN_RADIUS - outlineThickness / 2), 0, Math.PI * 2);\n    ctx.lineWidth = outlineThickness;\n    ctx.strokeStyle = outlineColor;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n}\n```","dynamicBlocks",[46,59],{"_47":48,"_49":50,"_51":52,"_53":54,"_15":56,"_57":58},"type","dynamic","mode","component","componentId","#diagram","props",{"_49":55},"demo","Visual demonstration of the winning strategy: Place center coin, then mirror opponent's moves","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/adversarial-games/coins-on-a-table.md",{"_47":48,"_49":50,"_51":52,"_53":60,"_15":61,"_57":58},{"_49":29},"Interactive game: Try the strategy as the second player (blue) against the first player (red)","inlineComponents",{"_64":65},"diagram",{"_13":64,"_66":67,"_68":69,"_70":71},"code","function mount(options) {\n  const { props } = options;\n  if (props.mode === 'demo') {\n    mountDemo(options);\n  } else if (props.mode === 'interactive') {\n    mountInteractive(options);\n  }\n}\n\nfunction mountDemo(options) {\n  const { api, props } = options;\n  initColors(api);\n  const containerElem = document.querySelector('#container');\n\n  function draw() {\n    const containerWidth = containerElem.getBoundingClientRect().width;\n    const width = Math.min(800, containerWidth);\n\n    const maxGap = 20;\n    const gapRatio = 0.2; // for smaller screens, the gap should be this much of table diameter\n    const TABLE_COUNT = 3;\n    const gap = Math.min(maxGap, width / ((TABLE_COUNT + (TABLE_COUNT - 1) * gapRatio)) * gapRatio);\n    const tableSize = (width - ((TABLE_COUNT - 1) * gap)) / TABLE_COUNT;\n\n    const canvas = document.querySelector('#table-canvas');\n    canvas.width = width;\n    canvas.height = tableSize;\n    drawConfiguration({\n      canvas,\n      x: tableSize / 2 + (0 * (tableSize + gap)),\n      y: tableSize / 2,\n      radius: tableSize / 2,\n      coins: [\n        { player: 'A', theta: 0, radius: 0, new: true },\n        // { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\n        // { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\n      ],\n    });\n    drawConfiguration({\n      canvas,\n      x: tableSize / 2 + (1 * (tableSize + gap)),\n      y: tableSize / 2,\n      radius: tableSize / 2,\n      coins: [\n        { player: 'A', theta: 0, radius: 0 },\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5, new: true },\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5, new: true },\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\n      ],\n    });\n    drawConfiguration({\n      canvas,\n      x: tableSize / 2 + (2 * (tableSize + gap)),\n      y: tableSize / 2,\n      radius: tableSize / 2,\n      coins: [\n        { player: 'A', theta: 0, radius: 0 },\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\n        { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\n        { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\n      ],\n    });\n  }\n\n  let prevWidth = 0;\n  const observer = new ResizeObserver(entries => {\n    const curWidth = containerElem.getBoundingClientRect().width;\n    if (prevWidth === curWidth) { return; }\n    prevWidth = curWidth;\n    draw();\n  });\n  observer.observe(containerElem);\n  draw();\n}\n\nfunction mountInteractive(options) {\n  const { api, props } = options;\n  initColors(api);\n  const containerElem = document.querySelector('#container');\n  const buttonContainerElem = document.querySelector('#button-container');\n\n  const canvas = document.querySelector('#table-canvas');\n  const actionCanvas = document.querySelector('#action-canvas');\n  actionCanvas.classList.remove('hidden');\n\n  const firstCoin = { player: 'B', theta: 0, radius: 0, new: true };\n  let coins = [firstCoin];\n  let cursorCoin = undefined;\n  let lastInvalidCoin = undefined;\n\n  const undoButton = api.ui.button({ label: 'Undo', variant: 'contained', color: 'primary' });\n  const resetButton = api.ui.button({ label: 'Reset', variant: 'outlined', color: 'destructive' });\n\n  undoButton.classList.add(api.css('w-20'));\n  resetButton.classList.add(api.css('w-20'));\n\n  buttonContainerElem.appendChild(undoButton);\n  buttonContainerElem.appendChild(resetButton);\n\n  function updateControls() {\n    undoButton.disabled = coins.length <= 1;\n    resetButton.disabled = coins.length == 1;\n  }\n\n  function handleUndo() {\n    if (coins.length > 1) {\n      coins = coins.slice(0, -2);\n    }\n    draw();\n    updateControls();\n  }\n\n  function handleReset() {\n    coins = [firstCoin];\n    draw();\n    updateControls();\n  }\n\n  undoButton.addEventListener('click', handleUndo);\n  resetButton.addEventListener('click', handleReset);\n  updateControls();\n\n  let containerWidth = 0;\n  let canvasSize = 0;\n  let tableSize = 0;\n\n  function draw() {\n    containerWidth = containerElem.getBoundingClientRect().width;\n    canvasSize = Math.min(400, containerWidth);\n    tableSize = canvasSize / (1 + COIN_TO_TABLE_RATIO)\n\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n    drawConfiguration({\n      canvas,\n      x: canvasSize / 2,\n      y: canvasSize / 2,\n      radius: tableSize / 2,\n      coins,\n    });\n    drawAction();\n  }\n\n  let prevWidth = 0;\n  const observer = new ResizeObserver(entries => {\n    const curWidth = containerElem.getBoundingClientRect().width;\n    if (prevWidth === curWidth) { return; }\n    prevWidth = curWidth;\n    draw();\n  });\n  observer.observe(containerElem);\n  draw();\n\n  function drawAction() {\n    actionCanvas.width = canvasSize;\n    actionCanvas.height = canvasSize;\n    drawConfiguration({\n      canvas: actionCanvas,\n      x: canvasSize / 2,\n      y: canvasSize / 2,\n      radius: tableSize / 2,\n      hideTable: true,\n      coins: [\n        ...(!!cursorCoin ? [cursorCoin] : []),\n        ...(!!lastInvalidCoin ? [lastInvalidCoin] : []),\n      ],\n    });\n  }\n\n  function checkValidMove(coordinates) {\n    // Check if new coin is within table bounds\n    if (!coordinates.withinTable || coordinates.radius > 1) {\n      return false;\n    }\n\n    const tableRadius = tableSize / 2;\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\n    const maxCoinCenterDistance = tableRadius - coinRadius;\n    const centerX = canvasSize / 2;\n    const centerY = canvasSize / 2;\n\n    // Convert input coordinates to x/y\n    const newCoinDistance = coordinates.radius * maxCoinCenterDistance;\n    const newX = centerX + newCoinDistance * Math.cos(coordinates.theta);\n    const newY = centerY + newCoinDistance * Math.sin(coordinates.theta);\n\n    // Check overlap with existing coins\n    const minDistanceSquared = (2 * coinRadius) * (2 * coinRadius);\n    for (const coin of coins) {\n      const coinDistance = coin.radius * maxCoinCenterDistance;\n      const coinX = centerX + coinDistance * Math.cos(coin.theta);\n      const coinY = centerY + coinDistance * Math.sin(coin.theta);\n\n      const dx = newX - coinX;\n      const dy = newY - coinY;\n      const distanceSquared = dx * dx + dy * dy;\n\n      // Two coins overlap if distance between centers < sum of radii\n      // Compare squared distances to avoid expensive sqrt\n      if (distanceSquared < minDistanceSquared) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function handleMoveCursorCoin(coordinates) {\n    if (!coordinates || !coordinates.withinTable) {\n      cursorCoin = undefined;\n      drawAction();\n      return;\n    }\n\n    cursorCoin = {\n      player: 'A',\n      theta: coordinates.theta,\n      radius: coordinates.radius,\n      state: checkValidMove(coordinates) ? 'attempt' : 'invalid-attempt',\n    };\n    drawAction();\n  }\n\n  function handleClick(coordinates) {\n    if (!coordinates || !coordinates.withinTable) {\n      cursorCoin = undefined;\n      drawAction();\n      return;\n    }\n    const isValidMove = checkValidMove(coordinates);\n    if (!isValidMove) {\n      cursorCoin = {\n        player: 'A',\n        theta: coordinates.theta,\n        radius: coordinates.radius,\n        state: 'error',\n      };\n      drawAction();\n      return;\n    }\n\n    coins.push({\n      player: 'A',\n      theta: coordinates.theta,\n      radius: coordinates.radius,\n    });\n    coins.push({\n      player: 'B',\n      theta: (coordinates.theta + Math.PI) % (2 * Math.PI),\n      radius: coordinates.radius,\n    });\n    draw();\n    updateControls();\n  }\n\n  function getCoordinatesFromEvent(e) {\n    const rect = actionCanvas.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const mouseY = e.clientY - rect.top;\n\n    // Calculate position relative to table center\n    const centerX = canvasSize / 2;\n    const centerY = canvasSize / 2;\n    const dx = mouseX - centerX;\n    const dy = mouseY - centerY;\n\n    // Calculate polar coordinates\n    const tableRadius = tableSize / 2;\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\n    const maxCoinCenterDistance = tableRadius - coinRadius;\n\n    const radius = Math.sqrt(dx * dx + dy * dy);\n    const normalizedRadius = radius / maxCoinCenterDistance;\n    const theta = Math.atan2(dy, dx);\n    const withinTable = radius <= tableRadius;\n\n    return { radius: normalizedRadius, theta, withinTable };\n  }\n\n  // Add hover coordinate logging\n  actionCanvas.addEventListener('mousemove', (e) => {\n    const coords = getCoordinatesFromEvent(e);\n    handleMoveCursorCoin(coords);\n  });\n\n  actionCanvas.addEventListener('click', (e) => {\n    const coords = getCoordinatesFromEvent(e);\n    handleClick(coords);\n  });\n\n  actionCanvas.addEventListener('mouseleave', () => {\n    handleMoveCursorCoin(undefined);\n  });\n}\n\n// Configuration\nconst OUTLINE_THICKNESS = 2;\nconst COIN_TO_TABLE_RATIO = 1 / 8;\n\n// Colors (initialized by initColors)\nlet TABLE_FILL, TABLE_OUTLINE, PLAYER_A_FILL, PLAYER_A_OUTLINE, PLAYER_B_FILL, PLAYER_B_OUTLINE;\n\nfunction initColors(api) {\n  TABLE_FILL = api.getColor('amber-700');\n  TABLE_OUTLINE = api.getColor('amber-900');\n  PLAYER_A_FILL = api.getColor('blue-500');\n  PLAYER_A_OUTLINE = api.getColor('blue-800');\n  PLAYER_B_FILL = api.getColor('red-500');\n  PLAYER_B_OUTLINE = api.getColor('red-800');\n}\nconst NEW_COIN_OUTLINE_THICKNESS = OUTLINE_THICKNESS * 3;\n\n/**\n * Draws a configuration of coins on a circular table\n * @param {Object} params - Configuration parameters\n * @param {HTMLCanvasElement} params.canvas - The canvas element to draw on\n * @param {number} params.x - The x-coordinate of the table center\n * @param {number} params.y - The y-coordinate of the table center\n * @param {number} params.radius - The radius of the table in pixels\n * @param {boolean} [params.hideTable] - Hides the table\n * @param {Array<{player: 'A'|'B', theta: number, radius: number, state?:  }>} params.coins - Array of coin positions\n *   - player: The player who placed the coin ('A' or 'B')\n *   - theta: Angular position in radians (0 to 2π)\n *   - radius: Normalized radial distance from center (0 to 1)\n *   - state: `undefined` for no status | 'new' | 'attempt' | 'invalid-attempt' | 'error'\n */\nfunction drawConfiguration({ canvas, x, y, radius, hideTable, coins }) {\n  const ctx = canvas.getContext('2d');\n\n  if (!hideTable) {\n    // Draw table\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = TABLE_FILL;\n    ctx.fill();\n\n    // Draw table outline (inset by half thickness)\n    ctx.beginPath();\n    ctx.arc(x, y, Math.max(0, radius - OUTLINE_THICKNESS / 2), 0, Math.PI * 2);\n    ctx.lineWidth = OUTLINE_THICKNESS;\n    ctx.strokeStyle = TABLE_OUTLINE;\n    ctx.stroke();\n  }\n\n  // Draw coins\n  const COIN_RADIUS = radius * COIN_TO_TABLE_RATIO;\n  const maxCoinCenterDistance = radius - COIN_RADIUS;\n\n  for (const coin of coins) {\n    // Calculate coin center position\n    const coinCenterDistance = coin.radius * maxCoinCenterDistance;\n    const coinCenterX = x + coinCenterDistance * Math.cos(coin.theta);\n    const coinCenterY = y + coinCenterDistance * Math.sin(coin.theta);\n\n    // Choose colors based on player\n    const fillColor = coin.player === 'A' ? PLAYER_A_FILL : PLAYER_B_FILL;\n    const outlineColor = coin.player === 'A' ? PLAYER_A_OUTLINE : PLAYER_B_OUTLINE;\n\n    ctx.save();\n\n    if (coin.state === 'invalid-attempt' || coin.state === 'error') {\n      ctx.globalAlpha = 0.4;\n    }\n\n    // Draw coin\n    ctx.beginPath();\n    ctx.arc(coinCenterX, coinCenterY, COIN_RADIUS, 0, Math.PI * 2);\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n\n    // Draw coin outline (inset by half thickness)\n    ctx.beginPath();\n    const outlineThickness = coin.state === 'new' ? NEW_COIN_OUTLINE_THICKNESS : OUTLINE_THICKNESS;\n    ctx.arc(coinCenterX, coinCenterY, Math.max(0, COIN_RADIUS - outlineThickness / 2), 0, Math.PI * 2);\n    ctx.lineWidth = outlineThickness;\n    ctx.strokeStyle = outlineColor;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n}","layout","<div id=\"container\" class=\"flex justify-center\">\n  <div class=\"relative w-fit\">\n    <canvas id=\"table-canvas\"></canvas>\n    <canvas id=\"action-canvas\" class=\"hidden absolute inset-0\"></canvas>\n  </div>\n</div>\n<div id=\"button-container\" class=\"flex justify-center gap-4 [&:not(:empty)]:mt-4\">\n</div>","startLine",76]
