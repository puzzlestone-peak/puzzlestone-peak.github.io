[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8},"slug","cryptography-quantum","puzzle",{"_5":6,"_9":10,"_35":36,"_37":38,"_39":40},"metadata",{"_11":12,"_13":14,"_15":16,"_20":21,"_22":23,"_27":28,"_29":28,"_30":31,"_32":33,"_34":33},"id","16","title","Post-Quantum Cryptography","concepts",[17,18,19],"cryptography","computational-complexity","quantum-computing","difficulty","master","tags",[24,25,26],"series","quantum-resistant","modern-cryptography","dateCreated","2025-10-22T00:00:00.000Z","lastUpdated","previousPuzzle","cryptography-rsa","preview","The Quantum Threat Shor's algorithm (1994) proved that a sufficiently powerful quantum computer can: Factor large numbers in polynomial time (breaking RSA)...","websitePreview","content","<h2 class=\"markdown-h1\">The Quantum Threat</h2>\n<p>Shor's algorithm (1994) proved that a sufficiently powerful quantum computer can:</p>\n<ul>\n<li>Factor large numbers in polynomial time (breaking RSA)</li>\n<li>Solve discrete logarithm problems (breaking Diffie-Hellman, elliptic curve cryptography)</li>\n</ul>\n<p>This threatens virtually all current public-key cryptography. When large-scale quantum computers exist, encrypted data — including data encrypted today — will be vulnerable.</p>\n<h2 class=\"markdown-h1\">Post-Quantum Cryptography</h2>\n<p>Cryptographers are developing encryption methods based on problems believed to be hard even for quantum computers:</p>\n<ol>\n<li><strong>Lattice-based cryptography</strong> — Problems about high-dimensional lattices</li>\n<li><strong>Code-based cryptography</strong> — Decoding random linear codes</li>\n<li><strong>Hash-based signatures</strong> — Using cryptographic hash functions</li>\n<li><strong>Multivariate polynomial cryptography</strong> — Solving systems of polynomials</li>\n<li><strong>Isogeny-based cryptography</strong> — Computing isogenies between elliptic curves</li>\n</ol>\n<h2 class=\"markdown-h1\">The Challenge</h2>\n<p>Explore the hardness foundations of post-quantum cryptography:</p>\n<p><strong>Part A</strong>: The <strong>Shortest Vector Problem (SVP)</strong> asks: given a lattice (a discrete grid of points in n-dimensional space), find the shortest non-zero vector. Why is this problem believed to be hard for both classical and quantum computers?</p>\n<p><strong>Part B</strong>: The <strong>Learning With Errors (LWE)</strong> problem is the foundation of many lattice-based schemes. Given many linear equations with small random errors added, recover the secret. Explain why adding small errors transforms an easy problem (solving linear equations) into a presumably hard one.</p>\n<p><strong>Part C</strong>: <strong>NIST Post-Quantum Cryptography Standardization</strong> (2016-2024) selected algorithms for standardisation. Research what NIST chose and explain the trade-offs between security level, key size, and performance.</p>\n<p><strong>Part D</strong>: What is \"harvest now, decrypt later\"? Why does this threat require migrating to post-quantum cryptography before large quantum computers exist?</p>\n<details class=\"hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>For Part A, consider that SVP is believed to be NP-hard. Quantum computers provide speedup for some problems but not all NP-hard problems.</p></div></details>\n<details class=\"hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Grover's algorithm gives quantum computers a quadratic speedup for unstructured search, but this only requires doubling key sizes for symmetric encryption.</p></div></details>\n<details class=\"hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>For Part B, think about how noise in measurements affects what information can be extracted. Small errors compound in surprising ways.</p></div></details>\n<details class=\"hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>For Part C, NIST selected CRYSTALS-Kyber for encryption and CRYSTALS-Dilithium, Falcon, and SPHINCS+ for signatures. Research their properties.</p></div></details>\n<details class=\"solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><strong>Answer</strong>: A) SVP is NP-hard under certain reductions; quantum algorithms don't solve all NP-hard problems efficiently. B) Errors prevent using Gaussian elimination; recovering the secret requires solving an exponentially hard problem. C) See detailed comparison below. D) Adversaries can record encrypted data now and decrypt it later once quantum computers exist.</p><h3 class=\"markdown-h2\">Part A: Shortest Vector Problem</h3><p>The <strong>Shortest Vector Problem (SVP)</strong>: Given a basis for an n-dimensional lattice, find the shortest non-zero vector in the lattice.</p><p><strong>Example (2D)</strong>:\nConsider a lattice generated by basis vectors v₁ = (1, 0) and v₂ = (1, 2). The lattice consists of all points a·v₁ + b·v₂ where a, b are integers. The shortest non-zero vector is (1, 0) with length 1.</p><p>For poorly chosen bases in high dimensions, finding the shortest vector becomes extraordinarily difficult.</p><p><strong>Why It's Hard</strong>:</p><ol>\n<li><strong>Worst-case hardness</strong>: SVP is NP-hard under randomised reductions (Ajtai, 1996)</li>\n<li><strong>No quantum shortcut</strong>: Known quantum algorithms (including Grover's) provide at most a modest speedup, not the exponential speedup that breaks RSA</li>\n<li><strong>Best known algorithms</strong>: The fastest algorithms (like sieving methods) require time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{O(n)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span> for dimension n, even on quantum computers</li>\n<li><strong>High dimensions</strong>: Post-quantum schemes use dimensions n ≈ 500-1000, making attacks infeasible</li>\n</ol><p><strong>Quantum resistance</strong>: While quantum computers excel at problems with hidden structure (like factoring), lattice problems appear to lack exploitable structure. After decades of research, no efficient quantum algorithm for SVP exists.</p><h3 class=\"markdown-h2\">Part B: Learning With Errors (LWE)</h3><p><strong>Setup</strong>: Alice has a secret vector <strong>s</strong> = (s₁, s₂, ..., sₙ) with entries in ℤq (integers mod q).</p><p><strong>Without errors</strong>: Bob gives Alice many vectors <strong>aᵢ</strong> and receives:\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">⟨</mo><msub><mi mathvariant=\"bold\">a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi mathvariant=\"bold\">s</mi><mo stretchy=\"false\">⟩</mo><mspace></mspace><mspace width=\"0.4444em\"></mspace><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mspace width=\"0.3333em\"></mspace><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle \\pmod{q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord mathbf\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbf\">s</span><span class=\"mclose\">⟩</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.4444em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">)</span></span></span></span></p><p>This is just a system of linear equations. Using Gaussian elimination, Bob can recover <strong>s</strong> in polynomial time.</p><p><strong>With errors</strong>: Alice adds small random errors eᵢ:\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mo stretchy=\"false\">⟨</mo><msub><mi mathvariant=\"bold\">a</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi mathvariant=\"bold\">s</mi><mo stretchy=\"false\">⟩</mo><mo>+</mo><msub><mi>e</mi><mi>i</mi></msub><mspace></mspace><mspace width=\"0.4444em\"></mspace><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mspace width=\"0.3333em\"></mspace><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle + e_i \\pmod{q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord mathbf\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbf\">s</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.4444em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">)</span></span></span></span></p><p>where each |eᵢ| is small (say, |eᵢ| &#x3C; q/10).</p><p><strong>Why this is hard</strong>: The small errors prevent direct application of linear algebra. The problem becomes:</p><ul>\n<li>Given many \"approximate\" linear equations</li>\n<li>Separate the signal (secret <strong>s</strong>) from the noise (errors <strong>e</strong>)</li>\n<li>Known attacks require exponential time</li>\n</ul><p><strong>Intuition</strong>: Each equation gives a \"fuzzy hyperplane\" in n-dimensional space. The secret <strong>s</strong> lies near all these hyperplanes, but the noise makes it impossible to locate precisely without exponential search.</p><p><strong>Reductions</strong>: LWE is provably as hard as solving worst-case lattice problems (Regev, 2005). If you can solve LWE efficiently, you can solve SVP for any lattice — giving quantum resistance.</p><h3 class=\"markdown-h2\">Part C: NIST Post-Quantum Standards</h3><p>After 8 years of competition, NIST selected (2022-2024):</p><p><strong>For Encryption/Key Exchange</strong>:</p><ul>\n<li><strong>CRYSTALS-Kyber</strong> (now standardised as ML-KEM)\n<ul>\n<li>Based on: Module Learning With Errors (Module-LWE)</li>\n<li>Public key: ~1 KB</li>\n<li>Ciphertext: ~1 KB</li>\n<li>Security levels: 128, 192, 256-bit equivalent</li>\n<li>Performance: Very fast, suitable for TLS</li>\n</ul>\n</li>\n</ul><p><strong>For Digital Signatures</strong>:</p><ul>\n<li>\n<p><strong>CRYSTALS-Dilithium</strong> (now ML-DSA)</p>\n<ul>\n<li>Based on: Module-LWE</li>\n<li>Public key: ~1-2 KB</li>\n<li>Signature: ~2-4 KB</li>\n<li>Fast signing and verification</li>\n</ul>\n</li>\n<li>\n<p><strong>Falcon</strong></p>\n<ul>\n<li>Based on: NTRU lattices</li>\n<li>Public key: ~1 KB</li>\n<li>Signature: ~700 bytes (smallest signatures)</li>\n<li>Slower signing (requires floating-point)</li>\n</ul>\n</li>\n<li>\n<p><strong>SPHINCS+</strong> (now SLH-DSA)</p>\n<ul>\n<li>Based on: Hash functions (stateless hash-based signatures)</li>\n<li>Public key: ~32-64 bytes (tiny!)</li>\n<li>Signature: ~8-50 KB (very large)</li>\n<li>Slowest but conservative (only assumes hash functions are secure)</li>\n</ul>\n</li>\n</ul><p><strong>Trade-offs</strong>:</p><table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Kyber</th>\n<th>Dilithium</th>\n<th>Falcon</th>\n<th>SPHINCS+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Hardness assumption</strong></td>\n<td>Module-LWE</td>\n<td>Module-LWE</td>\n<td>NTRU</td>\n<td>Hash functions</td>\n</tr>\n<tr>\n<td><strong>Key size</strong></td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Tiny</td>\n</tr>\n<tr>\n<td><strong>Signature/CT size</strong></td>\n<td>Medium</td>\n<td>Large</td>\n<td>Small</td>\n<td>Huge</td>\n</tr>\n<tr>\n<td><strong>Speed</strong></td>\n<td>Fast</td>\n<td>Fast</td>\n<td>Medium</td>\n<td>Slow</td>\n</tr>\n<tr>\n<td><strong>Simplicity</strong></td>\n<td>Moderate</td>\n<td>Moderate</td>\n<td>Complex</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td><strong>Quantum security</strong></td>\n<td>Strong</td>\n<td>Strong</td>\n<td>Strong</td>\n<td>Strongest</td>\n</tr>\n</tbody>\n</table><p><strong>NIST's strategy</strong>: Diversify! Different algorithms based on different hard problems, allowing migration if one assumption breaks.</p><h3 class=\"markdown-h2\">Part D: Harvest Now, Decrypt Later</h3><p><strong>Threat model</strong>: An adversary with resources (e.g., nation-state) can:</p><ol>\n<li><strong>Today</strong>: Record all encrypted internet traffic</li>\n<li><strong>Store it</strong>: Data remains encrypted and unreadable</li>\n<li><strong>Wait</strong>: 10-20 years for large quantum computers</li>\n<li><strong>Decrypt</strong>: Use Shor's algorithm to break RSA/ECC and read historical data</li>\n</ol><p><strong>Vulnerable data</strong>:</p><ul>\n<li>Government communications</li>\n<li>Medical records</li>\n<li>Financial data</li>\n<li>Trade secrets</li>\n<li>Personal communications</li>\n</ul><p><strong>Timeline pressure</strong>: Even though large quantum computers don't exist yet, sensitive data encrypted with RSA today is at risk. Once quantum computers arrive, all that stored data becomes readable.</p><p><strong>Migration imperative</strong>: Organisations must migrate to post-quantum cryptography <strong>now</strong>, before quantum computers exist, to protect data being encrypted today.</p><p><strong>Current status (2025)</strong>:</p><ul>\n<li>Major internet companies deploying post-quantum TLS</li>\n<li>Governments mandating post-quantum migration timelines</li>\n<li>Cryptographic libraries implementing NIST standards</li>\n<li>Hardware accelerators for lattice cryptography in development</li>\n</ul><p>The race is on: will we migrate to quantum-resistant cryptography before quantum computers capable of breaking current encryption are built?</p></div></details>","rawContent","\n# The Quantum Threat\n\nShor's algorithm (1994) proved that a sufficiently powerful quantum computer can:\n- Factor large numbers in polynomial time (breaking RSA)\n- Solve discrete logarithm problems (breaking Diffie-Hellman, elliptic curve cryptography)\n\nThis threatens virtually all current public-key cryptography. When large-scale quantum computers exist, encrypted data — including data encrypted today — will be vulnerable.\n\n# Post-Quantum Cryptography\n\nCryptographers are developing encryption methods based on problems believed to be hard even for quantum computers:\n\n1. **Lattice-based cryptography** — Problems about high-dimensional lattices\n2. **Code-based cryptography** — Decoding random linear codes\n3. **Hash-based signatures** — Using cryptographic hash functions\n4. **Multivariate polynomial cryptography** — Solving systems of polynomials\n5. **Isogeny-based cryptography** — Computing isogenies between elliptic curves\n\n# The Challenge\n\nExplore the hardness foundations of post-quantum cryptography:\n\n**Part A**: The **Shortest Vector Problem (SVP)** asks: given a lattice (a discrete grid of points in n-dimensional space), find the shortest non-zero vector. Why is this problem believed to be hard for both classical and quantum computers?\n\n**Part B**: The **Learning With Errors (LWE)** problem is the foundation of many lattice-based schemes. Given many linear equations with small random errors added, recover the secret. Explain why adding small errors transforms an easy problem (solving linear equations) into a presumably hard one.\n\n**Part C**: **NIST Post-Quantum Cryptography Standardization** (2016-2024) selected algorithms for standardisation. Research what NIST chose and explain the trade-offs between security level, key size, and performance.\n\n**Part D**: What is \"harvest now, decrypt later\"? Why does this threat require migrating to post-quantum cryptography before large quantum computers exist?\n\n:::hint\nFor Part A, consider that SVP is believed to be NP-hard. Quantum computers provide speedup for some problems but not all NP-hard problems.\n:::\n\n:::hint\nGrover's algorithm gives quantum computers a quadratic speedup for unstructured search, but this only requires doubling key sizes for symmetric encryption.\n:::\n\n:::hint\nFor Part B, think about how noise in measurements affects what information can be extracted. Small errors compound in surprising ways.\n:::\n\n:::hint\nFor Part C, NIST selected CRYSTALS-Kyber for encryption and CRYSTALS-Dilithium, Falcon, and SPHINCS+ for signatures. Research their properties.\n:::\n\n:::solution\n**Answer**: A) SVP is NP-hard under certain reductions; quantum algorithms don't solve all NP-hard problems efficiently. B) Errors prevent using Gaussian elimination; recovering the secret requires solving an exponentially hard problem. C) See detailed comparison below. D) Adversaries can record encrypted data now and decrypt it later once quantum computers exist.\n\n## Part A: Shortest Vector Problem\n\nThe **Shortest Vector Problem (SVP)**: Given a basis for an n-dimensional lattice, find the shortest non-zero vector in the lattice.\n\n**Example (2D)**:\nConsider a lattice generated by basis vectors v₁ = (1, 0) and v₂ = (1, 2). The lattice consists of all points a·v₁ + b·v₂ where a, b are integers. The shortest non-zero vector is (1, 0) with length 1.\n\nFor poorly chosen bases in high dimensions, finding the shortest vector becomes extraordinarily difficult.\n\n**Why It's Hard**:\n\n1. **Worst-case hardness**: SVP is NP-hard under randomised reductions (Ajtai, 1996)\n2. **No quantum shortcut**: Known quantum algorithms (including Grover's) provide at most a modest speedup, not the exponential speedup that breaks RSA\n3. **Best known algorithms**: The fastest algorithms (like sieving methods) require time $2^{O(n)}$ for dimension n, even on quantum computers\n4. **High dimensions**: Post-quantum schemes use dimensions n ≈ 500-1000, making attacks infeasible\n\n**Quantum resistance**: While quantum computers excel at problems with hidden structure (like factoring), lattice problems appear to lack exploitable structure. After decades of research, no efficient quantum algorithm for SVP exists.\n\n## Part B: Learning With Errors (LWE)\n\n**Setup**: Alice has a secret vector **s** = (s₁, s₂, ..., sₙ) with entries in ℤq (integers mod q).\n\n**Without errors**: Bob gives Alice many vectors **aᵢ** and receives:\n$$b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle \\pmod{q}$$\n\nThis is just a system of linear equations. Using Gaussian elimination, Bob can recover **s** in polynomial time.\n\n**With errors**: Alice adds small random errors eᵢ:\n$$b_i = \\langle \\mathbf{a}_i, \\mathbf{s} \\rangle + e_i \\pmod{q}$$\n\nwhere each |eᵢ| is small (say, |eᵢ| < q/10).\n\n**Why this is hard**: The small errors prevent direct application of linear algebra. The problem becomes:\n- Given many \"approximate\" linear equations\n- Separate the signal (secret **s**) from the noise (errors **e**)\n- Known attacks require exponential time\n\n**Intuition**: Each equation gives a \"fuzzy hyperplane\" in n-dimensional space. The secret **s** lies near all these hyperplanes, but the noise makes it impossible to locate precisely without exponential search.\n\n**Reductions**: LWE is provably as hard as solving worst-case lattice problems (Regev, 2005). If you can solve LWE efficiently, you can solve SVP for any lattice — giving quantum resistance.\n\n## Part C: NIST Post-Quantum Standards\n\nAfter 8 years of competition, NIST selected (2022-2024):\n\n**For Encryption/Key Exchange**:\n- **CRYSTALS-Kyber** (now standardised as ML-KEM)\n  - Based on: Module Learning With Errors (Module-LWE)\n  - Public key: ~1 KB\n  - Ciphertext: ~1 KB\n  - Security levels: 128, 192, 256-bit equivalent\n  - Performance: Very fast, suitable for TLS\n\n**For Digital Signatures**:\n- **CRYSTALS-Dilithium** (now ML-DSA)\n  - Based on: Module-LWE\n  - Public key: ~1-2 KB\n  - Signature: ~2-4 KB\n  - Fast signing and verification\n\n- **Falcon**\n  - Based on: NTRU lattices\n  - Public key: ~1 KB\n  - Signature: ~700 bytes (smallest signatures)\n  - Slower signing (requires floating-point)\n\n- **SPHINCS+** (now SLH-DSA)\n  - Based on: Hash functions (stateless hash-based signatures)\n  - Public key: ~32-64 bytes (tiny!)\n  - Signature: ~8-50 KB (very large)\n  - Slowest but conservative (only assumes hash functions are secure)\n\n**Trade-offs**:\n\n| Property | Kyber | Dilithium | Falcon | SPHINCS+ |\n|----------|-------|-----------|--------|----------|\n| **Hardness assumption** | Module-LWE | Module-LWE | NTRU | Hash functions |\n| **Key size** | Medium | Medium | Medium | Tiny |\n| **Signature/CT size** | Medium | Large | Small | Huge |\n| **Speed** | Fast | Fast | Medium | Slow |\n| **Simplicity** | Moderate | Moderate | Complex | Simple |\n| **Quantum security** | Strong | Strong | Strong | Strongest |\n\n**NIST's strategy**: Diversify! Different algorithms based on different hard problems, allowing migration if one assumption breaks.\n\n## Part D: Harvest Now, Decrypt Later\n\n**Threat model**: An adversary with resources (e.g., nation-state) can:\n1. **Today**: Record all encrypted internet traffic\n2. **Store it**: Data remains encrypted and unreadable\n3. **Wait**: 10-20 years for large quantum computers\n4. **Decrypt**: Use Shor's algorithm to break RSA/ECC and read historical data\n\n**Vulnerable data**:\n- Government communications\n- Medical records\n- Financial data\n- Trade secrets\n- Personal communications\n\n**Timeline pressure**: Even though large quantum computers don't exist yet, sensitive data encrypted with RSA today is at risk. Once quantum computers arrive, all that stored data becomes readable.\n\n**Migration imperative**: Organisations must migrate to post-quantum cryptography **now**, before quantum computers exist, to protect data being encrypted today.\n\n**Current status (2025)**:\n- Major internet companies deploying post-quantum TLS\n- Governments mandating post-quantum migration timelines\n- Cryptographic libraries implementing NIST standards\n- Hardware accelerators for lattice cryptography in development\n\nThe race is on: will we migrate to quantum-resistant cryptography before quantum computers capable of breaking current encryption are built?\n:::\n","dynamicBlocks",[]]
