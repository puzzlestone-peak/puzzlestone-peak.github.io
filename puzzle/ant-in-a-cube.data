[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","ant-in-a-cube","puzzle",{"_7":8,"_11":12,"_36":37,"_38":39,"_40":41,"_63":64},"metadata",{"_13":14,"_15":16,"_17":18,"_19":22,"_24":25,"_27":28,"_29":30,"_31":32,"_33":34,"_35":34},"id","puzzle-59","title","Ant in a Cube","difficulty",{"_19":20,"_21":20},"concepts","easy","reasoning",[23],"geometry","tags",[26],"has-solution","credit","Classic puzzle. Question and solution written by Puzzlestone Peak.","dateCreated","2026-02-03","lastUpdated","2026-02-04","preview","An ant is at one corner of a cube with side length 1. The exit is a tiny hole on the corner diagonally opposite the ant. What is the length of the shortest...","websitePreview","content","<p>An ant is at one corner of a cube with side length 1. The exit is a tiny hole on the corner diagonally opposite the ant. What is the length of the shortest path the ant can take to the exit? The ant must stay on the surface — it can't fly through the interior.</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><strong>Answer</strong>: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msqrt><mn>5</mn></msqrt></mrow><annotation>\\sqrt{5}</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">5</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span></p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>The ant needs to travel along the surface from corner A to corner G. The trick is to unfold the cube into a flat net — then the shortest path becomes a straight line.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>On the unfolded surface, we can form a right triangle:</p><ul>\n<li>The horizontal distance is 2 (the width of two faces)</li>\n<li>The vertical distance is 1 (the height of one face)</li>\n</ul><p>Using Pythagoras’ theorem: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msqrt><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></msqrt><mo>=</mo><msqrt><mn>5</mn></msqrt></mrow><annotation>\\sqrt{2^2 + 1^2} = \\sqrt{5}</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1266em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9134em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7401em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7401em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span><span style=\"top:-2.8734em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1266em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">5</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span>.</p></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nAn ant is at one corner of a cube with side length 1. The exit is a tiny hole on the corner diagonally opposite the ant. What is the length of the shortest path the ant can take to the exit? The ant must stay on the surface — it can't fly through the interior.\n\n:::dynamic\n```yaml\ntitle: 3D cube showing the ant at corner A and exit at corner G\nuse: '#cube-3d'\nprops:\n  solution: false\n```\n:::\n\n::::solution\n**Answer**: $\\sqrt{5}$\n\n:::dynamic\n```yaml\ntitle: 3D cube showing the ant's path from A to G\nuse: '#cube-3d'\nprops:\n  solution: true\n```\n:::\n\nThe ant needs to travel along the surface from corner A to corner G. The trick is to unfold the cube into a flat net — then the shortest path becomes a straight line.\n\n:::dynamic\n```yaml\ntitle: Cube net diagram showing the ant’s shortest path\nuse: '#cube-net'\n```\n:::\n\nOn the unfolded surface, we can form a right triangle:\n- The horizontal distance is 2 (the width of two faces)\n- The vertical distance is 1 (the height of one face)\n\nUsing Pythagoras’ theorem: $\\sqrt{2^2 + 1^2} = \\sqrt{5}$.\n::::\n\n\n:::component[cube-3d]\n```js\nfunction draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext(\"2d\");\n\n  // Get solution prop (default: false)\n  const showSolution = props?.solution ?? false;\n\n  // Configuration\n  const MAX_SQUARE_SIZE = 125;\n  const LABEL_OFFSET_RATIO = 0.10;\n  const LABEL_TEXT_WIDTH = 10; // approximate width of label text\n\n  // Calculate square size based on available width\n  // Cube diagram: width = squareSize * 1.4 (squareSize + offset where offset = 0.4 * squareSize)\n  // Label space on each side = squareSize * LABEL_OFFSET_RATIO + LABEL_TEXT_WIDTH\n  // Total width = squareSize * 1.4 + 2 * (squareSize * LABEL_OFFSET_RATIO + LABEL_TEXT_WIDTH)\n  // Total width = squareSize * (1.4 + 2 * LABEL_OFFSET_RATIO) + 2 * LABEL_TEXT_WIDTH\n  const widthMultiplier = 1.4 + 2 * LABEL_OFFSET_RATIO;\n  const squareSize = Math.min(MAX_SQUARE_SIZE, (width - 2 * LABEL_TEXT_WIDTH) / widthMultiplier);\n  const offset = squareSize * 0.4; // Offset between front and back squares\n\n  // Calculate actual dimensions\n  const cubeWidth = squareSize + offset;\n  const cubeHeight = squareSize + offset;\n  const labelOffset = squareSize * LABEL_OFFSET_RATIO;\n  const labelSpace = labelOffset + LABEL_TEXT_WIDTH;\n\n  // Canvas size based on actual cube dimensions plus label space\n  canvas.width = cubeWidth + labelSpace * 2;\n  canvas.height = cubeHeight + labelSpace * 2;\n\n  // The cube spans:\n  // - Horizontally: from left edge of front to right edge of back (squareSize + offset)\n  // - Vertically: from bottom of front to top of back (squareSize + offset)\n  // Position front square so entire cube is centered in canvas\n  const frontLeft = labelSpace;\n  const frontBottom = canvas.height - labelSpace;\n\n  // Front square (bottom-left positioned) - contains A\n  const front = {\n    A: { x: frontLeft, y: frontBottom },\n    B: { x: frontLeft + squareSize, y: frontBottom },\n    E: { x: frontLeft, y: frontBottom - squareSize },\n    F: { x: frontLeft + squareSize, y: frontBottom - squareSize }\n  };\n\n  // Back square (top-right positioned) - contains G\n  const back = {\n    D: { x: front.A.x + offset, y: front.A.y - offset },\n    C: { x: front.B.x + offset, y: front.B.y - offset },\n    H: { x: front.E.x + offset, y: front.E.y - offset },\n    G: { x: front.F.x + offset, y: front.F.y - offset }\n  };\n\n  // Get theme colors\n  const edgeColor = api.getColor(\"foreground\");\n  const hiddenEdgeColor = api.getColor(\"muted-foreground\");\n  const pathColor = api.getColor(\"error-500\");\n  const labelColor = api.getColor(\"foreground\");\n\n  // Draw edge helper\n  const drawEdge = (from, to, dashed = false) => {\n    ctx.strokeStyle = dashed ? hiddenEdgeColor : edgeColor;\n    ctx.lineWidth = dashed ? 1.5 : 2;\n    ctx.setLineDash(dashed ? [5, 5] : []);\n    ctx.beginPath();\n    ctx.moveTo(from.x, from.y);\n    ctx.lineTo(to.x, to.y);\n    ctx.stroke();\n  };\n\n  // Draw hidden edges first (dashed)\n  drawEdge(front.A, back.D, true);\n  drawEdge(back.D, back.H, true);\n  drawEdge(back.D, back.C, true);\n\n  // Draw back square (visible edges)\n  drawEdge(front.E, back.H);\n  drawEdge(back.C, back.G);\n  drawEdge(back.H, back.G);\n\n  // Draw front square\n  drawEdge(front.A, front.B);\n  drawEdge(front.B, front.F);\n  drawEdge(front.E, front.F);\n  drawEdge(front.A, front.E);\n\n  // Draw connecting edges (visible)\n  drawEdge(front.B, back.C);\n  drawEdge(front.F, back.G);\n\n  // Draw corner dots\n  const drawDot = (point, radius = 6) => {\n    ctx.fillStyle = pathColor;\n    ctx.beginPath();\n    ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);\n    ctx.fill();\n  };\n  drawDot(front.A);\n  drawDot(back.G);\n\n  // Draw path and labels only when showing solution\n  if (showSolution) {\n    // Draw path: A -> across front face -> across top face -> G\n    // Path goes from A diagonally to midpoint of EF edge, then to G\n    const pathMid = {\n      x: (front.F.x + front.B.x) / 2,\n      y: (front.F.y + front.B.y) / 2\n    };\n\n    ctx.strokeStyle = pathColor;\n    ctx.lineWidth = 3;\n    ctx.setLineDash([]);\n    ctx.beginPath();\n    ctx.moveTo(front.A.x, front.A.y);\n    ctx.lineTo(pathMid.x, pathMid.y);\n    ctx.lineTo(back.G.x, back.G.y);\n    ctx.stroke();\n\n    // Draw labels (labelOffset already defined above)\n    ctx.font = \"bold 14px system-ui, sans-serif\";\n    ctx.fillStyle = labelColor;\n    ctx.textBaseline = \"middle\";\n\n    // Label offset map (similar to hypercube-viz pattern)\n    const labels = {\n      A: { point: front.A, x: -labelOffset, y: labelOffset, align: \"right\" },\n      B: { point: front.B, x: labelOffset * 0.8, y: labelOffset * 0.8, align: \"left\" },\n      E: { point: front.E, x: -labelOffset * 0.8, y: -labelOffset * 0.7, align: \"right\" },\n      F: { point: front.F, x: labelOffset * 0.7, y: labelOffset * 0.3, align: \"left\" },\n      D: { point: back.D, x: labelOffset * 0.8, y: -labelOffset * 0.8, align: \"left\" },\n      C: { point: back.C, x: labelOffset * 0.8, y: labelOffset * 0.8, align: \"left\" },\n      H: { point: back.H, x: -labelOffset * 0.8, y: -labelOffset * 0.7, align: \"right\" },\n      G: { point: back.G, x: labelOffset * 0.8, y: -labelOffset * 0.7, align: \"left\" }\n    };\n\n    Object.entries(labels).forEach(([label, config]) => {\n      ctx.textAlign = config.align;\n      ctx.fillText(label, config.point.x + config.x, config.point.y + config.y);\n    });\n  }\n\n}\n```\n:::\n\n:::component[cube-net]\n```js\nfunction draw(options) {\n  const { canvas, api, width } = options;\n  const ctx = canvas.getContext('2d');\n\n  // Padding for labels around the net\n  const labelPadding = 20;\n  const strokeWidth = 2;\n\n  // Calculate dimensions - cube net is 4 units wide, 3 units tall\n  const netWidth = 4;\n  const netHeight = 3;\n  const aspectRatio = netHeight / netWidth;\n\n  // Max size of 300px (for the net content, excluding padding)\n  const contentSize = Math.min(width - labelPadding * 2, 300);\n  const contentHeight = contentSize * aspectRatio;\n\n  canvas.width = contentSize + labelPadding * 2;\n  canvas.height = contentHeight + labelPadding * 2;\n\n  // Calculate unit size (each square face is 1×1 unit)\n  const unit = contentSize / netWidth;\n\n  // Offset all drawing by padding so labels have room\n  ctx.translate(labelPadding, labelPadding);\n\n  // Get theme colors\n  const faceColor = api.getColor('muted');\n  const borderColor = api.getColor('foreground');\n  const pathColor = api.getColor('error-500');\n\n  // Helper function to draw a square face (no label)\n  const drawFace = (x, y) => {\n    ctx.fillStyle = faceColor;\n    ctx.fillRect(x, y, unit, unit);\n\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeRect(x, y, unit, unit);\n  };\n\n  // Draw cube net in cross formation\n  drawFace(unit * 1, unit * 0);  // TOP\n  drawFace(unit * 0, unit * 1);  // LEFT\n  drawFace(unit * 1, unit * 1);  // FRONT\n  drawFace(unit * 2, unit * 1);  // RIGHT\n  drawFace(unit * 3, unit * 1);  // BACK\n  drawFace(unit * 1, unit * 2);  // BOTTOM\n\n  // Point A: bottom-left corner of FRONT face\n  const pointA = {\n    x: unit * 1,\n    y: unit * 2\n  };\n\n  // Point B: top-right corner of TOP face\n  const pointB = {\n    x: unit * 3,\n    y: unit * 1\n  };\n\n  // Draw the path (straight line from A to G)\n  ctx.strokeStyle = pathColor;\n  ctx.lineWidth = 3;\n  ctx.setLineDash([]);\n  ctx.beginPath();\n  ctx.moveTo(pointA.x, pointA.y);\n  ctx.lineTo(pointB.x, pointB.y);\n  ctx.stroke();\n\n  // Draw endpoint dots\n  const dotRadius = 5;\n  ctx.fillStyle = pathColor;\n  ctx.beginPath();\n  ctx.arc(pointA.x, pointA.y, dotRadius, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.beginPath();\n  ctx.arc(pointB.x, pointB.y, dotRadius, 0, Math.PI * 2);\n  ctx.fill();\n\n  // Draw vertex labels\n  const labelColor = api.getColor('foreground');\n  const labelOffset = 8;\n  ctx.font = \"bold 14px system-ui, sans-serif\";\n  ctx.fillStyle = labelColor;\n\n  // Vertices with position offsets and alignment (both horizontal and vertical)\n  // align: \"left\" | \"center\" | \"right\", baseline: \"top\" | \"middle\" | \"bottom\"\n  const vertices = [\n    // FRONT face corners\n    { label: \"A\", x: unit * 1, y: unit * 2, labelX: -labelOffset, labelY: labelOffset, align: \"right\", baseline: \"top\" },\n    { label: \"B\", x: unit * 2, y: unit * 2, labelX: labelOffset, labelY: labelOffset, align: \"left\", baseline: \"top\" },\n    { label: \"E\", x: unit * 1, y: unit * 1, labelX: -labelOffset, labelY: -labelOffset * 0.7, align: \"right\", baseline: \"bottom\" },\n    { label: \"F\", x: unit * 2, y: unit * 1, labelX: labelOffset, labelY: -labelOffset * 0.7, align: \"left\", baseline: \"bottom\" },\n    // TOP face - top corners\n    { label: \"H\", x: unit * 1, y: unit * 0, labelX: -labelOffset, labelY: 0, align: \"right\", baseline: \"bottom\" },\n    { label: \"G\", x: unit * 2, y: unit * 0, labelX: labelOffset, labelY: 0, align: \"left\", baseline: \"bottom\" },\n    // BOTTOM face - bottom corners\n    { label: \"D\", x: unit * 1, y: unit * 3, labelX: -labelOffset, labelY: 0, align: \"right\", baseline: \"top\" },\n    { label: \"C\", x: unit * 2, y: unit * 3, labelX: labelOffset, labelY: 0, align: \"left\", baseline: \"top\" },\n    // RIGHT face - right corners\n    { label: \"C\", x: unit * 3, y: unit * 2, labelX: 0, labelY: labelOffset, align: \"center\", baseline: \"top\" },\n    { label: \"G\", x: unit * 3, y: unit * 1, labelX: 0, labelY: -labelOffset * 0.7, align: \"center\", baseline: \"bottom\" },\n    // LEFT face - left corners\n    { label: \"H\", x: unit * 0, y: unit * 1, labelX: -labelOffset, labelY: -labelOffset * 0.7, align: \"right\", baseline: \"bottom\" },\n    { label: \"D\", x: unit * 0, y: unit * 2, labelX: -labelOffset, labelY: labelOffset, align: \"right\", baseline: \"top\" },\n    // Back face - right corners\n    { label: \"H\", x: unit * 4, y: unit * 1, labelX: 0, labelY: -labelOffset * 0.7, align: \"center\", baseline: \"bottom\" },\n    { label: \"D\", x: unit * 4, y: unit * 2, labelX: 0, labelY: labelOffset, align: \"center\", baseline: \"top\" },\n  ];\n\n  vertices.forEach((v) => {\n    ctx.textAlign = v.align;\n    ctx.textBaseline = v.baseline;\n    ctx.fillText(v.label, v.x + v.labelX, v.y + v.labelY);\n  });\n}\n```\n:::","dynamicBlocks",[42,56,60],{"_43":44,"_45":46,"_47":48,"_49":50,"_15":53,"_54":55},"type","dynamic","mode","component","componentId","#cube-3d","props",{"_51":52},"solution",false,"3D cube showing the ant at corner A and exit at corner G","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/ant-in-a-cube.md",{"_43":44,"_45":46,"_47":48,"_49":57,"_15":59,"_54":55},{"_51":58},true,"3D cube showing the ant's path from A to G",{"_43":44,"_45":46,"_47":61,"_15":62,"_54":55},"#cube-net","Cube net diagram showing the ant’s shortest path","inlineComponents",{"_65":66,"_71":72},"cube-3d",{"_13":65,"_67":68,"_69":70},"code","function draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext(\"2d\");\n\n  // Get solution prop (default: false)\n  const showSolution = props?.solution ?? false;\n\n  // Configuration\n  const MAX_SQUARE_SIZE = 125;\n  const LABEL_OFFSET_RATIO = 0.10;\n  const LABEL_TEXT_WIDTH = 10; // approximate width of label text\n\n  // Calculate square size based on available width\n  // Cube diagram: width = squareSize * 1.4 (squareSize + offset where offset = 0.4 * squareSize)\n  // Label space on each side = squareSize * LABEL_OFFSET_RATIO + LABEL_TEXT_WIDTH\n  // Total width = squareSize * 1.4 + 2 * (squareSize * LABEL_OFFSET_RATIO + LABEL_TEXT_WIDTH)\n  // Total width = squareSize * (1.4 + 2 * LABEL_OFFSET_RATIO) + 2 * LABEL_TEXT_WIDTH\n  const widthMultiplier = 1.4 + 2 * LABEL_OFFSET_RATIO;\n  const squareSize = Math.min(MAX_SQUARE_SIZE, (width - 2 * LABEL_TEXT_WIDTH) / widthMultiplier);\n  const offset = squareSize * 0.4; // Offset between front and back squares\n\n  // Calculate actual dimensions\n  const cubeWidth = squareSize + offset;\n  const cubeHeight = squareSize + offset;\n  const labelOffset = squareSize * LABEL_OFFSET_RATIO;\n  const labelSpace = labelOffset + LABEL_TEXT_WIDTH;\n\n  // Canvas size based on actual cube dimensions plus label space\n  canvas.width = cubeWidth + labelSpace * 2;\n  canvas.height = cubeHeight + labelSpace * 2;\n\n  // The cube spans:\n  // - Horizontally: from left edge of front to right edge of back (squareSize + offset)\n  // - Vertically: from bottom of front to top of back (squareSize + offset)\n  // Position front square so entire cube is centered in canvas\n  const frontLeft = labelSpace;\n  const frontBottom = canvas.height - labelSpace;\n\n  // Front square (bottom-left positioned) - contains A\n  const front = {\n    A: { x: frontLeft, y: frontBottom },\n    B: { x: frontLeft + squareSize, y: frontBottom },\n    E: { x: frontLeft, y: frontBottom - squareSize },\n    F: { x: frontLeft + squareSize, y: frontBottom - squareSize }\n  };\n\n  // Back square (top-right positioned) - contains G\n  const back = {\n    D: { x: front.A.x + offset, y: front.A.y - offset },\n    C: { x: front.B.x + offset, y: front.B.y - offset },\n    H: { x: front.E.x + offset, y: front.E.y - offset },\n    G: { x: front.F.x + offset, y: front.F.y - offset }\n  };\n\n  // Get theme colors\n  const edgeColor = api.getColor(\"foreground\");\n  const hiddenEdgeColor = api.getColor(\"muted-foreground\");\n  const pathColor = api.getColor(\"error-500\");\n  const labelColor = api.getColor(\"foreground\");\n\n  // Draw edge helper\n  const drawEdge = (from, to, dashed = false) => {\n    ctx.strokeStyle = dashed ? hiddenEdgeColor : edgeColor;\n    ctx.lineWidth = dashed ? 1.5 : 2;\n    ctx.setLineDash(dashed ? [5, 5] : []);\n    ctx.beginPath();\n    ctx.moveTo(from.x, from.y);\n    ctx.lineTo(to.x, to.y);\n    ctx.stroke();\n  };\n\n  // Draw hidden edges first (dashed)\n  drawEdge(front.A, back.D, true);\n  drawEdge(back.D, back.H, true);\n  drawEdge(back.D, back.C, true);\n\n  // Draw back square (visible edges)\n  drawEdge(front.E, back.H);\n  drawEdge(back.C, back.G);\n  drawEdge(back.H, back.G);\n\n  // Draw front square\n  drawEdge(front.A, front.B);\n  drawEdge(front.B, front.F);\n  drawEdge(front.E, front.F);\n  drawEdge(front.A, front.E);\n\n  // Draw connecting edges (visible)\n  drawEdge(front.B, back.C);\n  drawEdge(front.F, back.G);\n\n  // Draw corner dots\n  const drawDot = (point, radius = 6) => {\n    ctx.fillStyle = pathColor;\n    ctx.beginPath();\n    ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);\n    ctx.fill();\n  };\n  drawDot(front.A);\n  drawDot(back.G);\n\n  // Draw path and labels only when showing solution\n  if (showSolution) {\n    // Draw path: A -> across front face -> across top face -> G\n    // Path goes from A diagonally to midpoint of EF edge, then to G\n    const pathMid = {\n      x: (front.F.x + front.B.x) / 2,\n      y: (front.F.y + front.B.y) / 2\n    };\n\n    ctx.strokeStyle = pathColor;\n    ctx.lineWidth = 3;\n    ctx.setLineDash([]);\n    ctx.beginPath();\n    ctx.moveTo(front.A.x, front.A.y);\n    ctx.lineTo(pathMid.x, pathMid.y);\n    ctx.lineTo(back.G.x, back.G.y);\n    ctx.stroke();\n\n    // Draw labels (labelOffset already defined above)\n    ctx.font = \"bold 14px system-ui, sans-serif\";\n    ctx.fillStyle = labelColor;\n    ctx.textBaseline = \"middle\";\n\n    // Label offset map (similar to hypercube-viz pattern)\n    const labels = {\n      A: { point: front.A, x: -labelOffset, y: labelOffset, align: \"right\" },\n      B: { point: front.B, x: labelOffset * 0.8, y: labelOffset * 0.8, align: \"left\" },\n      E: { point: front.E, x: -labelOffset * 0.8, y: -labelOffset * 0.7, align: \"right\" },\n      F: { point: front.F, x: labelOffset * 0.7, y: labelOffset * 0.3, align: \"left\" },\n      D: { point: back.D, x: labelOffset * 0.8, y: -labelOffset * 0.8, align: \"left\" },\n      C: { point: back.C, x: labelOffset * 0.8, y: labelOffset * 0.8, align: \"left\" },\n      H: { point: back.H, x: -labelOffset * 0.8, y: -labelOffset * 0.7, align: \"right\" },\n      G: { point: back.G, x: labelOffset * 0.8, y: -labelOffset * 0.7, align: \"left\" }\n    };\n\n    Object.entries(labels).forEach(([label, config]) => {\n      ctx.textAlign = config.align;\n      ctx.fillText(label, config.point.x + config.x, config.point.y + config.y);\n    });\n  }\n\n}","startLine",58,"cube-net",{"_13":71,"_67":73,"_69":74},"function draw(options) {\n  const { canvas, api, width } = options;\n  const ctx = canvas.getContext('2d');\n\n  // Padding for labels around the net\n  const labelPadding = 20;\n  const strokeWidth = 2;\n\n  // Calculate dimensions - cube net is 4 units wide, 3 units tall\n  const netWidth = 4;\n  const netHeight = 3;\n  const aspectRatio = netHeight / netWidth;\n\n  // Max size of 300px (for the net content, excluding padding)\n  const contentSize = Math.min(width - labelPadding * 2, 300);\n  const contentHeight = contentSize * aspectRatio;\n\n  canvas.width = contentSize + labelPadding * 2;\n  canvas.height = contentHeight + labelPadding * 2;\n\n  // Calculate unit size (each square face is 1×1 unit)\n  const unit = contentSize / netWidth;\n\n  // Offset all drawing by padding so labels have room\n  ctx.translate(labelPadding, labelPadding);\n\n  // Get theme colors\n  const faceColor = api.getColor('muted');\n  const borderColor = api.getColor('foreground');\n  const pathColor = api.getColor('error-500');\n\n  // Helper function to draw a square face (no label)\n  const drawFace = (x, y) => {\n    ctx.fillStyle = faceColor;\n    ctx.fillRect(x, y, unit, unit);\n\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeRect(x, y, unit, unit);\n  };\n\n  // Draw cube net in cross formation\n  drawFace(unit * 1, unit * 0);  // TOP\n  drawFace(unit * 0, unit * 1);  // LEFT\n  drawFace(unit * 1, unit * 1);  // FRONT\n  drawFace(unit * 2, unit * 1);  // RIGHT\n  drawFace(unit * 3, unit * 1);  // BACK\n  drawFace(unit * 1, unit * 2);  // BOTTOM\n\n  // Point A: bottom-left corner of FRONT face\n  const pointA = {\n    x: unit * 1,\n    y: unit * 2\n  };\n\n  // Point B: top-right corner of TOP face\n  const pointB = {\n    x: unit * 3,\n    y: unit * 1\n  };\n\n  // Draw the path (straight line from A to G)\n  ctx.strokeStyle = pathColor;\n  ctx.lineWidth = 3;\n  ctx.setLineDash([]);\n  ctx.beginPath();\n  ctx.moveTo(pointA.x, pointA.y);\n  ctx.lineTo(pointB.x, pointB.y);\n  ctx.stroke();\n\n  // Draw endpoint dots\n  const dotRadius = 5;\n  ctx.fillStyle = pathColor;\n  ctx.beginPath();\n  ctx.arc(pointA.x, pointA.y, dotRadius, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.beginPath();\n  ctx.arc(pointB.x, pointB.y, dotRadius, 0, Math.PI * 2);\n  ctx.fill();\n\n  // Draw vertex labels\n  const labelColor = api.getColor('foreground');\n  const labelOffset = 8;\n  ctx.font = \"bold 14px system-ui, sans-serif\";\n  ctx.fillStyle = labelColor;\n\n  // Vertices with position offsets and alignment (both horizontal and vertical)\n  // align: \"left\" | \"center\" | \"right\", baseline: \"top\" | \"middle\" | \"bottom\"\n  const vertices = [\n    // FRONT face corners\n    { label: \"A\", x: unit * 1, y: unit * 2, labelX: -labelOffset, labelY: labelOffset, align: \"right\", baseline: \"top\" },\n    { label: \"B\", x: unit * 2, y: unit * 2, labelX: labelOffset, labelY: labelOffset, align: \"left\", baseline: \"top\" },\n    { label: \"E\", x: unit * 1, y: unit * 1, labelX: -labelOffset, labelY: -labelOffset * 0.7, align: \"right\", baseline: \"bottom\" },\n    { label: \"F\", x: unit * 2, y: unit * 1, labelX: labelOffset, labelY: -labelOffset * 0.7, align: \"left\", baseline: \"bottom\" },\n    // TOP face - top corners\n    { label: \"H\", x: unit * 1, y: unit * 0, labelX: -labelOffset, labelY: 0, align: \"right\", baseline: \"bottom\" },\n    { label: \"G\", x: unit * 2, y: unit * 0, labelX: labelOffset, labelY: 0, align: \"left\", baseline: \"bottom\" },\n    // BOTTOM face - bottom corners\n    { label: \"D\", x: unit * 1, y: unit * 3, labelX: -labelOffset, labelY: 0, align: \"right\", baseline: \"top\" },\n    { label: \"C\", x: unit * 2, y: unit * 3, labelX: labelOffset, labelY: 0, align: \"left\", baseline: \"top\" },\n    // RIGHT face - right corners\n    { label: \"C\", x: unit * 3, y: unit * 2, labelX: 0, labelY: labelOffset, align: \"center\", baseline: \"top\" },\n    { label: \"G\", x: unit * 3, y: unit * 1, labelX: 0, labelY: -labelOffset * 0.7, align: \"center\", baseline: \"bottom\" },\n    // LEFT face - left corners\n    { label: \"H\", x: unit * 0, y: unit * 1, labelX: -labelOffset, labelY: -labelOffset * 0.7, align: \"right\", baseline: \"bottom\" },\n    { label: \"D\", x: unit * 0, y: unit * 2, labelX: -labelOffset, labelY: labelOffset, align: \"right\", baseline: \"top\" },\n    // Back face - right corners\n    { label: \"H\", x: unit * 4, y: unit * 1, labelX: 0, labelY: -labelOffset * 0.7, align: \"center\", baseline: \"bottom\" },\n    { label: \"D\", x: unit * 4, y: unit * 2, labelX: 0, labelY: labelOffset, align: \"center\", baseline: \"top\" },\n  ];\n\n  vertices.forEach((v) => {\n    ctx.textAlign = v.align;\n    ctx.textBaseline = v.baseline;\n    ctx.fillText(v.label, v.x + v.labelX, v.y + v.labelY);\n  });\n}",206]
