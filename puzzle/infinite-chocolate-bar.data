[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","infinite-chocolate-bar","puzzle",{"_7":8,"_11":12,"_37":38,"_39":40,"_41":42,"_64":65},"metadata",{"_13":14,"_15":16,"_17":18,"_22":23,"_24":23,"_25":26,"_19":27,"_29":30,"_32":33,"_34":35,"_36":35},"id","puzzle-72","title","The Infinite Chocolate Bar","difficulty",{"_19":20,"_21":20},"concepts","easy","reasoning","dateCreated","2026-02-06","lastUpdated","previousPuzzle","vanishing-square",[28],"geometry","tags",[31],"has-solution","credit","Classic puzzle. Question and solution written by Puzzlestone Peak.\n","preview","A chocolate bar is cut into five pieces: a small square, a rectangle, two diagonal slope pieces, and a large base piece. We rearrange the pieces, reforming the...","websitePreview","content","<p>A chocolate bar is cut into five pieces: a small square, a rectangle, two diagonal slope pieces, and a large base piece. We rearrange the pieces, reforming the original chocolate bar with an addition square piece. Can you explain what’s really happening here?</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>You can step through the animation below. See if you can spot the trick!</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><strong>Answer</strong>: What the animation cleverly hides is a subtle increase in the height of both slanted pieces.</p><p>The trick lies in the gradual expansion of the diagonal pieces during the rearrangement:</p><ul>\n<li><strong>Narrow slope piece</strong>: Originally 2.3 units tall at its left edge, it quietly expands to 2.5 units during the animation</li>\n<li><strong>Wide slope piece</strong>: Originally 2.5 units tall at its left edge, it quietly expands to 2.7 units during the animation</li>\n</ul><p>Each of these two slanted pieces increases by exactly 0.2 units in height. Since the chocolate bar is 5 units wide, this expansion accounts for precisely 0.2 × 5 = 1 square unit—the exact area of the “vanished” square.</p><p>Watch the animation below without the trick—the pieces maintain their original dimensions, and a grid overlay reveals what’s really happening:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>You can see that without the subtle expansion, the chocolate bar ends up with an actual gap where the removed square used to be.</p></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nA chocolate bar is cut into five pieces: a small square, a rectangle, two diagonal slope pieces, and a large base piece. We rearrange the pieces, reforming the original chocolate bar with an addition square piece. Can you explain what’s really happening here?\n\n:::dynamic\n```yaml\ntitle: \"Chocolate bar puzzle—where does the square go?\"\nuse: '#diagram'\nprops:\n  mode: question\n```\n:::\n\n::::hint\nYou can step through the animation below. See if you can spot the trick!\n\n:::dynamic\n```yaml\ntitle: \"Step through the animation\"\nuse: '#diagram'\nprops:\n  mode: hint\n```\n:::\n::::\n\n::::solution\n**Answer**: What the animation cleverly hides is a subtle increase in the height of both slanted pieces.\n\nThe trick lies in the gradual expansion of the diagonal pieces during the rearrangement:\n\n- **Narrow slope piece**: Originally 2.3 units tall at its left edge, it quietly expands to 2.5 units during the animation\n- **Wide slope piece**: Originally 2.5 units tall at its left edge, it quietly expands to 2.7 units during the animation\n\nEach of these two slanted pieces increases by exactly 0.2 units in height. Since the chocolate bar is 5 units wide, this expansion accounts for precisely 0.2 × 5 = 1 square unit—the exact area of the “vanished” square.\n\nWatch the animation below without the trick—the pieces maintain their original dimensions, and a grid overlay reveals what’s really happening:\n\n:::dynamic\n```yaml\ntitle: \"Animation without the trick (with grid overlay)\"\nuse: '#diagram'\nprops:\n  mode: solution\n```\n:::\n\nYou can see that without the subtle expansion, the chocolate bar ends up with an actual gap where the removed square used to be.\n::::\n\n:::component[diagram]\n\n```yaml\nmode: dom\ntitle: \"Chocolate bar diagram\"\n```\n\n```js\n// Chocolate rectangle aspect ratio (width/height)\nconst CHOCOLATE_ASPECT_RATIO = 3 / 4;\n\n// Grid dimensions for the chocolate bar\nconst GRID_COLS = 5;\nconst GRID_ROWS = 5;\n\n// Diagram grid dimensions (from Step 3)\nconst DIAGRAM_GRID_WIDTH = 8;\nconst DIAGRAM_GRID_HEIGHT = 8;\n\n// Offset to position pieces in the diagram (from Step 3: OFFSETS: X=3, Y=3)\nconst OFFSET_X = 3;\nconst OFFSET_Y = 3;\n\n// Animation duration in seconds\nconst ANIMATION_DURATION = 5;\n\n// Piece definitions (coordinates in grid units)\nconst PIECES = {\n  square: [[0, 0], [1, 0], [1, 1], [0, 1]],\n  rectangle: [[0, 0], [2, 0], [2, 1], [0, 1]],\n  narrowSlope: [[0, 0], [2, 0], [2, 1.5], [0, 2.3]],\n  wideSlope: [[0, 0], [3, 0], [3, 1.3], [0, 2.5]],\n  base: [[0, 2.5], [5, 0.5], [5, 4], [0, 4]]\n};\n\n// \"Tricked\" piece shapes (subtly expanded during the illusion)\nconst PIECES_TRICKED = {\n  narrowSlope: [[0, 0], [2, 0], [2, 1.7], [0, 2.5]],\n  wideSlope: [[0, 0], [3, 0], [3, 1.5], [0, 2.7]]\n};\n\n// Animation keyframes: [time in seconds, { piece: [x, y], ... }]\n// Positions are relative to top-left of piece, before adding OFFSET\nconst KEYFRAMES = [\n  [0, {\n    square: [0, 0],\n    rectangle: [1, 0],\n    narrowSlope: [3, 0],\n    wideSlope: [0, 1],\n    base: [0, 1]\n  }],\n  [1, {\n    square: [-2, -1.5],\n    rectangle: [-3, 0],\n    narrowSlope: [3, -3],\n    wideSlope: [0, 0.8],\n    base: [0, 1]\n  }],\n  [2, {\n    square: [-2, -1.5],\n    rectangle: [-3, 0],\n    narrowSlope: [0, -3],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }],\n  [3, {\n    square: [-2, -1.5],\n    rectangle: [-3, 0],\n    narrowSlope: [0, 1],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }],\n  [4, {\n    square: [-2, -1.5],\n    rectangle: [0, 0],\n    narrowSlope: [0, 1],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }],\n  [5, {\n    square: [-4.01, -1.5],\n    rectangle: [0, 0],\n    narrowSlope: [0, 1],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }]\n];\n\nfunction mount(options) {\n  const { root, api, props } = options;\n\n  try {\n    const mode = props.mode;\n\n    const canvas = document.createElement('canvas');\n    canvas.style.display = 'block';\n    canvas.style.margin = '0 auto';\n    root.appendChild(canvas);\n\n    // Animation state\n    let animationId = null;\n    let startTime = null;\n    let isPaused = false;\n    let currentTime = 0;\n    let lastTimestamp = null;\n\n    // Determine if we should use trick based on mode\n    const useTrick = mode !== 'solution';\n\n    const draw = (time) => {\n      drawAnimatedPieces(canvas, api, time, useTrick, mode === 'solution');\n    };\n\n    // Create controls for hint and solution modes\n    if (mode === 'hint' || mode === 'solution') {\n      const controlsContainer = document.createElement('div');\n      controlsContainer.className = api.css('flex items-center justify-center gap-2 mt-4');\n\n      // Back button\n      const backBtn = api.ui.button({\n        label: '← Back',\n        variant: 'outlined',\n        size: 'sm',\n        onClick: () => {\n          currentTime = currentTime - 0.2;\n          if (currentTime < 0) currentTime += ANIMATION_DURATION;\n          draw(currentTime);\n        }\n      });\n      backBtn.style.width = '100px';\n\n      // Pause/Play button\n      const playPauseBtn = api.ui.button({\n        label: isPaused ? '▶ Play' : '⏸ Pause',\n        variant: 'contained',\n        size: 'sm',\n        onClick: () => {\n          isPaused = !isPaused;\n          playPauseBtn.textContent = isPaused ? '▶ Play' : '⏸ Pause';\n        }\n      });\n      playPauseBtn.style.width = '100px';\n\n      // Forward button\n      const forwardBtn = api.ui.button({\n        label: 'Forward →',\n        variant: 'outlined',\n        size: 'sm',\n        onClick: () => {\n          currentTime = (currentTime + 0.2) % ANIMATION_DURATION;\n          draw(currentTime);\n        }\n      });\n      forwardBtn.style.width = '100px';\n\n      controlsContainer.appendChild(backBtn);\n      controlsContainer.appendChild(playPauseBtn);\n      controlsContainer.appendChild(forwardBtn);\n\n      root.appendChild(controlsContainer);\n    }\n\n    // Animation loop for all modes\n    const animate = (timestamp) => {\n      if (isPaused) {\n        lastTimestamp = timestamp;\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n\n      if (!lastTimestamp) lastTimestamp = timestamp;\n      const deltaTime = (timestamp - lastTimestamp) / 1000;\n      lastTimestamp = timestamp;\n\n      currentTime += deltaTime;\n\n      // Loop animation for question mode, or if controls are present\n      if (mode === 'question' || mode === 'hint' || mode === 'solution') {\n        currentTime = currentTime % ANIMATION_DURATION;\n      }\n\n      draw(currentTime);\n\n      animationId = requestAnimationFrame(animate);\n    };\n\n    // Initial draw\n    draw(currentTime);\n\n    // Start animation\n    animationId = requestAnimationFrame(animate);\n\n    // Redraw on theme change\n    api.onThemeChange(() => {\n      draw(currentTime);\n    });\n\n    // Handle resize\n    api.onResize(() => {\n      draw(currentTime);\n    });\n\n  } catch (error) {\n    console.error('[Chocolate Bar Error]', error);\n    root.textContent = 'An error occurred rendering the chocolate bar. Check the console.';\n  }\n}\n\n// Interpolate between two values\nfunction lerp(a, b, t) {\n  return a + (b - a) * t;\n}\n\n// Get interpolated positions for a given time\nfunction getPositionsAtTime(time, useTrick = true) {\n  // Find surrounding keyframes\n  let prevFrame = KEYFRAMES[0];\n  let nextFrame = KEYFRAMES[KEYFRAMES.length - 1];\n\n  for (let i = 0; i < KEYFRAMES.length - 1; i++) {\n    if (time >= KEYFRAMES[i][0] && time <= KEYFRAMES[i + 1][0]) {\n      prevFrame = KEYFRAMES[i];\n      nextFrame = KEYFRAMES[i + 1];\n      break;\n    }\n  }\n\n  const [prevTime, prevPositions] = prevFrame;\n  const [nextTime, nextPositions] = nextFrame;\n\n  // Calculate interpolation factor\n  const duration = nextTime - prevTime;\n  const t = duration > 0 ? (time - prevTime) / duration : 0;\n\n  // Interpolate each piece position\n  const positions = {};\n  for (const piece of Object.keys(prevPositions)) {\n    positions[piece] = [\n      lerp(prevPositions[piece][0], nextPositions[piece][0], t),\n      lerp(prevPositions[piece][1], nextPositions[piece][1], t)\n    ];\n  }\n\n  // Determine which piece shapes to use\n  // Wide slope morphs between seconds 1-2 (at keyframe 2)\n  // Narrow slope morphs between seconds 2-3 (at keyframe 3)\n  let pieces = { ...PIECES };\n  if (useTrick) {\n    // Wide slope: morph between 1-2 seconds\n    if (time >= 1 && time <= 2) {\n      const morphT = time - 1;\n      pieces.wideSlope = interpolatePiece(PIECES.wideSlope, PIECES_TRICKED.wideSlope, morphT);\n    } else if (time > 2) {\n      pieces.wideSlope = PIECES_TRICKED.wideSlope;\n    }\n\n    // Narrow slope: morph between 2-3 seconds\n    if (time >= 2 && time <= 3) {\n      const morphT = time - 2;\n      pieces.narrowSlope = interpolatePiece(PIECES.narrowSlope, PIECES_TRICKED.narrowSlope, morphT);\n    } else if (time > 3) {\n      pieces.narrowSlope = PIECES_TRICKED.narrowSlope;\n    }\n  }\n\n  return { positions, pieces };\n}\n\n// Interpolate piece shape coordinates\nfunction interpolatePiece(pieceA, pieceB, t) {\n  return pieceA.map((pointA, i) => {\n    const pointB = pieceB[i];\n    return [lerp(pointA[0], pointB[0], t), lerp(pointA[1], pointB[1], t)];\n  });\n}\n\n// Determine which pieces to skip and what solid mask to use for gap prevention\nfunction getGapPreventionConfig(time, useTrick) {\n  // Check for exact 0 second frame (stationary start)\n  if (time === 0) {\n    return {\n      skipPieces: ['square', 'rectangle', 'narrowSlope', 'wideSlope', 'base'],\n      solidMask: [[0, 0], [5, 0], [5, 4], [0, 4]]\n    };\n  }\n\n  if (useTrick) {\n    // CONCEALING THE TRICK optimizations\n    if (time >= 2 && time < 3) {\n      // 2 to 3 second frames: pieces are settling into new positions\n      return {\n        skipPieces: ['base', 'wideSlope'],\n        solidMask: [[2, 0], [5, 0], [5, 5], [0, 5], [0, 3.5], [2, 2.7]]\n      };\n    }\n    if (time >= 3 && time < 4) {\n      // 3 to 4 second frames: narrow slope has settled\n      return {\n        skipPieces: ['base', 'wideSlope', 'narrowSlope'],\n        solidMask: [[2, 0], [5, 0], [5, 5], [0, 5], [0, 1], [2, 1]]\n      };\n    }\n    if (time >= 4 && time <= 5) {\n      // 4 to 5 second frames: all pieces in final position\n      return {\n        skipPieces: ['rectangle', 'narrowSlope', 'wideSlope', 'base'],\n        solidMask: [[0, 0], [5, 0], [5, 5], [0, 5]]\n      };\n    }\n  } else {\n    // NOT CONCEALING THE TRICK optimizations\n    if (time >= 3 && time < 4) {\n      // 3 to 4 second frames: slopes have settled but with true shapes\n      return {\n        skipPieces: ['wideSlope', 'narrowSlope'],\n        solidMask: [[2, 0], [5, 0], [5, 1.3], [0, 3.3], [0, 1], [2, 1]]\n      };\n    }\n    if (time >= 4 && time <= 5) {\n      // 4 to 5 second frames: rectangle has returned\n      return {\n        skipPieces: ['rectangle', 'narrowSlope', 'wideSlope'],\n        solidMask: [[0, 0], [5, 0], [5, 1.3], [0, 3.3]]\n      };\n    }\n  }\n\n  // No gap prevention needed\n  return null;\n}\n\n// Draw the animated pieces\nfunction drawAnimatedPieces(canvas, api, time, useTrick = true, showGrid = false) {\n  if (api.size.width === 0) {\n    return;\n  }\n\n  const ctx = canvas.getContext('2d');\n\n  // Calculate dimensions\n  const maxWidth = Math.min(api.size.width, 300);\n  if (maxWidth <= 0) return;\n\n  const rectWidth = maxWidth / DIAGRAM_GRID_WIDTH;\n  const rectHeight = rectWidth / CHOCOLATE_ASPECT_RATIO;\n\n  const canvasWidth = rectWidth * DIAGRAM_GRID_WIDTH;\n  const canvasHeight = rectHeight * DIAGRAM_GRID_HEIGHT;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Clear canvas\n  ctx.fillStyle = api.getColor('background');\n  ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\n  // Get theme-aware chocolate colors\n  const isDark = api.theme === 'dark';\n  const baseColor = isDark ? api.getColor('#a16944') : api.getColor('#622c06');\n  const lightColor = isDark ? api.getColor('#c4916b') : api.getColor('#7b3f10');\n  const darkColor = isDark ? api.getColor('#6d3e1a') : api.getColor('#3b1d07');\n\n  const borderWidth = rectWidth * (10 / 80);\n\n  // Create the chocolate bar source canvas\n  const chocolateCanvas = createChocolateBarCanvas(rectWidth, rectHeight, borderWidth, baseColor, lightColor, darkColor);\n\n  // Get interpolated positions and piece shapes\n  const { positions, pieces } = getPositionsAtTime(time, useTrick);\n\n  // Check for gap prevention optimization\n  const gapConfig = getGapPreventionConfig(time, useTrick);\n\n  // Draw pieces in order (base first, then others on top)\n  const drawOrder = ['base', 'wideSlope', 'narrowSlope', 'rectangle', 'square'];\n\n  // If we have gap prevention, draw solid mask first, then remaining pieces\n  if (gapConfig) {\n    // Draw the solid chocolate bar with clipping mask at the standard position\n    const solidDestX = OFFSET_X * rectWidth;\n    const solidDestY = OFFSET_Y * rectHeight;\n    drawPieceWithMask(ctx, chocolateCanvas, gapConfig.solidMask, rectWidth, rectHeight, solidDestX, solidDestY);\n\n    // Draw only the pieces that are NOT skipped\n    for (const pieceName of drawOrder) {\n      if (gapConfig.skipPieces.includes(pieceName)) continue;\n      const pos = positions[pieceName];\n      const piece = pieces[pieceName];\n      const destX = (pos[0] + OFFSET_X) * rectWidth;\n      const destY = (pos[1] + OFFSET_Y) * rectHeight;\n      drawPiece(ctx, chocolateCanvas, piece, rectWidth, rectHeight, destX, destY);\n    }\n  } else {\n    // Normal rendering: draw all pieces\n    for (const pieceName of drawOrder) {\n      const pos = positions[pieceName];\n      const piece = pieces[pieceName];\n      const destX = (pos[0] + OFFSET_X) * rectWidth;\n      const destY = (pos[1] + OFFSET_Y) * rectHeight;\n      drawPiece(ctx, chocolateCanvas, piece, rectWidth, rectHeight, destX, destY);\n    }\n  }\n\n  // Draw grid overlay for solution mode\n  if (showGrid) {\n    drawGrid(ctx, rectWidth, rectHeight, api);\n  }\n}\n\n// Draw grid overlay (for solution mode)\nfunction drawGrid(ctx, rectWidth, rectHeight, api) {\n  ctx.save();\n\n  // Get a subtle grid color that contrasts with background\n  const gridColor = api.getColor('border', { alpha: -0.3 });\n\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 1;\n\n  // Draw vertical lines (5 columns + 1 for right edge = 6 lines)\n  for (let col = 0; col <= GRID_COLS; col++) {\n    const x = (col + OFFSET_X) * rectWidth;\n    const yStart = OFFSET_Y * rectHeight;\n    const yEnd = (OFFSET_Y + GRID_ROWS) * rectHeight;\n    ctx.beginPath();\n    ctx.moveTo(x, yStart);\n    ctx.lineTo(x, yEnd);\n    ctx.stroke();\n  }\n\n  // Draw horizontal lines (4 rows + 1 for bottom edge = 5 lines)\n  for (let row = 0; row <= GRID_ROWS; row++) {\n    const y = (row + OFFSET_Y) * rectHeight;\n    const xStart = OFFSET_X * rectWidth;\n    const xEnd = (OFFSET_X + GRID_COLS) * rectWidth;\n    ctx.beginPath();\n    ctx.moveTo(xStart, y);\n    ctx.lineTo(xEnd, y);\n    ctx.stroke();\n  }\n\n  ctx.restore();\n}\n\n// Create an offscreen canvas with the full chocolate bar\nfunction createChocolateBarCanvas(rectWidth, rectHeight, borderWidth, baseColor, lightColor, darkColor) {\n  const offscreen = document.createElement('canvas');\n  offscreen.width = rectWidth * GRID_COLS;\n  offscreen.height = rectHeight * GRID_ROWS;\n  const ctx = offscreen.getContext('2d');\n\n  for (let row = 0; row < GRID_ROWS; row++) {\n    for (let col = 0; col < GRID_COLS; col++) {\n      const x = col * rectWidth;\n      const y = row * rectHeight;\n      drawChocolateSquare(ctx, x, y, rectWidth, rectHeight, borderWidth, baseColor, lightColor, darkColor);\n    }\n  }\n\n  return offscreen;\n}\n\n// Draw a piece by clipping from the chocolate bar canvas\nfunction drawPiece(ctx, chocolateCanvas, piece, rectWidth, rectHeight, destX, destY) {\n  ctx.save();\n\n  // Create clipping path from piece coordinates\n  ctx.beginPath();\n  piece.forEach((point, i) => {\n    const px = destX + point[0] * rectWidth;\n    const py = destY + point[1] * rectHeight;\n    if (i === 0) {\n      ctx.moveTo(px, py);\n    } else {\n      ctx.lineTo(px, py);\n    }\n  });\n  ctx.closePath();\n  ctx.clip();\n\n  // Draw the chocolate bar canvas at the destination\n  ctx.drawImage(chocolateCanvas, destX, destY);\n\n  ctx.restore();\n}\n\n// Draw the chocolate bar with a custom clipping mask (for gap prevention)\n// The mask coordinates are in grid units, relative to the chocolate bar origin\nfunction drawPieceWithMask(ctx, chocolateCanvas, mask, rectWidth, rectHeight, destX, destY) {\n  ctx.save();\n\n  // Create clipping path from mask coordinates\n  ctx.beginPath();\n  mask.forEach((point, i) => {\n    const px = destX + point[0] * rectWidth;\n    const py = destY + point[1] * rectHeight;\n    if (i === 0) {\n      ctx.moveTo(px, py);\n    } else {\n      ctx.lineTo(px, py);\n    }\n  });\n  ctx.closePath();\n  ctx.clip();\n\n  // Draw the chocolate bar canvas at the destination\n  ctx.drawImage(chocolateCanvas, destX, destY);\n\n  ctx.restore();\n}\n\nfunction drawChocolateSquare(ctx, x, y, w, h, bw, baseColor, lightColor, darkColor) {\n  // Draw base chocolate fill\n  ctx.fillStyle = baseColor;\n  ctx.fillRect(x, y, w, h);\n\n  // Draw top border as trapezoid (light)\n  ctx.fillStyle = lightColor;\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x + w, y);\n  ctx.lineTo(x + w - bw, y + bw);\n  ctx.lineTo(x + bw, y + bw);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw left border as trapezoid (light)\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x + bw, y + bw);\n  ctx.lineTo(x + bw, y + h - bw);\n  ctx.lineTo(x, y + h);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw bottom border as trapezoid (dark)\n  ctx.fillStyle = darkColor;\n  ctx.beginPath();\n  ctx.moveTo(x, y + h);\n  ctx.lineTo(x + bw, y + h - bw);\n  ctx.lineTo(x + w - bw, y + h - bw);\n  ctx.lineTo(x + w, y + h);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw right border as trapezoid (dark)\n  ctx.beginPath();\n  ctx.moveTo(x + w, y);\n  ctx.lineTo(x + w, y + h);\n  ctx.lineTo(x + w - bw, y + h - bw);\n  ctx.lineTo(x + w - bw, y + bw);\n  ctx.closePath();\n  ctx.fill();\n}\n```\n:::\n","dynamicBlocks",[43,56,60],{"_44":45,"_46":47,"_48":49,"_50":51,"_15":53,"_54":55},"type","dynamic","mode","component","componentId","#diagram","props",{"_46":52},"question","Chocolate bar puzzle—where does the square go?","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/infinite-chocolate-bar.md",{"_44":45,"_46":47,"_48":49,"_50":57,"_15":59,"_54":55},{"_46":58},"hint","Step through the animation",{"_44":45,"_46":47,"_48":49,"_50":61,"_15":63,"_54":55},{"_46":62},"solution","Animation without the trick (with grid overlay)","inlineComponents",{"_66":67},"diagram",{"_13":66,"_68":69,"_70":71},"code","// Chocolate rectangle aspect ratio (width/height)\nconst CHOCOLATE_ASPECT_RATIO = 3 / 4;\n\n// Grid dimensions for the chocolate bar\nconst GRID_COLS = 5;\nconst GRID_ROWS = 5;\n\n// Diagram grid dimensions (from Step 3)\nconst DIAGRAM_GRID_WIDTH = 8;\nconst DIAGRAM_GRID_HEIGHT = 8;\n\n// Offset to position pieces in the diagram (from Step 3: OFFSETS: X=3, Y=3)\nconst OFFSET_X = 3;\nconst OFFSET_Y = 3;\n\n// Animation duration in seconds\nconst ANIMATION_DURATION = 5;\n\n// Piece definitions (coordinates in grid units)\nconst PIECES = {\n  square: [[0, 0], [1, 0], [1, 1], [0, 1]],\n  rectangle: [[0, 0], [2, 0], [2, 1], [0, 1]],\n  narrowSlope: [[0, 0], [2, 0], [2, 1.5], [0, 2.3]],\n  wideSlope: [[0, 0], [3, 0], [3, 1.3], [0, 2.5]],\n  base: [[0, 2.5], [5, 0.5], [5, 4], [0, 4]]\n};\n\n// \"Tricked\" piece shapes (subtly expanded during the illusion)\nconst PIECES_TRICKED = {\n  narrowSlope: [[0, 0], [2, 0], [2, 1.7], [0, 2.5]],\n  wideSlope: [[0, 0], [3, 0], [3, 1.5], [0, 2.7]]\n};\n\n// Animation keyframes: [time in seconds, { piece: [x, y], ... }]\n// Positions are relative to top-left of piece, before adding OFFSET\nconst KEYFRAMES = [\n  [0, {\n    square: [0, 0],\n    rectangle: [1, 0],\n    narrowSlope: [3, 0],\n    wideSlope: [0, 1],\n    base: [0, 1]\n  }],\n  [1, {\n    square: [-2, -1.5],\n    rectangle: [-3, 0],\n    narrowSlope: [3, -3],\n    wideSlope: [0, 0.8],\n    base: [0, 1]\n  }],\n  [2, {\n    square: [-2, -1.5],\n    rectangle: [-3, 0],\n    narrowSlope: [0, -3],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }],\n  [3, {\n    square: [-2, -1.5],\n    rectangle: [-3, 0],\n    narrowSlope: [0, 1],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }],\n  [4, {\n    square: [-2, -1.5],\n    rectangle: [0, 0],\n    narrowSlope: [0, 1],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }],\n  [5, {\n    square: [-4.01, -1.5],\n    rectangle: [0, 0],\n    narrowSlope: [0, 1],\n    wideSlope: [2, 0],\n    base: [0, 1]\n  }]\n];\n\nfunction mount(options) {\n  const { root, api, props } = options;\n\n  try {\n    const mode = props.mode;\n\n    const canvas = document.createElement('canvas');\n    canvas.style.display = 'block';\n    canvas.style.margin = '0 auto';\n    root.appendChild(canvas);\n\n    // Animation state\n    let animationId = null;\n    let startTime = null;\n    let isPaused = false;\n    let currentTime = 0;\n    let lastTimestamp = null;\n\n    // Determine if we should use trick based on mode\n    const useTrick = mode !== 'solution';\n\n    const draw = (time) => {\n      drawAnimatedPieces(canvas, api, time, useTrick, mode === 'solution');\n    };\n\n    // Create controls for hint and solution modes\n    if (mode === 'hint' || mode === 'solution') {\n      const controlsContainer = document.createElement('div');\n      controlsContainer.className = api.css('flex items-center justify-center gap-2 mt-4');\n\n      // Back button\n      const backBtn = api.ui.button({\n        label: '← Back',\n        variant: 'outlined',\n        size: 'sm',\n        onClick: () => {\n          currentTime = currentTime - 0.2;\n          if (currentTime < 0) currentTime += ANIMATION_DURATION;\n          draw(currentTime);\n        }\n      });\n      backBtn.style.width = '100px';\n\n      // Pause/Play button\n      const playPauseBtn = api.ui.button({\n        label: isPaused ? '▶ Play' : '⏸ Pause',\n        variant: 'contained',\n        size: 'sm',\n        onClick: () => {\n          isPaused = !isPaused;\n          playPauseBtn.textContent = isPaused ? '▶ Play' : '⏸ Pause';\n        }\n      });\n      playPauseBtn.style.width = '100px';\n\n      // Forward button\n      const forwardBtn = api.ui.button({\n        label: 'Forward →',\n        variant: 'outlined',\n        size: 'sm',\n        onClick: () => {\n          currentTime = (currentTime + 0.2) % ANIMATION_DURATION;\n          draw(currentTime);\n        }\n      });\n      forwardBtn.style.width = '100px';\n\n      controlsContainer.appendChild(backBtn);\n      controlsContainer.appendChild(playPauseBtn);\n      controlsContainer.appendChild(forwardBtn);\n\n      root.appendChild(controlsContainer);\n    }\n\n    // Animation loop for all modes\n    const animate = (timestamp) => {\n      if (isPaused) {\n        lastTimestamp = timestamp;\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n\n      if (!lastTimestamp) lastTimestamp = timestamp;\n      const deltaTime = (timestamp - lastTimestamp) / 1000;\n      lastTimestamp = timestamp;\n\n      currentTime += deltaTime;\n\n      // Loop animation for question mode, or if controls are present\n      if (mode === 'question' || mode === 'hint' || mode === 'solution') {\n        currentTime = currentTime % ANIMATION_DURATION;\n      }\n\n      draw(currentTime);\n\n      animationId = requestAnimationFrame(animate);\n    };\n\n    // Initial draw\n    draw(currentTime);\n\n    // Start animation\n    animationId = requestAnimationFrame(animate);\n\n    // Redraw on theme change\n    api.onThemeChange(() => {\n      draw(currentTime);\n    });\n\n    // Handle resize\n    api.onResize(() => {\n      draw(currentTime);\n    });\n\n  } catch (error) {\n    console.error('[Chocolate Bar Error]', error);\n    root.textContent = 'An error occurred rendering the chocolate bar. Check the console.';\n  }\n}\n\n// Interpolate between two values\nfunction lerp(a, b, t) {\n  return a + (b - a) * t;\n}\n\n// Get interpolated positions for a given time\nfunction getPositionsAtTime(time, useTrick = true) {\n  // Find surrounding keyframes\n  let prevFrame = KEYFRAMES[0];\n  let nextFrame = KEYFRAMES[KEYFRAMES.length - 1];\n\n  for (let i = 0; i < KEYFRAMES.length - 1; i++) {\n    if (time >= KEYFRAMES[i][0] && time <= KEYFRAMES[i + 1][0]) {\n      prevFrame = KEYFRAMES[i];\n      nextFrame = KEYFRAMES[i + 1];\n      break;\n    }\n  }\n\n  const [prevTime, prevPositions] = prevFrame;\n  const [nextTime, nextPositions] = nextFrame;\n\n  // Calculate interpolation factor\n  const duration = nextTime - prevTime;\n  const t = duration > 0 ? (time - prevTime) / duration : 0;\n\n  // Interpolate each piece position\n  const positions = {};\n  for (const piece of Object.keys(prevPositions)) {\n    positions[piece] = [\n      lerp(prevPositions[piece][0], nextPositions[piece][0], t),\n      lerp(prevPositions[piece][1], nextPositions[piece][1], t)\n    ];\n  }\n\n  // Determine which piece shapes to use\n  // Wide slope morphs between seconds 1-2 (at keyframe 2)\n  // Narrow slope morphs between seconds 2-3 (at keyframe 3)\n  let pieces = { ...PIECES };\n  if (useTrick) {\n    // Wide slope: morph between 1-2 seconds\n    if (time >= 1 && time <= 2) {\n      const morphT = time - 1;\n      pieces.wideSlope = interpolatePiece(PIECES.wideSlope, PIECES_TRICKED.wideSlope, morphT);\n    } else if (time > 2) {\n      pieces.wideSlope = PIECES_TRICKED.wideSlope;\n    }\n\n    // Narrow slope: morph between 2-3 seconds\n    if (time >= 2 && time <= 3) {\n      const morphT = time - 2;\n      pieces.narrowSlope = interpolatePiece(PIECES.narrowSlope, PIECES_TRICKED.narrowSlope, morphT);\n    } else if (time > 3) {\n      pieces.narrowSlope = PIECES_TRICKED.narrowSlope;\n    }\n  }\n\n  return { positions, pieces };\n}\n\n// Interpolate piece shape coordinates\nfunction interpolatePiece(pieceA, pieceB, t) {\n  return pieceA.map((pointA, i) => {\n    const pointB = pieceB[i];\n    return [lerp(pointA[0], pointB[0], t), lerp(pointA[1], pointB[1], t)];\n  });\n}\n\n// Determine which pieces to skip and what solid mask to use for gap prevention\nfunction getGapPreventionConfig(time, useTrick) {\n  // Check for exact 0 second frame (stationary start)\n  if (time === 0) {\n    return {\n      skipPieces: ['square', 'rectangle', 'narrowSlope', 'wideSlope', 'base'],\n      solidMask: [[0, 0], [5, 0], [5, 4], [0, 4]]\n    };\n  }\n\n  if (useTrick) {\n    // CONCEALING THE TRICK optimizations\n    if (time >= 2 && time < 3) {\n      // 2 to 3 second frames: pieces are settling into new positions\n      return {\n        skipPieces: ['base', 'wideSlope'],\n        solidMask: [[2, 0], [5, 0], [5, 5], [0, 5], [0, 3.5], [2, 2.7]]\n      };\n    }\n    if (time >= 3 && time < 4) {\n      // 3 to 4 second frames: narrow slope has settled\n      return {\n        skipPieces: ['base', 'wideSlope', 'narrowSlope'],\n        solidMask: [[2, 0], [5, 0], [5, 5], [0, 5], [0, 1], [2, 1]]\n      };\n    }\n    if (time >= 4 && time <= 5) {\n      // 4 to 5 second frames: all pieces in final position\n      return {\n        skipPieces: ['rectangle', 'narrowSlope', 'wideSlope', 'base'],\n        solidMask: [[0, 0], [5, 0], [5, 5], [0, 5]]\n      };\n    }\n  } else {\n    // NOT CONCEALING THE TRICK optimizations\n    if (time >= 3 && time < 4) {\n      // 3 to 4 second frames: slopes have settled but with true shapes\n      return {\n        skipPieces: ['wideSlope', 'narrowSlope'],\n        solidMask: [[2, 0], [5, 0], [5, 1.3], [0, 3.3], [0, 1], [2, 1]]\n      };\n    }\n    if (time >= 4 && time <= 5) {\n      // 4 to 5 second frames: rectangle has returned\n      return {\n        skipPieces: ['rectangle', 'narrowSlope', 'wideSlope'],\n        solidMask: [[0, 0], [5, 0], [5, 1.3], [0, 3.3]]\n      };\n    }\n  }\n\n  // No gap prevention needed\n  return null;\n}\n\n// Draw the animated pieces\nfunction drawAnimatedPieces(canvas, api, time, useTrick = true, showGrid = false) {\n  if (api.size.width === 0) {\n    return;\n  }\n\n  const ctx = canvas.getContext('2d');\n\n  // Calculate dimensions\n  const maxWidth = Math.min(api.size.width, 300);\n  if (maxWidth <= 0) return;\n\n  const rectWidth = maxWidth / DIAGRAM_GRID_WIDTH;\n  const rectHeight = rectWidth / CHOCOLATE_ASPECT_RATIO;\n\n  const canvasWidth = rectWidth * DIAGRAM_GRID_WIDTH;\n  const canvasHeight = rectHeight * DIAGRAM_GRID_HEIGHT;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Clear canvas\n  ctx.fillStyle = api.getColor('background');\n  ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\n  // Get theme-aware chocolate colors\n  const isDark = api.theme === 'dark';\n  const baseColor = isDark ? api.getColor('#a16944') : api.getColor('#622c06');\n  const lightColor = isDark ? api.getColor('#c4916b') : api.getColor('#7b3f10');\n  const darkColor = isDark ? api.getColor('#6d3e1a') : api.getColor('#3b1d07');\n\n  const borderWidth = rectWidth * (10 / 80);\n\n  // Create the chocolate bar source canvas\n  const chocolateCanvas = createChocolateBarCanvas(rectWidth, rectHeight, borderWidth, baseColor, lightColor, darkColor);\n\n  // Get interpolated positions and piece shapes\n  const { positions, pieces } = getPositionsAtTime(time, useTrick);\n\n  // Check for gap prevention optimization\n  const gapConfig = getGapPreventionConfig(time, useTrick);\n\n  // Draw pieces in order (base first, then others on top)\n  const drawOrder = ['base', 'wideSlope', 'narrowSlope', 'rectangle', 'square'];\n\n  // If we have gap prevention, draw solid mask first, then remaining pieces\n  if (gapConfig) {\n    // Draw the solid chocolate bar with clipping mask at the standard position\n    const solidDestX = OFFSET_X * rectWidth;\n    const solidDestY = OFFSET_Y * rectHeight;\n    drawPieceWithMask(ctx, chocolateCanvas, gapConfig.solidMask, rectWidth, rectHeight, solidDestX, solidDestY);\n\n    // Draw only the pieces that are NOT skipped\n    for (const pieceName of drawOrder) {\n      if (gapConfig.skipPieces.includes(pieceName)) continue;\n      const pos = positions[pieceName];\n      const piece = pieces[pieceName];\n      const destX = (pos[0] + OFFSET_X) * rectWidth;\n      const destY = (pos[1] + OFFSET_Y) * rectHeight;\n      drawPiece(ctx, chocolateCanvas, piece, rectWidth, rectHeight, destX, destY);\n    }\n  } else {\n    // Normal rendering: draw all pieces\n    for (const pieceName of drawOrder) {\n      const pos = positions[pieceName];\n      const piece = pieces[pieceName];\n      const destX = (pos[0] + OFFSET_X) * rectWidth;\n      const destY = (pos[1] + OFFSET_Y) * rectHeight;\n      drawPiece(ctx, chocolateCanvas, piece, rectWidth, rectHeight, destX, destY);\n    }\n  }\n\n  // Draw grid overlay for solution mode\n  if (showGrid) {\n    drawGrid(ctx, rectWidth, rectHeight, api);\n  }\n}\n\n// Draw grid overlay (for solution mode)\nfunction drawGrid(ctx, rectWidth, rectHeight, api) {\n  ctx.save();\n\n  // Get a subtle grid color that contrasts with background\n  const gridColor = api.getColor('border', { alpha: -0.3 });\n\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 1;\n\n  // Draw vertical lines (5 columns + 1 for right edge = 6 lines)\n  for (let col = 0; col <= GRID_COLS; col++) {\n    const x = (col + OFFSET_X) * rectWidth;\n    const yStart = OFFSET_Y * rectHeight;\n    const yEnd = (OFFSET_Y + GRID_ROWS) * rectHeight;\n    ctx.beginPath();\n    ctx.moveTo(x, yStart);\n    ctx.lineTo(x, yEnd);\n    ctx.stroke();\n  }\n\n  // Draw horizontal lines (4 rows + 1 for bottom edge = 5 lines)\n  for (let row = 0; row <= GRID_ROWS; row++) {\n    const y = (row + OFFSET_Y) * rectHeight;\n    const xStart = OFFSET_X * rectWidth;\n    const xEnd = (OFFSET_X + GRID_COLS) * rectWidth;\n    ctx.beginPath();\n    ctx.moveTo(xStart, y);\n    ctx.lineTo(xEnd, y);\n    ctx.stroke();\n  }\n\n  ctx.restore();\n}\n\n// Create an offscreen canvas with the full chocolate bar\nfunction createChocolateBarCanvas(rectWidth, rectHeight, borderWidth, baseColor, lightColor, darkColor) {\n  const offscreen = document.createElement('canvas');\n  offscreen.width = rectWidth * GRID_COLS;\n  offscreen.height = rectHeight * GRID_ROWS;\n  const ctx = offscreen.getContext('2d');\n\n  for (let row = 0; row < GRID_ROWS; row++) {\n    for (let col = 0; col < GRID_COLS; col++) {\n      const x = col * rectWidth;\n      const y = row * rectHeight;\n      drawChocolateSquare(ctx, x, y, rectWidth, rectHeight, borderWidth, baseColor, lightColor, darkColor);\n    }\n  }\n\n  return offscreen;\n}\n\n// Draw a piece by clipping from the chocolate bar canvas\nfunction drawPiece(ctx, chocolateCanvas, piece, rectWidth, rectHeight, destX, destY) {\n  ctx.save();\n\n  // Create clipping path from piece coordinates\n  ctx.beginPath();\n  piece.forEach((point, i) => {\n    const px = destX + point[0] * rectWidth;\n    const py = destY + point[1] * rectHeight;\n    if (i === 0) {\n      ctx.moveTo(px, py);\n    } else {\n      ctx.lineTo(px, py);\n    }\n  });\n  ctx.closePath();\n  ctx.clip();\n\n  // Draw the chocolate bar canvas at the destination\n  ctx.drawImage(chocolateCanvas, destX, destY);\n\n  ctx.restore();\n}\n\n// Draw the chocolate bar with a custom clipping mask (for gap prevention)\n// The mask coordinates are in grid units, relative to the chocolate bar origin\nfunction drawPieceWithMask(ctx, chocolateCanvas, mask, rectWidth, rectHeight, destX, destY) {\n  ctx.save();\n\n  // Create clipping path from mask coordinates\n  ctx.beginPath();\n  mask.forEach((point, i) => {\n    const px = destX + point[0] * rectWidth;\n    const py = destY + point[1] * rectHeight;\n    if (i === 0) {\n      ctx.moveTo(px, py);\n    } else {\n      ctx.lineTo(px, py);\n    }\n  });\n  ctx.closePath();\n  ctx.clip();\n\n  // Draw the chocolate bar canvas at the destination\n  ctx.drawImage(chocolateCanvas, destX, destY);\n\n  ctx.restore();\n}\n\nfunction drawChocolateSquare(ctx, x, y, w, h, bw, baseColor, lightColor, darkColor) {\n  // Draw base chocolate fill\n  ctx.fillStyle = baseColor;\n  ctx.fillRect(x, y, w, h);\n\n  // Draw top border as trapezoid (light)\n  ctx.fillStyle = lightColor;\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x + w, y);\n  ctx.lineTo(x + w - bw, y + bw);\n  ctx.lineTo(x + bw, y + bw);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw left border as trapezoid (light)\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x + bw, y + bw);\n  ctx.lineTo(x + bw, y + h - bw);\n  ctx.lineTo(x, y + h);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw bottom border as trapezoid (dark)\n  ctx.fillStyle = darkColor;\n  ctx.beginPath();\n  ctx.moveTo(x, y + h);\n  ctx.lineTo(x + bw, y + h - bw);\n  ctx.lineTo(x + w - bw, y + h - bw);\n  ctx.lineTo(x + w, y + h);\n  ctx.closePath();\n  ctx.fill();\n\n  // Draw right border as trapezoid (dark)\n  ctx.beginPath();\n  ctx.moveTo(x + w, y);\n  ctx.lineTo(x + w, y + h);\n  ctx.lineTo(x + w - bw, y + h - bw);\n  ctx.lineTo(x + w - bw, y + bw);\n  ctx.closePath();\n  ctx.fill();\n}","startLine",74]
