[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","covering-a-chessboard-1","puzzle",{"_7":8,"_11":12,"_35":36,"_37":38,"_39":40,"_61":62},"metadata",{"_13":14,"_15":16,"_17":18,"_19":20,"_22":23,"_25":26,"_27":28,"_29":28,"_30":31,"_32":33,"_34":33},"id","puzzle-9","title","Covering a Chessboard 1","difficulty","medium","concepts",[21],"invariants","tags",[24],"has-solution","credit","Classic puzzle originally posed by philosopher Max Black in *Critical Thinking* (1946) and later popularised by Martin Gardner.\nQuestion and solution written by Puzzlestone Peak.\n","dateCreated","2025-11-02","lastUpdated","changelog","2025-11-03: Added to Puzzlestone Peak","preview","You're given an 8x8 chessboard with 2 opposite corner tiles removed. You can place dominoes on the board, with each one covering exactly 2 adjacent tiles (you...","websitePreview","content","<p>You're given an 8x8 chessboard with 2 opposite corner tiles removed. You can place dominoes on the board, with each one covering exactly 2 adjacent tiles (you can't place them diagonally to cover 2 tiles touching at a corner. The dominoes can be rotated by 90° increments, but cannot be overlapped. Can you cover all the empty tiles with 31 dominoes? If yes, show an arrangement of such a covering. If not, prove why it cannot be done.</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>There's an interesting property of tiles on a chessboard that could point you in the right direction.</p></div></details>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Let's try colouring the tiles like a chessboard. Does this shine the light on anything?</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<details class=\"content-block hint-block\" data-type=\"hint\"><summary class=\"hint-label\">Hint: Interactive board</summary><div class=\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Try playing around with the interactive board. Click in between any 2 tiles to place a domino over it. You may click on a domino to remove it.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>It is impossible to cover the chessboard with dominoes.</p><p>If you had a go with the interactive board, you might've noticed an interesting property: you'll end up with 2 tiles of the same colour left over. This hints at a property that we can use to prove it cannot be done.</p><p>Let's colour the chessboard with alternating black and white tiles. Notice that each domino covers a black and white tile, so 31 dominoes would cover 31 black tiles and 31 white tiles.</p><p>However, with opposite corners removed, a chessboard will have 30 black tiles and 32 white tiles (or vice versa, depending on which corner you cut off). Thus, there can be no arrangement of dominoes that will cover the entire chessboard.</p></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nYou're given an 8x8 chessboard with 2 opposite corner tiles removed. You can place dominoes on the board, with each one covering exactly 2 adjacent tiles (you can't place them diagonally to cover 2 tiles touching at a corner. The dominoes can be rotated by 90° increments, but cannot be overlapped. Can you cover all the empty tiles with 31 dominoes? If yes, show an arrangement of such a covering. If not, prove why it cannot be done.\n\n:::dynamic\n```yaml\nuse: '#chessboard'\nprops:\n  mode: static\n  pattern: plain\n```\n:::\n\n:::hint\nThere's an interesting property of tiles on a chessboard that could point you in the right direction.\n:::\n\n::::hint\nLet's try colouring the tiles like a chessboard. Does this shine the light on anything?\n\n:::dynamic\n```yaml\nuse: '#chessboard'\nprops:\n  mode: static\n  pattern: chessboard\n```\n:::\n::::\n\n::::hint[Hint: Interactive board]\nTry playing around with the interactive board. Click in between any 2 tiles to place a domino over it. You may click on a domino to remove it.\n\n:::dynamic\n```yaml\nuse: '#chessboard'\nprops:\n  mode: interactive\n  pattern: chessboard\n```\n:::\n::::\n\n:::solution\nIt is impossible to cover the chessboard with dominoes.\n\nIf you had a go with the interactive board, you might've noticed an interesting property: you'll end up with 2 tiles of the same colour left over. This hints at a property that we can use to prove it cannot be done.\n\nLet's colour the chessboard with alternating black and white tiles. Notice that each domino covers a black and white tile, so 31 dominoes would cover 31 black tiles and 31 white tiles.\n\nHowever, with opposite corners removed, a chessboard will have 30 black tiles and 32 white tiles (or vice versa, depending on which corner you cut off). Thus, there can be no arrangement of dominoes that will cover the entire chessboard.\n:::\n\n:::component[chessboard]\n```html\n<div id=\"chessboard-container\">\n  <div id=\"grid-wrapper\"></div>\n  <div id=\"controls\" class=\"hidden\"></div>\n</div>\n```\n\n```css\n:root {\n  --square-size: min(50px, calc(100vw / 10));\n  --grid-border-size: 2px;\n  --grid-border: var(--grid-border-size) solid #333;\n  --click-area-size: calc(var(--square-size) / 5);\n}\n\n* {\n  box-sizing: border-box;\n}\n\n#chessboard-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n#grid-wrapper {\n  position: relative;\n  display: inline-block;\n}\n\n#grid {\n  display: grid;\n  grid-template-columns: repeat(8, var(--square-size));\n  grid-template-rows: repeat(8, var(--square-size));\n  gap: 0;\n  position: relative;\n  user-select: none;\n}\n\n.chess-square {\n  width: var(--square-size);\n  height: var(--square-size);\n  position: relative;\n}\n\n.chess-square {\n  border-bottom: var(--grid-border);\n  border-right: var(--grid-border);\n}\n\n.chess-square[data-row=\"0\"] {\n  border-top: var(--grid-border);\n}\n\n.chess-square[data-col=\"0\"] {\n  border-left: var(--grid-border);\n}\n\n.chess-square[data-row=\"0\"][data-col=\"0\"] {\n  border-top: none;\n  border-left: none;\n}\n\n.chess-square[data-row=\"7\"][data-col=\"7\"] {\n  border-bottom: none;\n  border-right: none;\n}\n\n.chess-square.white {\n  background-color: #EEEED2;\n}\n\n.chess-square.black {\n  background-color: #769656;\n}\n\n.chess-square.plain {\n  background-color: #f0f0f0;\n}\n\n.chess-square.removed {\n  background-color: transparent;\n}\n\n.domino-container {\n  position: absolute;\n  cursor: pointer;\n  transition: opacity 0.2s;\n  z-index: 15;\n\n  --padding: 2px;\n  padding-top: var(--padding);\n  padding-left: var(--padding);\n  padding-bottom: calc(var(--padding) + var(--grid-border-size) / 2);\n  padding-right: calc(var(--padding) + var(--grid-border-size) / 2);\n}\n\n.domino-container:hover {\n  opacity: 0.7;\n}\n\n.domino-container.horizontal {\n  width: calc(var(--square-size) * 2);\n  height: var(--square-size);\n}\n\n.domino-container.vertical {\n  width: var(--square-size);\n  height: calc(var(--square-size) * 2);\n}\n\n.domino {\n  width: 100%;\n  height: 100%;\n\n  background: rgba(139, 69, 19, 0.9);\n  border: 4px solid #654321;\n  border-radius: 4px;\n}\n\n.domino-container.preview {\n  pointer-events: none;\n  z-index: 5;\n}\n\n.domino-container.preview > .domino {\n  background: rgba(139, 69, 19, 0.4);\n  border: 4px dashed #654321;\n}\n\n.gap-detector {\n  position: absolute;\n  z-index: 10;\n  cursor: pointer;\n}\n\n.gap-detector.horizontal {\n  width: var(--square-size);\n  height: var(--click-area-size);\n}\n\n.gap-detector.vertical {\n  width: var(--click-area-size);\n  height: var(--square-size);\n}\n\n#controls {\n  display: flex;\n  gap: 1rem;\n  margin-top: 1rem;\n}\n\n#controls > * {\n  width: 6rem;\n}\n```\n\n```js\nfunction mount(options) {\n  const { root, api, props } = options;\n\n  // Props\n  const mode = props.mode || 'static'; // 'static' | 'interactive'\n  const pattern = props.pattern || 'plain'; // 'plain' | 'chessboard'\n  const initialDominoes = props.dominoes || []; // [[r1, c1, r2, c2], ...]\n\n  // State\n  let dominoes = [...initialDominoes];\n  let dominoHistory = [];\n  let previewDomino = null;\n\n  const removedSquares = [[0, 0], [7, 7]]; // Top-left and bottom-right corners\n\n  // Create grid\n  const wrapper = document.getElementById('grid-wrapper');\n  const grid = document.createElement('div');\n  grid.id = 'grid';\n  wrapper.appendChild(grid);\n\n  // Create squares\n  const squares = [];\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const square = document.createElement('div');\n      square.className = 'chess-square';\n      square.dataset.row = row;\n      square.dataset.col = col;\n\n      // Check if this square is removed\n      const isRemoved = removedSquares.some(([r, c]) => r === row && c === col);\n\n      if (isRemoved) {\n        square.classList.add('removed');\n      } else if (pattern === 'chessboard') {\n        square.classList.add((row + col) % 2 === 0 ? 'white' : 'black');\n      } else {\n        square.classList.add('plain');\n      }\n\n      grid.appendChild(square);\n      squares.push(square);\n    }\n  }\n\n  // Helper functions\n  function getSquareElement(row, col) {\n    return grid.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n  }\n\n  function isSquareRemoved(row, col) {\n    return removedSquares.some(([r, c]) => r === row && c === col);\n  }\n\n  function isSquareOccupied(row, col) {\n    return dominoes.some(([r1, c1, r2, c2]) =>\n      (r1 === row && c1 === col) || (r2 === row && c2 === col)\n    );\n  }\n\n  function canPlaceDomino(row1, col1, row2, col2) {\n    // Check if squares exist\n    if (row1 < 0 || row1 > 7 || col1 < 0 || col1 > 7) return false;\n    if (row2 < 0 || row2 > 7 || col2 < 0 || col2 > 7) return false;\n\n    // Check if squares are removed\n    if (isSquareRemoved(row1, col1) || isSquareRemoved(row2, col2)) return false;\n\n    // Check if squares are already occupied\n    if (isSquareOccupied(row1, col1) || isSquareOccupied(row2, col2)) return false;\n\n    return true;\n  }\n\n  function createDominoElement(row1, col1, row2, col2, isPreview = false) {\n    const dominoContainer = document.createElement('div');\n    dominoContainer.className = 'domino-container';\n\n    const domino = document.createElement('div');\n    domino.className = 'domino';\n\n    if (isPreview) {\n      dominoContainer.classList.add('preview');\n    }\n\n    // Determine orientation and position\n    const isHorizontal = row1 === row2;\n    dominoContainer.classList.add(isHorizontal ? 'horizontal' : 'vertical');\n\n    const minRow = Math.min(row1, row2);\n    const minCol = Math.min(col1, col2);\n\n    dominoContainer.style.left = `calc(var(--square-size) * ${minCol})`;\n    dominoContainer.style.top = `calc(var(--square-size) * ${minRow})`;\n\n    if (!isPreview) {\n      dominoContainer.dataset.domino = JSON.stringify([row1, col1, row2, col2]);\n      dominoContainer.addEventListener('click', () => removeDomino(row1, col1, row2, col2));\n    }\n\n    dominoContainer.append(domino);\n\n    return dominoContainer;\n  }\n\n  function renderDominoes() {\n    // Remove all existing dominoes\n    grid.querySelectorAll('.domino-container:not(.preview)').forEach(el => el.remove());\n\n    // Render all dominoes\n    dominoes.forEach(([r1, c1, r2, c2]) => {\n      const domino = createDominoElement(r1, c1, r2, c2);\n      grid.appendChild(domino);\n    });\n  }\n\n  function placeDomino(row1, col1, row2, col2) {\n    if (canPlaceDomino(row1, col1, row2, col2)) {\n      dominoHistory.push([...dominoes]);\n      dominoes.push([row1, col1, row2, col2]);\n      renderDominoes();\n    }\n  }\n\n  function removeDomino(row1, col1, row2, col2) {\n    if (mode === 'static') return; // Can't remove in static mode\n\n    dominoHistory.push([...dominoes]);\n    dominoes = dominoes.filter(([r1, c1, r2, c2]) =>\n      !(r1 === row1 && c1 === col1 && r2 === row2 && c2 === col2)\n    );\n    renderDominoes();\n  }\n\n  function undo() {\n    if (dominoHistory.length > 0) {\n      dominoes = dominoHistory.pop();\n      renderDominoes();\n    }\n  }\n\n  function reset() {\n    dominoHistory.push([...dominoes]);\n    dominoes = [];\n    renderDominoes();\n  }\n\n  // Interactive mode: Add gap detectors for hover\n  if (mode === 'interactive') {\n    // Add horizontal gap detectors (between rows)\n    for (let row = 0; row < 7; row++) {\n      for (let col = 0; col < 8; col++) {\n        const detector = document.createElement('div');\n        detector.className = 'gap-detector horizontal';\n        detector.style.left = `calc(var(--square-size) * ${col})`;\n        detector.style.top = `calc(var(--square-size) * ${row + 1} - var(--click-area-size) / 2)`;\n        detector.dataset.orientation = 'vertical'; // Vertical domino on horizontal gap\n        detector.dataset.row = row;\n        detector.dataset.col = col;\n\n        detector.addEventListener('mouseenter', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n\n          if (canPlaceDomino(r, c, r + 1, c)) {\n            previewDomino = createDominoElement(r, c, r + 1, c, true);\n            grid.appendChild(previewDomino);\n          }\n        });\n\n        detector.addEventListener('mouseleave', () => {\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        detector.addEventListener('click', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n          placeDomino(r, c, r + 1, c);\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        grid.appendChild(detector);\n      }\n    }\n\n    // Add vertical gap detectors (between columns)\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 7; col++) {\n        const detector = document.createElement('div');\n        detector.className = 'gap-detector vertical';\n        detector.style.left = `calc(var(--square-size) * ${col + 1} - var(--click-area-size) / 2)`;\n        detector.style.top = `calc(var(--square-size) * ${row})`;\n        detector.dataset.orientation = 'horizontal'; // Horizontal domino on vertical gap\n        detector.dataset.row = row;\n        detector.dataset.col = col;\n\n        detector.addEventListener('mouseenter', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n\n          if (canPlaceDomino(r, c, r, c + 1)) {\n            previewDomino = createDominoElement(r, c, r, c + 1, true);\n            grid.appendChild(previewDomino);\n          }\n        });\n\n        detector.addEventListener('mouseleave', () => {\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        detector.addEventListener('click', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n          placeDomino(r, c, r, c + 1);\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        grid.appendChild(detector);\n      }\n    }\n\n    // Add controls\n    const controls = document.getElementById('controls');\n    controls.classList.remove('hidden');\n\n    const undoBtn = api.ui.button({\n      label: 'Undo',\n      variant: 'outlined',\n      color: 'secondary',\n      size: 'sm',\n      onClick: undo\n    });\n\n    const resetBtn = api.ui.button({\n      label: 'Reset',\n      variant: 'outlined',\n      color: 'destructive',\n      size: 'sm',\n      onClick: reset\n    });\n\n    controls.appendChild(undoBtn);\n    controls.appendChild(resetBtn);\n  }\n\n  // Initial render\n  renderDominoes();\n}\n```\n\n:::\n","dynamicBlocks",[41,55,58],{"_42":43,"_44":45,"_46":47,"_48":49,"_53":54},"type","dynamic","mode","component","componentId","#chessboard","props",{"_44":50,"_51":52},"static","pattern","plain","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/misc/covering-a-chessboard-1.md",{"_42":43,"_44":45,"_46":47,"_48":56,"_53":54},{"_44":50,"_51":57},"chessboard",{"_42":43,"_44":45,"_46":47,"_48":59,"_53":54},{"_44":60,"_51":57},"interactive","inlineComponents",{"_57":63},{"_13":57,"_64":65,"_66":67,"_68":69,"_70":71},"code","function mount(options) {\n  const { root, api, props } = options;\n\n  // Props\n  const mode = props.mode || 'static'; // 'static' | 'interactive'\n  const pattern = props.pattern || 'plain'; // 'plain' | 'chessboard'\n  const initialDominoes = props.dominoes || []; // [[r1, c1, r2, c2], ...]\n\n  // State\n  let dominoes = [...initialDominoes];\n  let dominoHistory = [];\n  let previewDomino = null;\n\n  const removedSquares = [[0, 0], [7, 7]]; // Top-left and bottom-right corners\n\n  // Create grid\n  const wrapper = document.getElementById('grid-wrapper');\n  const grid = document.createElement('div');\n  grid.id = 'grid';\n  wrapper.appendChild(grid);\n\n  // Create squares\n  const squares = [];\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const square = document.createElement('div');\n      square.className = 'chess-square';\n      square.dataset.row = row;\n      square.dataset.col = col;\n\n      // Check if this square is removed\n      const isRemoved = removedSquares.some(([r, c]) => r === row && c === col);\n\n      if (isRemoved) {\n        square.classList.add('removed');\n      } else if (pattern === 'chessboard') {\n        square.classList.add((row + col) % 2 === 0 ? 'white' : 'black');\n      } else {\n        square.classList.add('plain');\n      }\n\n      grid.appendChild(square);\n      squares.push(square);\n    }\n  }\n\n  // Helper functions\n  function getSquareElement(row, col) {\n    return grid.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n  }\n\n  function isSquareRemoved(row, col) {\n    return removedSquares.some(([r, c]) => r === row && c === col);\n  }\n\n  function isSquareOccupied(row, col) {\n    return dominoes.some(([r1, c1, r2, c2]) =>\n      (r1 === row && c1 === col) || (r2 === row && c2 === col)\n    );\n  }\n\n  function canPlaceDomino(row1, col1, row2, col2) {\n    // Check if squares exist\n    if (row1 < 0 || row1 > 7 || col1 < 0 || col1 > 7) return false;\n    if (row2 < 0 || row2 > 7 || col2 < 0 || col2 > 7) return false;\n\n    // Check if squares are removed\n    if (isSquareRemoved(row1, col1) || isSquareRemoved(row2, col2)) return false;\n\n    // Check if squares are already occupied\n    if (isSquareOccupied(row1, col1) || isSquareOccupied(row2, col2)) return false;\n\n    return true;\n  }\n\n  function createDominoElement(row1, col1, row2, col2, isPreview = false) {\n    const dominoContainer = document.createElement('div');\n    dominoContainer.className = 'domino-container';\n\n    const domino = document.createElement('div');\n    domino.className = 'domino';\n\n    if (isPreview) {\n      dominoContainer.classList.add('preview');\n    }\n\n    // Determine orientation and position\n    const isHorizontal = row1 === row2;\n    dominoContainer.classList.add(isHorizontal ? 'horizontal' : 'vertical');\n\n    const minRow = Math.min(row1, row2);\n    const minCol = Math.min(col1, col2);\n\n    dominoContainer.style.left = `calc(var(--square-size) * ${minCol})`;\n    dominoContainer.style.top = `calc(var(--square-size) * ${minRow})`;\n\n    if (!isPreview) {\n      dominoContainer.dataset.domino = JSON.stringify([row1, col1, row2, col2]);\n      dominoContainer.addEventListener('click', () => removeDomino(row1, col1, row2, col2));\n    }\n\n    dominoContainer.append(domino);\n\n    return dominoContainer;\n  }\n\n  function renderDominoes() {\n    // Remove all existing dominoes\n    grid.querySelectorAll('.domino-container:not(.preview)').forEach(el => el.remove());\n\n    // Render all dominoes\n    dominoes.forEach(([r1, c1, r2, c2]) => {\n      const domino = createDominoElement(r1, c1, r2, c2);\n      grid.appendChild(domino);\n    });\n  }\n\n  function placeDomino(row1, col1, row2, col2) {\n    if (canPlaceDomino(row1, col1, row2, col2)) {\n      dominoHistory.push([...dominoes]);\n      dominoes.push([row1, col1, row2, col2]);\n      renderDominoes();\n    }\n  }\n\n  function removeDomino(row1, col1, row2, col2) {\n    if (mode === 'static') return; // Can't remove in static mode\n\n    dominoHistory.push([...dominoes]);\n    dominoes = dominoes.filter(([r1, c1, r2, c2]) =>\n      !(r1 === row1 && c1 === col1 && r2 === row2 && c2 === col2)\n    );\n    renderDominoes();\n  }\n\n  function undo() {\n    if (dominoHistory.length > 0) {\n      dominoes = dominoHistory.pop();\n      renderDominoes();\n    }\n  }\n\n  function reset() {\n    dominoHistory.push([...dominoes]);\n    dominoes = [];\n    renderDominoes();\n  }\n\n  // Interactive mode: Add gap detectors for hover\n  if (mode === 'interactive') {\n    // Add horizontal gap detectors (between rows)\n    for (let row = 0; row < 7; row++) {\n      for (let col = 0; col < 8; col++) {\n        const detector = document.createElement('div');\n        detector.className = 'gap-detector horizontal';\n        detector.style.left = `calc(var(--square-size) * ${col})`;\n        detector.style.top = `calc(var(--square-size) * ${row + 1} - var(--click-area-size) / 2)`;\n        detector.dataset.orientation = 'vertical'; // Vertical domino on horizontal gap\n        detector.dataset.row = row;\n        detector.dataset.col = col;\n\n        detector.addEventListener('mouseenter', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n\n          if (canPlaceDomino(r, c, r + 1, c)) {\n            previewDomino = createDominoElement(r, c, r + 1, c, true);\n            grid.appendChild(previewDomino);\n          }\n        });\n\n        detector.addEventListener('mouseleave', () => {\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        detector.addEventListener('click', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n          placeDomino(r, c, r + 1, c);\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        grid.appendChild(detector);\n      }\n    }\n\n    // Add vertical gap detectors (between columns)\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 7; col++) {\n        const detector = document.createElement('div');\n        detector.className = 'gap-detector vertical';\n        detector.style.left = `calc(var(--square-size) * ${col + 1} - var(--click-area-size) / 2)`;\n        detector.style.top = `calc(var(--square-size) * ${row})`;\n        detector.dataset.orientation = 'horizontal'; // Horizontal domino on vertical gap\n        detector.dataset.row = row;\n        detector.dataset.col = col;\n\n        detector.addEventListener('mouseenter', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n\n          if (canPlaceDomino(r, c, r, c + 1)) {\n            previewDomino = createDominoElement(r, c, r, c + 1, true);\n            grid.appendChild(previewDomino);\n          }\n        });\n\n        detector.addEventListener('mouseleave', () => {\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        detector.addEventListener('click', () => {\n          const r = parseInt(detector.dataset.row);\n          const c = parseInt(detector.dataset.col);\n          placeDomino(r, c, r, c + 1);\n          if (previewDomino) {\n            previewDomino.remove();\n            previewDomino = null;\n          }\n        });\n\n        grid.appendChild(detector);\n      }\n    }\n\n    // Add controls\n    const controls = document.getElementById('controls');\n    controls.classList.remove('hidden');\n\n    const undoBtn = api.ui.button({\n      label: 'Undo',\n      variant: 'outlined',\n      color: 'secondary',\n      size: 'sm',\n      onClick: undo\n    });\n\n    const resetBtn = api.ui.button({\n      label: 'Reset',\n      variant: 'outlined',\n      color: 'destructive',\n      size: 'sm',\n      onClick: reset\n    });\n\n    controls.appendChild(undoBtn);\n    controls.appendChild(resetBtn);\n  }\n\n  // Initial render\n  renderDominoes();\n}","layout","<div id=\"chessboard-container\">\n  <div id=\"grid-wrapper\"></div>\n  <div id=\"controls\" class=\"hidden\"></div>\n</div>","css",":root {\n  --square-size: min(50px, calc(100vw / 10));\n  --grid-border-size: 2px;\n  --grid-border: var(--grid-border-size) solid #333;\n  --click-area-size: calc(var(--square-size) / 5);\n}\n\n* {\n  box-sizing: border-box;\n}\n\n#chessboard-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n#grid-wrapper {\n  position: relative;\n  display: inline-block;\n}\n\n#grid {\n  display: grid;\n  grid-template-columns: repeat(8, var(--square-size));\n  grid-template-rows: repeat(8, var(--square-size));\n  gap: 0;\n  position: relative;\n  user-select: none;\n}\n\n.chess-square {\n  width: var(--square-size);\n  height: var(--square-size);\n  position: relative;\n}\n\n.chess-square {\n  border-bottom: var(--grid-border);\n  border-right: var(--grid-border);\n}\n\n.chess-square[data-row=\"0\"] {\n  border-top: var(--grid-border);\n}\n\n.chess-square[data-col=\"0\"] {\n  border-left: var(--grid-border);\n}\n\n.chess-square[data-row=\"0\"][data-col=\"0\"] {\n  border-top: none;\n  border-left: none;\n}\n\n.chess-square[data-row=\"7\"][data-col=\"7\"] {\n  border-bottom: none;\n  border-right: none;\n}\n\n.chess-square.white {\n  background-color: #EEEED2;\n}\n\n.chess-square.black {\n  background-color: #769656;\n}\n\n.chess-square.plain {\n  background-color: #f0f0f0;\n}\n\n.chess-square.removed {\n  background-color: transparent;\n}\n\n.domino-container {\n  position: absolute;\n  cursor: pointer;\n  transition: opacity 0.2s;\n  z-index: 15;\n\n  --padding: 2px;\n  padding-top: var(--padding);\n  padding-left: var(--padding);\n  padding-bottom: calc(var(--padding) + var(--grid-border-size) / 2);\n  padding-right: calc(var(--padding) + var(--grid-border-size) / 2);\n}\n\n.domino-container:hover {\n  opacity: 0.7;\n}\n\n.domino-container.horizontal {\n  width: calc(var(--square-size) * 2);\n  height: var(--square-size);\n}\n\n.domino-container.vertical {\n  width: var(--square-size);\n  height: calc(var(--square-size) * 2);\n}\n\n.domino {\n  width: 100%;\n  height: 100%;\n\n  background: rgba(139, 69, 19, 0.9);\n  border: 4px solid #654321;\n  border-radius: 4px;\n}\n\n.domino-container.preview {\n  pointer-events: none;\n  z-index: 5;\n}\n\n.domino-container.preview > .domino {\n  background: rgba(139, 69, 19, 0.4);\n  border: 4px dashed #654321;\n}\n\n.gap-detector {\n  position: absolute;\n  z-index: 10;\n  cursor: pointer;\n}\n\n.gap-detector.horizontal {\n  width: var(--square-size);\n  height: var(--click-area-size);\n}\n\n.gap-detector.vertical {\n  width: var(--click-area-size);\n  height: var(--square-size);\n}\n\n#controls {\n  display: flex;\n  gap: 1rem;\n  margin-top: 1rem;\n}\n\n#controls > * {\n  width: 6rem;\n}","startLine",229]
