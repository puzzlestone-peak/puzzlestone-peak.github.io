[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","equal-shape-cutting-4","puzzle",{"_7":8,"_11":12,"_37":38,"_39":40,"_41":42,"_62":63},"metadata",{"_13":14,"_15":16,"_17":18,"_19":22,"_24":25,"_27":28,"_29":30,"_31":30,"_32":33,"_34":35,"_36":35},"id","puzzle-draft-70","title","Equal Shape Cutting 4","difficulty",{"_19":20,"_21":20},"concepts","easy","reasoning",[23],"geometry","tags",[26],"has-solution","credit","Classic geometry puzzle. Question and solution written by Puzzlestone Peak.","dateCreated","2026-02-02","lastUpdated","previousPuzzle","equal-shape-cutting-3","preview","With 1 cut, divide the zigzag shape into 2 equal shapes of itself. The cut does not have to be straight, but has to be a connected line. The shapes can be...","websitePreview","content","<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<p>With 1 cut, divide the zigzag shape into 2 equal shapes of itself. The cut does not have to be straight, but has to be a connected line. The shapes can be rotated, but they both must be of the same size.</p>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>You can visualise the solution by splitting the original image into squares.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\n:::dynamic\n```yaml\ntitle: \"Zigzag shape\"\nuse: '#zigzag-diagram'\nprops:\n  mode: puzzle\n```\n:::\n\nWith 1 cut, divide the zigzag shape into 2 equal shapes of itself. The cut does not have to be straight, but has to be a connected line. The shapes can be rotated, but they both must be of the same size.\n\n::::solution\n\n:::dynamic\n```yaml\ntitle: \"Zigzag shape divided into 2 smaller zigzag shapes\"\nuse: '#zigzag-diagram'\nprops:\n  mode: solution\n```\n:::\n\nYou can visualise the solution by splitting the original image into squares.\n\n:::dynamic\n```yaml\ntitle: \"Zigzag shape divided into 2 smaller zigzag shapes\"\nuse: '#zigzag-diagram'\nprops:\n  mode: guides\n```\n:::\n\n::::\n\n\n:::component[zigzag-diagram]\n```js\nfunction draw(options) {\n  const { canvas, api, theme, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  const lineWidth = 2;\n  const guideLineWidth = 0.5;\n  const dividerLineWidth = 4;\n  const padding = 30;\n\n  // Mode: 'puzzle', 'solution', or 'guides'\n  const mode = props?.mode || 'puzzle';\n\n  // Diamond grid: 5x5 grid of diamond cells\n  const gridSize = 5;\n  const cellSize = 40; // Size of each diamond (distance from center to vertex)\n\n  // Pattern: X = empty, A = first half, B = second half\n  // Rotated 45° counterclockwise from original grid\n  const pattern = [\n    ['X', 'X', 'B', 'B', 'X'],\n    ['X', 'X', 'B', 'B', 'B'],\n    ['X', 'A', 'A', 'B', 'X'],\n    ['A', 'A', 'A', 'X', 'X'],\n    ['X', 'A', 'X', 'X', 'X']\n  ];\n\n  // Calculate bounds of non-empty cells\n  let minX = Infinity, maxX = -Infinity;\n  let minY = Infinity, maxY = -Infinity;\n\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (pattern[row][col] !== 'X') {\n        const x = (col - row) * cellSize;\n        const y = (col + row - gridSize + 1) * cellSize;\n        minX = Math.min(minX, x - cellSize);\n        maxX = Math.max(maxX, x + cellSize);\n        minY = Math.min(minY, y - cellSize);\n        maxY = Math.max(maxY, y + cellSize);\n      }\n    }\n  }\n\n  // Canvas dimensions based on actual shape bounds\n  const shapeWidth = maxX - minX;\n  const shapeHeight = maxY - minY;\n  const canvasWidth = Math.min(width, shapeWidth + 2 * padding);\n  const canvasHeight = shapeHeight + 2 * padding;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Offset to center the shape\n  const offsetX = canvasWidth / 2 - (minX + maxX) / 2;\n  const offsetY = canvasHeight / 2 - (minY + maxY) / 2;\n\n  // Get colors\n  const foregroundColor = api.getColor('foreground');\n  const primaryColor = api.getColor('primary');\n\n  // Clear canvas\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  // Draw guides (thin grid lines) if mode is 'guides'\n  if (mode === 'guides') {\n    ctx.strokeStyle = foregroundColor;\n    ctx.lineWidth = guideLineWidth;\n\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        const cell = pattern[row][col];\n        if (cell === 'X') continue;\n\n        const x = offsetX + (col - row) * cellSize;\n        const y = offsetY + (col + row - gridSize + 1) * cellSize;\n\n        ctx.beginPath();\n        ctx.moveTo(x, y - cellSize);\n        ctx.lineTo(x + cellSize, y);\n        ctx.lineTo(x, y + cellSize);\n        ctx.lineTo(x - cellSize, y);\n        ctx.closePath();\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Draw outline\n  ctx.strokeStyle = foregroundColor;\n  ctx.lineWidth = lineWidth;\n  ctx.beginPath();\n\n  // Trace the outer boundary of the shape\n  const cells = [];\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (pattern[row][col] !== 'X') {\n        cells.push({ row, col, value: pattern[row][col] });\n      }\n    }\n  }\n\n  // Find outline by checking which edges are external\n  const edges = [];\n  for (const { row, col } of cells) {\n    const x = offsetX + (col - row) * cellSize;\n    const y = offsetY + (col + row - gridSize + 1) * cellSize;\n\n    const neighbors = [\n      { dr: -1, dc: 0, edge: [[x, y - cellSize], [x + cellSize, y]] },      // top\n      { dr: 0, dc: 1, edge: [[x + cellSize, y], [x, y + cellSize]] },       // right\n      { dr: 1, dc: 0, edge: [[x, y + cellSize], [x - cellSize, y]] },       // bottom\n      { dr: 0, dc: -1, edge: [[x - cellSize, y], [x, y - cellSize]] }       // left\n    ];\n\n    for (const { dr, dc, edge } of neighbors) {\n      const nr = row + dr;\n      const nc = col + dc;\n      if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize || pattern[nr][nc] === 'X') {\n        edges.push(edge);\n      }\n    }\n  }\n\n  // Draw outline edges\n  for (const [[x1, y1], [x2, y2]] of edges) {\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n  }\n  ctx.stroke();\n\n  // Draw divider between A and B regions if mode is 'solution' or 'guides'\n  if (mode === 'solution' || mode === 'guides') {\n    ctx.strokeStyle = primaryColor;\n    ctx.lineWidth = dividerLineWidth;\n    ctx.lineCap = 'butt';\n    ctx.beginPath();\n\n    // Find edges between A and B cells\n    for (const { row, col, value } of cells) {\n      if (value !== 'A') continue;\n\n      const x = offsetX + (col - row) * cellSize;\n      const y = offsetY + (col + row - gridSize + 1) * cellSize;\n\n      const neighbors = [\n        { dr: -1, dc: 0, edge: [[x, y - cellSize], [x + cellSize, y]] },\n        { dr: 0, dc: 1, edge: [[x + cellSize, y], [x, y + cellSize]] },\n        { dr: 1, dc: 0, edge: [[x, y + cellSize], [x - cellSize, y]] },\n        { dr: 0, dc: -1, edge: [[x - cellSize, y], [x, y - cellSize]] }\n      ];\n\n      for (const { dr, dc, edge } of neighbors) {\n        const nr = row + dr;\n        const nc = col + dc;\n        if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize && pattern[nr][nc] === 'B') {\n          const [[x1, y1], [x2, y2]] = edge;\n          ctx.moveTo(x1, y1);\n          ctx.lineTo(x2, y2);\n        }\n      }\n    }\n    ctx.stroke();\n  }\n}\n```\n:::\n","dynamicBlocks",[43,55,59],{"_44":45,"_46":47,"_48":49,"_50":51,"_15":52,"_53":54},"type","dynamic","mode","component","componentId","#zigzag-diagram","props",{"_46":9},"Zigzag shape","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/equal-shape-cutting/equal-shape-cutting-4.md",{"_44":45,"_46":47,"_48":49,"_50":56,"_15":58,"_53":54},{"_46":57},"solution","Zigzag shape divided into 2 smaller zigzag shapes",{"_44":45,"_46":47,"_48":49,"_50":60,"_15":58,"_53":54},{"_46":61},"guides","inlineComponents",{"_64":65},"zigzag-diagram",{"_13":64,"_66":67,"_68":69},"code","function draw(options) {\n  const { canvas, api, theme, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  const lineWidth = 2;\n  const guideLineWidth = 0.5;\n  const dividerLineWidth = 4;\n  const padding = 30;\n\n  // Mode: 'puzzle', 'solution', or 'guides'\n  const mode = props?.mode || 'puzzle';\n\n  // Diamond grid: 5x5 grid of diamond cells\n  const gridSize = 5;\n  const cellSize = 40; // Size of each diamond (distance from center to vertex)\n\n  // Pattern: X = empty, A = first half, B = second half\n  // Rotated 45° counterclockwise from original grid\n  const pattern = [\n    ['X', 'X', 'B', 'B', 'X'],\n    ['X', 'X', 'B', 'B', 'B'],\n    ['X', 'A', 'A', 'B', 'X'],\n    ['A', 'A', 'A', 'X', 'X'],\n    ['X', 'A', 'X', 'X', 'X']\n  ];\n\n  // Calculate bounds of non-empty cells\n  let minX = Infinity, maxX = -Infinity;\n  let minY = Infinity, maxY = -Infinity;\n\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (pattern[row][col] !== 'X') {\n        const x = (col - row) * cellSize;\n        const y = (col + row - gridSize + 1) * cellSize;\n        minX = Math.min(minX, x - cellSize);\n        maxX = Math.max(maxX, x + cellSize);\n        minY = Math.min(minY, y - cellSize);\n        maxY = Math.max(maxY, y + cellSize);\n      }\n    }\n  }\n\n  // Canvas dimensions based on actual shape bounds\n  const shapeWidth = maxX - minX;\n  const shapeHeight = maxY - minY;\n  const canvasWidth = Math.min(width, shapeWidth + 2 * padding);\n  const canvasHeight = shapeHeight + 2 * padding;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Offset to center the shape\n  const offsetX = canvasWidth / 2 - (minX + maxX) / 2;\n  const offsetY = canvasHeight / 2 - (minY + maxY) / 2;\n\n  // Get colors\n  const foregroundColor = api.getColor('foreground');\n  const primaryColor = api.getColor('primary');\n\n  // Clear canvas\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  // Draw guides (thin grid lines) if mode is 'guides'\n  if (mode === 'guides') {\n    ctx.strokeStyle = foregroundColor;\n    ctx.lineWidth = guideLineWidth;\n\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        const cell = pattern[row][col];\n        if (cell === 'X') continue;\n\n        const x = offsetX + (col - row) * cellSize;\n        const y = offsetY + (col + row - gridSize + 1) * cellSize;\n\n        ctx.beginPath();\n        ctx.moveTo(x, y - cellSize);\n        ctx.lineTo(x + cellSize, y);\n        ctx.lineTo(x, y + cellSize);\n        ctx.lineTo(x - cellSize, y);\n        ctx.closePath();\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Draw outline\n  ctx.strokeStyle = foregroundColor;\n  ctx.lineWidth = lineWidth;\n  ctx.beginPath();\n\n  // Trace the outer boundary of the shape\n  const cells = [];\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (pattern[row][col] !== 'X') {\n        cells.push({ row, col, value: pattern[row][col] });\n      }\n    }\n  }\n\n  // Find outline by checking which edges are external\n  const edges = [];\n  for (const { row, col } of cells) {\n    const x = offsetX + (col - row) * cellSize;\n    const y = offsetY + (col + row - gridSize + 1) * cellSize;\n\n    const neighbors = [\n      { dr: -1, dc: 0, edge: [[x, y - cellSize], [x + cellSize, y]] },      // top\n      { dr: 0, dc: 1, edge: [[x + cellSize, y], [x, y + cellSize]] },       // right\n      { dr: 1, dc: 0, edge: [[x, y + cellSize], [x - cellSize, y]] },       // bottom\n      { dr: 0, dc: -1, edge: [[x - cellSize, y], [x, y - cellSize]] }       // left\n    ];\n\n    for (const { dr, dc, edge } of neighbors) {\n      const nr = row + dr;\n      const nc = col + dc;\n      if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize || pattern[nr][nc] === 'X') {\n        edges.push(edge);\n      }\n    }\n  }\n\n  // Draw outline edges\n  for (const [[x1, y1], [x2, y2]] of edges) {\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n  }\n  ctx.stroke();\n\n  // Draw divider between A and B regions if mode is 'solution' or 'guides'\n  if (mode === 'solution' || mode === 'guides') {\n    ctx.strokeStyle = primaryColor;\n    ctx.lineWidth = dividerLineWidth;\n    ctx.lineCap = 'butt';\n    ctx.beginPath();\n\n    // Find edges between A and B cells\n    for (const { row, col, value } of cells) {\n      if (value !== 'A') continue;\n\n      const x = offsetX + (col - row) * cellSize;\n      const y = offsetY + (col + row - gridSize + 1) * cellSize;\n\n      const neighbors = [\n        { dr: -1, dc: 0, edge: [[x, y - cellSize], [x + cellSize, y]] },\n        { dr: 0, dc: 1, edge: [[x + cellSize, y], [x, y + cellSize]] },\n        { dr: 1, dc: 0, edge: [[x, y + cellSize], [x - cellSize, y]] },\n        { dr: 0, dc: -1, edge: [[x - cellSize, y], [x, y - cellSize]] }\n      ];\n\n      for (const { dr, dc, edge } of neighbors) {\n        const nr = row + dr;\n        const nc = col + dc;\n        if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize && pattern[nr][nc] === 'B') {\n          const [[x1, y1], [x2, y2]] = edge;\n          ctx.moveTo(x1, y1);\n          ctx.lineTo(x2, y2);\n        }\n      }\n    }\n    ctx.stroke();\n  }\n}","startLine",55]
