<!DOCTYPE html><html lang="en" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1LM5FNK1VX"></script><meta name="color-scheme" content="dark light"/><link rel="preload" href="/assets/poppins-400-cpxAROuN.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-500-C8OXljZJ.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-600-zEkxB9Mr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-700-Qrb0O0WB.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Egg Dropping - Puzzlestone Peak</title><meta name="description" content="For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when..."/><meta property="og:title" content="Egg Dropping - Puzzlestone Peak"/><meta property="og:description" content="For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when..."/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Egg Dropping - Puzzlestone Peak"/><meta name="twitter:description" content="For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when..."/><meta name="keywords" content="optimisation, medium, logic puzzle"/><link rel="modulepreload" href="/assets/manifest-32e0cf82.js"/><link rel="modulepreload" href="/assets/entry.client-BQEHofJp.js"/><link rel="modulepreload" href="/assets/index-DIth0oIc.js"/><link rel="modulepreload" href="/assets/root-opl8c9RC.js"/><link rel="modulepreload" href="/assets/Logo-BRp-LhsU.js"/><link rel="modulepreload" href="/assets/use-dark-mode-mdHJdo6o.js"/><link rel="modulepreload" href="/assets/card-fxtljBLB.js"/><link rel="modulepreload" href="/assets/NavHeightContext-BwIQMGhB.js"/><link rel="modulepreload" href="/assets/difficulty-types-Yz_I7Ggm.js"/><link rel="modulepreload" href="/assets/expeditionIndex-fN_P2HPz.js"/><link rel="modulepreload" href="/assets/puzzleIndex-ckSbsijI.js"/><link rel="modulepreload" href="/assets/loader-circle-liqmjHjk.js"/><link rel="modulepreload" href="/assets/puzzle-detail-midM2Dmi.js"/><link rel="modulepreload" href="/assets/useBack-DqnUndht.js"/><link rel="modulepreload" href="/assets/ItemCardList-C-RxMh7h.js"/><link rel="modulepreload" href="/assets/ErrorBoundary-B5mn_yui.js"/><link rel="modulepreload" href="/assets/chevron-down-BphMwi9y.js"/><script>
              (function initTheme() {
                if (localStorage.getItem('darkmode') === '1') {
                  document.documentElement.classList.add('dark');
                }
              })();
            </script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-1LM5FNK1VX');
            </script><link rel="stylesheet" href="/assets/root-Czwq0Wb-.css"/><link rel="stylesheet" href="/assets/useBack-2KSn8t0Q.css"/></head><body><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><div class="min-h-screen bg-background"><nav class="sticky top-0 z-[1000] border-b border-border bg-card"><div class="container mx-auto px-6"><div class="flex h-16 items-center justify-between"><a class="flex items-center gap-3 text-nav-foreground no-underline" href="/" data-discover="true"><svg class="h-10 w-10 text-nav-foreground" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2211.37 2208.98" aria-label="Puzzlestone Peak Logo"><g><g><path fill="currentColor" d="M1108.28,0c649.77,5.24,1114.13,533.8,1102.89,1120-11.85,618.13-493.23,1100.61-1128,1088.81C450,2197-8.61,1690.25.12,1087.2,8.81,487.59,492.57,4.1,1108.28,0ZM121.13,1114.76c1.14,543.44,432.5,984.51,996.37,978.51,557.06-5.93,978-444.2,971.35-995.6C2082,528.37,1628.73,114,1095.67,118.84,573.44,123.64,121,538.05,121.13,1114.76Z"></path><path fill="currentColor" d="M2021.18,1304.81c-125.17-118.57-243.11-238.8-364.9-359.1-2.56,14.24,1.92,24,3.82,33.95,4.41,23.07,11.61,45.81,13.73,69.05,4,43.53,24.59,76.14,55.56,106,57.17,55,111.85,112.69,167.64,169.19,3.08,3.11,6.78,5.62,13.43,11.07l-29.92-94c24.62,13.75,40.06,32.2,57.87,47.59,20.91,18.06,40.77,37.34,61.77,55.28,8.84,7.54,10.58,14.7,7.36,25.8-20.06,69.13-47.63,135-81.34,198.6-9.36,17.65-14.91,9.53-22.48,0q-90.9-114.8-181.89-229.53-95.47-120.15-191.27-240c-1-1.26-2.64-2-7-5.25,9.72,71.9,28.35,139.3,37.91,208.53-107.81-169.7-206.63-344.59-311.28-516-9.22,3.51-3.87,12.13-10,16-12-7.35-18.72-20.06-27.45-30.66q-45.4-55.15-89.63-111.28c-9.15-11.66-14.16-9.84-23.87.14-12.63,13-13.15,24.45-6.86,40.56,17.11,43.76,35.07,87.25,48.64,132.33,1,3.28,1.72,6.64,3.84,14.9L1022.35,771.4l-2.78,2.64c13.51,22.36,26.89,44.8,40.55,67.06,24.58,40.09,49,80.27,74.21,120,6,9.48,6,15.92-1.51,24.54-28.26,32.31-55.84,65.21-83.61,97.95-15.86,18.69-15.92,18.85,1.06,35.86q114.7,114.87,229.51,229.63c2.84,2.84,5.41,6,11.73,12.92-46.79-8.28-88.16-19-132.09-25.8l298,291.64,3.93-2.17L1430.53,1306c23.59,34.58,44.25,64.91,65,95.22q123.36,180.63,251.43,357.94c1.38,1.9,2.39,4.13,4,5.79,13.32,13.77,9.47,24-4.25,35.81-47.75,41.22-98,78.83-151.9,111.65-8.1,4.94-16.34,5.41-25.27,5.45-104.54.45-203.43-26.94-300.81-61.29-107-37.74-210.39-84.76-315.67-126.92-149.26-59.78-302.65-102.49-463-118.55-55.13-5.53-110.43-4.65-165.7-3.63-9.28.18-16.45-.49-22-10-61.64-105.06-105-216.59-122.31-337.73-1.51-10.61,1.49-17.46,8.71-24.81q184.24-187.54,367.82-375.72c10-10.28,15.36-7.56,23.67,1.12,35.77,37.39,72.31,74.05,108,111.53,8.31,8.73,13.08,10.25,21.86.21Q871.5,787.48,1033.71,603.54c21-23.84,42.59-47.13,63.21-71.27,8.62-10.09,13.52-8.08,21.52,1q195.46,222.81,391.26,445.32c9.78,11.18,14.44,10.28,23.92.32,36.07-37.91,73.29-74.72,109.47-112.54,8.26-8.63,13.09-7.71,20.87.25q175.07,179.21,350.85,357.7c13.23,13.39,20.15,25.9,13.9,44.57C2025.39,1278.84,2024.3,1289.49,2021.18,1304.81ZM564.41,931.41c0,18.05-1.59,31,.28,43.31,7.16,47.25-7.05,85.12-43.68,116.5-15.75,13.5-32.89,30.56-38.74,49.32-11,35.33-14.27,73.08-20.87,110.49,8.29-1,11-6.85,14.51-11.08q84.69-101.51,174.52-198.49c8.71-9.46,11.86-16.15.08-25.48-9.14-7.24-16.56-16.62-24.93-24.86C606.56,972.43,587.42,953.86,564.41,931.41Z"></path><path fill="currentColor" d="M1258,2036.19c-156.22,31.67-307.68,13.84-456-37.14-128-44-242.37-111.53-346.16-205.19,33.78-3.18,62.72.36,91.57,3.41,177.71,18.78,340.49,86.11,502.68,155.25,63.74,27.17,127.88,53.3,193.63,75.29C1248.52,2029.42,1254.05,2029.85,1258,2036.19Z"></path><path fill="currentColor" d="M1461.61,671.32c.48-75.58,59.09-133.3,135-132.91,69.62.35,129.18,61.43,128.77,132.05-.43,74-59.91,132.06-134.66,131.48C1518.42,801.37,1461.15,743.42,1461.61,671.32Z"></path></g></g></svg><span class="text-[1.25rem] font-semibold leading-none">Puzzlestone Peak</span></a><div class="hidden items-center gap-6 md:flex"><ul class="flex items-center gap-8"><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/progress" data-discover="true">Progress</a></li></ul><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div><button class="flex h-8 w-8 cursor-pointer flex-col justify-around border-none bg-transparent p-1 text-nav-foreground md:hidden" aria-label="Toggle mobile menu" aria-expanded="false" aria-controls="mobile-menu"><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span></button></div></div></nav><div id="mobile-menu" class="fixed left-0 right-0 top-16 z-[999] border-b border-border bg-card shadow-lg transition-all duration-300 md:hidden pointer-events-none -translate-y-full opacity-0"><div class="px-6 pb-6 pt-4"><ul class="flex flex-col gap-3"><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/progress" data-discover="true">Progress</a></li></ul><div class="mt-4 flex justify-center border-t border-border pt-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div></div></div><main><div class="container mx-auto px-4 py-6 max-w-4xl"><a class="inline-flex items-center text-link hover:text-link-hover hover:underline mb-6 cursor-pointer" href="/puzzles" data-discover="true">← Back</a><div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-4"><h1 class="text-4xl font-bold text-foreground sm:flex-1">Egg Dropping</h1><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><div class="space-y-4 border-b border-divider pb-6 mb-6"><div><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="text-sm text-muted-foreground"><span>Created: <!-- -->February 2, 2026</span></div></div><div class="markdown-content prose max-w-none space-y-4"></div><div class="flex justify-center my-8"><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><section class="mt-12"><h2 class="mb-6 text-xl font-bold text-foreground lg:text-2xl">Try These Next</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/hummingbird" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Hummingbird</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">A train leaves Oakridge at 20 km/h, headed for Fairhaven. At the same time, another train leaves Fairhaven at 30 km/h, headed for Oakridge on the same track....</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/guessing-hats-3" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Guessing Hats 3</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">The king’s challenges are growing crueller. This time, three wise men stand in a room, each wearing either a black or white hat chosen at random by a coin...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/taking-pills" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Taking Pills</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">After falling ill, Josh sees a doctor and is prescribed some medication. He is to take 1 pill of Xenoril and 1 pill of Yvexol every 24 hours. The two pills...</p></div></a></div></section></div></main></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":false,"unstable_splitRouteModules":false,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-32e0cf82.js";
import * as route0 from "/assets/root-opl8c9RC.js";
import * as route1 from "/assets/puzzle-detail-midM2Dmi.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/puzzle-detail":route1};

import("/assets/entry.client-BQEHofJp.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_253\":-5,\"_254\":-5},\"loaderData\",{\"_3\":4},\"routes/puzzle-detail\",{\"_5\":6,\"_7\":8,\"_9\":10},\"status\",\"success\",\"slug\",\"egg-dropping\",\"puzzle\",{\"_7\":8,\"_11\":12,\"_35\":36,\"_37\":38,\"_39\":40,\"_245\":246},\"metadata\",{\"_13\":14,\"_15\":16,\"_17\":18,\"_19\":20,\"_22\":23,\"_24\":25,\"_27\":28,\"_29\":28,\"_30\":31,\"_32\":33,\"_34\":33},\"id\",\"puzzle-40\",\"title\",\"Egg Dropping\",\"questionPreview\",\"You’ve devised an egg-protection device for a school project. With two prototypes and a 100-storey building, what’s the fewest drops to find the break floor?\\n\",\"concepts\",[21],\"optimisation\",\"difficulty\",\"medium\",\"tags\",[26],\"has-solution\",\"dateCreated\",\"2026-02-02\",\"lastUpdated\",\"credit\",\"Classic puzzle.\\nQuestion and solution by Puzzlestone Peak.\\n\",\"preview\",\"For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when...\",\"websitePreview\",\"content\",\"\u003cp\u003eFor a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.\u003c/p\u003e\\n\u003cp\u003eNear your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.\u003c/p\u003e\\n\u003cp\u003eWhat is the minimum number of drops you’d ever need in the \u003cstrong\u003eworst case\u003c/strong\u003e to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.\u003c/p\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint 1\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eExperiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint 2\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eIf you only had 1 device, you cannot do better than 100 drops in the worst case. Why?\u003c/p\u003e\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eLet’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.\u003c/p\u003e\u003cp\u003eThis means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\u003cp\u003eNow consider what happens when you have 2 devices.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint 3\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eIf your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?\u003c/p\u003e\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eYou would have to do 50 drops in the worst case scenario.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCase 1\u003c/strong\u003e: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCase 2\u003c/strong\u003e: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003e\u003cstrong\u003eAnswer\u003c/strong\u003e: 14 drops.\u003c/p\u003e\u003cp\u003eLet’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?\u003c/p\u003e\u003cp\u003eFirst, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eFirst drop: Drop from floor 3.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 1, then 2. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, drop from floor 6.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 4, then 5. Worst case: 4 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, then we know the device survives all 6 floors.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\u003cp\u003eThis gives us a worst case of 4 moves.\u003c/p\u003e\u003cp\u003eLet's come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"0\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWhen the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we're left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"1\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let's try a different strategy:\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eFirst drop: Drop from floor 2.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 1. Worst case: 2 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, drop from floor 4.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 3. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, test floor 6.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 5. Worst case: 4 moves\u003c/li\u003e\\n\u003cli\u003eIf it doesn't break, then we know the device survives all 6 floors.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"2\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eHmm, we're still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we've found the optimal number of drops?\u003c/p\u003e\u003cp\u003eNo! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2). In version 2, we have (Start → 2 → 1) and (Start → 2 → 4 → 3). If we could make these longer in order to shorten the worst-case path, we'll find a better solution. And in fact, we can!\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eFirst drop: Drop from floor 3.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 1, then 2. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, drop from floor 5.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 4. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn't break, test floor 6. Worst case: 3 moves.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"3\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNo matter which path we take, we'll always end up with 3 moves in the worst case.\u003c/p\u003e\u003cp\u003eWith this visualisation in mind, let's explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"4\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eOof, that's rough. It seems like we're not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.\u003c/p\u003e\u003cp\u003eHow about steps of 10? This time, we'll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"5\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIn the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let's lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmn\u003e14\u003c/mn\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e13\u003c/mn\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e27\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation\u003e14 + 13 = 27\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e14\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mbin\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e13\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mrel\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e27\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e. Then the following drop should be \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmn\u003e27\u003c/mn\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e12\u003c/mn\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e39\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation\u003e27 + 12 = 39\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e27\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mbin\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e12\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mrel\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e39\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e. Continuing this way, we get a chart of:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"6\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIn the worst case scenario, we have 14 moves, and we can't do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"7\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cdiv class=\\\"content-block note-block note-note\\\" data-type=\\\"note\\\" data-note-type=\\\"note\\\"\u003e\u003cdiv class=\\\"note-header note-note-header\\\"\u003eAn Extension\u003c/div\u003e\u003cdiv class=\\\"note-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eNow that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:\u003c/p\u003e\u003col\u003e\\n\u003cli\u003eFor 2 devices, what is the minimum worst-case number of drops for a building of \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e storeys?\u003c/li\u003e\\n\u003cli\u003eFor 2 devices, what is the maximum building height coverable with at most \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ek\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003ek\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\"\u003ek\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e drops in the worst case?\u003c/li\u003e\\n\u003cli\u003eFor \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ed\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003ed\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003ed\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e devices and an \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e-storey building, what is the minimum worst-case number of drops?\u003c/li\u003e\\n\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\",\"rawContent\",\"\\nFor a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.\\n\\nNear your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.\\n\\nWhat is the minimum number of drops you’d ever need in the **worst case** to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.\\n\\n\\n:::hint[Hint 1]\\nExperiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.\\n:::\\n\\n::::hint[Hint 2]\\nIf you only had 1 device, you cannot do better than 100 drops in the worst case. Why?\\n\\n:::solution\\nLet’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.\\n\\nThis means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.\\n:::\\n\\nNow consider what happens when you have 2 devices.\\n::::\\n\\n::::hint[Hint 3]\\nIf your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?\\n\\n:::solution\\nYou would have to do 50 drops in the worst case scenario.\\n\\n**Case 1**: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.\\n\\n**Case 2**: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.\\n:::\\n::::\\n\\n::::solution\\n**Answer**: 14 drops.\\n\\nLet’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?\\n\\nFirst, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:\\n\\n- First drop: Drop from floor 3.\\n    - If it breaks, test floor 1, then 2. Worst case: 3 moves.\\n    - If it doesn’t break, drop from floor 6.\\n        - If it breaks, test floor 4, then 5. Worst case: 4 moves.\\n        - If it doesn’t break, then we know the device survives all 6 floors.\\n\\nThis gives us a worst case of 4 moves.\\n\\nLet's come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Simple strategy: drop from floor 3, then floor 6\\\"\\nariaLabel: Three nodes in a horizontal chain — start, floor 3, floor 6\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - \\\"3\\\"\\n    - \\\"6\\\"\\n```\\n:::\\n\\nWhen the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we're left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: floors 3 and 6 with fallback chains\\\"\\nariaLabel: Strategy tree with start node, floor 3 with chain 1 and 2 below, floor 6 with chain 4 and 5 below\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"3\\\"\\n      chain: [1, 2]\\n    - label: \\\"6\\\"\\n      chain: [4, 5]\\n  showDepth: true\\n```\\n:::\\n\\nWe can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let's try a different strategy:\\n\\n- First drop: Drop from floor 2.\\n    - If it breaks, test floor 1. Worst case: 2 moves.\\n    - If it doesn’t break, drop from floor 4.\\n        - If it breaks, test floor 3. Worst case: 3 moves.\\n        - If it doesn’t break, test floor 6.\\n            - If it breaks, test floor 5. Worst case: 4 moves\\n            - If it doesn't break, then we know the device survives all 6 floors.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: floors 2, 4, and 6 with single fallbacks\\\"\\nariaLabel: Strategy tree with start, floor 2 dropping to 1, floor 4 dropping to 3, floor 6 dropping to 5\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"2\\\"\\n      chain: [1]\\n    - label: \\\"4\\\"\\n      chain: [3]\\n    - label: \\\"6\\\"\\n      chain: [5]\\n  showDepth: true\\n```\\n:::\\n\\nHmm, we're still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we've found the optimal number of drops?\\n\\nNo! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2). In version 2, we have (Start → 2 → 1) and (Start → 2 → 4 → 3). If we could make these longer in order to shorten the worst-case path, we'll find a better solution. And in fact, we can!\\n\\n- First drop: Drop from floor 3.\\n    - If it breaks, test floor 1, then 2. Worst case: 3 moves.\\n    - If it doesn’t break, drop from floor 5.\\n        - If it breaks, test floor 4. Worst case: 3 moves.\\n        - If it doesn't break, test floor 6. Worst case: 3 moves.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Optimal strategy tree for 6 floors\\\"\\nariaLabel: Strategy tree with start, floor 3 dropping to 2 then 1, floor 5 dropping to 4, floor 6 with no chain\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"3\\\"\\n      chain: [1, 2]\\n    - label: \\\"5\\\"\\n      chain: [4]\\n    - \\\"6\\\"\\n  showDepth: true\\n```\\n:::\\n\\nNo matter which path we take, we'll always end up with 3 moves in the worst case.\\n\\nWith this visualisation in mind, let's explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:\\n\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: binary split from floor 50\\\"\\nariaLabel: Strategy tree showing drops from floors 50, 75, and 100 with long fallback chains\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"50\\\"\\n      chain: [1, 2, \\\"...\\\", \\\"...\\\", \\\"...\\\", \\\"...\\\", 49]\\n    - label: \\\"75\\\"\\n      chain: [51, 52, \\\"...\\\", 74]\\n    - label: \\\"100\\\"\\n      chain: [76, 77, \\\"...\\\", 98, 99]\\n  showDepth: true\\n  minWidth: 350\\n```\\n:::\\n\\nOof, that's rough. It seems like we're not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.\\n\\nHow about steps of 10? This time, we'll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: steps of 10\\\"\\nariaLabel: Strategy tree showing drops from floors 10, 20, 30 with full fallback chains of 9 floors each\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"10\\\"\\n      chain: { from: 1, to: 9 }\\n    - label: \\\"20\\\"\\n      chain: { from: 11, to: 19 }\\n    - label: \\\"30\\\"\\n      chain: { from: 21, to: 29 }\\n    - \\\"...\\\"\\n    - label: \\\"80\\\"\\n      chain: { from: 71, to: 79 }\\n      depth: 17\\n    - label: \\\"90\\\"\\n      chain: { from: 81, to: 89 }\\n      depth: 18\\n    - label: \\\"100\\\"\\n      chain: { from: 91, to: 99 }\\n      depth: 19\\n  showDepth: true\\n  minWidth: 550\\n```\\n:::\\n\\nIn the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let's lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be $14 + 13 = 27$. Then the following drop should be $27 + 12 = 39$. Continuing this way, we get a chart of:\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Optimal strategy tree for 100 floors\\\"\\nariaLabel: Strategy tree with decreasing jumps starting at floor 14, covering all 100 floors in at most 14 drops\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"14\\\"\\n      chain: { from: 1, to: 13 }\\n    - label: \\\"27\\\"\\n      chain: { from: 15, to: 26 }\\n    - label: \\\"39\\\"\\n      chain: { from: 28, to: 38 }\\n    - label: \\\"50\\\"\\n      chain: { from: 40, to: 49 }\\n    - label: \\\"60\\\"\\n      chain: { from: 51, to: 59 }\\n    - label: \\\"69\\\"\\n      chain: { from: 61, to: 68 }\\n    - label: \\\"77\\\"\\n      chain: { from: 70, to: 76 }\\n    - label: \\\"84\\\"\\n      chain: { from: 78, to: 83 }\\n    - label: \\\"90\\\"\\n      chain: { from: 85, to: 89 }\\n    - label: \\\"95\\\"\\n      chain: { from: 91, to: 94 }\\n    - label: \\\"99\\\"\\n      chain: { from: 96, to: 98 }\\n    - \\\"100\\\"\\n  showDepth: true\\n  minWidth: 700\\n```\\n:::\\n\\nIn the worst case scenario, we have 14 moves, and we can't do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Maximum building height with 14 drops: 105 floors\\\"\\nariaLabel: Strategy tree for 14 drops covering up to 105 floors, with every path exactly 14 steps\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"14\\\"\\n      chain: { from: 1, to: 13 }\\n    - label: \\\"27\\\"\\n      chain: { from: 15, to: 26 }\\n    - label: \\\"39\\\"\\n      chain: { from: 28, to: 38 }\\n    - label: \\\"50\\\"\\n      chain: { from: 40, to: 49 }\\n    - label: \\\"60\\\"\\n      chain: { from: 51, to: 59 }\\n    - label: \\\"69\\\"\\n      chain: { from: 61, to: 68 }\\n    - label: \\\"77\\\"\\n      chain: { from: 70, to: 76 }\\n    - label: \\\"84\\\"\\n      chain: { from: 78, to: 83 }\\n    - label: \\\"90\\\"\\n      chain: { from: 85, to: 89 }\\n    - label: \\\"95\\\"\\n      chain: { from: 91, to: 94 }\\n    - label: \\\"99\\\"\\n      chain: { from: 96, to: 98 }\\n    - label: \\\"102\\\"\\n      chain: [100, 101]\\n    - label: \\\"104\\\"\\n      chain: [103]\\n    - \\\"105\\\"\\n  showDepth: true\\n  minWidth: 800\\n```\\n:::\\n\\n:::note[An Extension]\\nNow that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:\\n\\n1. For 2 devices, what is the minimum worst-case number of drops for a building of $n$ storeys?\\n2. For 2 devices, what is the maximum building height coverable with at most $k$ drops in the worst case?\\n3. For $d$ devices and an $n$-storey building, what is the minimum worst-case number of drops?\\n:::\\n\\n::::\\n\\n\\n:::component[strategy-tree]\\n```yaml\\nmode: canvas\\ntitle: Strategy tree diagram\\nariaLabel: Horizontal chain of decision nodes with vertical fallback chains descending below\\n```\\n\\n```js\\n// Normalize columns: expand ranges, compute full chain length\\nfunction normalizeColumns(rawColumns) {\\n  return rawColumns.map(col =\u003e {\\n    // Handle shorthand: plain string → { label: \\\"X\\\" }\\n    if (typeof col === 'string') {\\n      return { label: col, chain: [], fullChainLength: 0, depth: null };\\n    }\\n\\n    const { label, chain, depth } = col;\\n    let chainLabels = [];\\n    let fullLength = 0;\\n\\n    if (!chain) {\\n      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };\\n    }\\n\\n    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]\\n    if (typeof chain === 'object' \u0026\u0026 !Array.isArray(chain)) {\\n      const { from, to } = chain;\\n      fullLength = to - from + 1;\\n      for (let i = from; i \u003c= to; i++) {\\n        chainLabels.push(String(i));\\n      }\\n    } else {\\n      chainLabels = chain.map(String);\\n      // Derive full length from first and last numeric items\\n      const nums = chainLabels.filter(l =\u003e l !== '...').map(Number);\\n      if (nums.length \u003e= 2) {\\n        fullLength = nums[nums.length - 1] - nums[0] + 1;\\n      } else {\\n        fullLength = nums.length;\\n      }\\n    }\\n\\n    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };\\n  });\\n}\\n\\n// Compute layout parameters based on columns and container width\\nfunction computeLayout(columns, containerWidth, options) {\\n  const { showDepth, minWidth } = options;\\n  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;\\n  const numCols = columns.length;\\n\\n  // Column spacing (+1 for right-side padding so last node isn't clipped)\\n  const totalSpacing = numCols + 1;\\n  const spacing = Math.min(effectiveWidth / totalSpacing, 100);\\n  const radius = Math.min(spacing * 0.35, 20);\\n\\n  // Vertical spacing\\n  const verticalSpacing = radius * 3;\\n\\n  // Calculate height needed\\n  let maxVisibleChainLength = 0;\\n  for (const col of columns) {\\n    if (col.chain.length \u003e maxVisibleChainLength) {\\n      maxVisibleChainLength = col.chain.length;\\n    }\\n  }\\n\\n  const topRowY = radius * 2.5;\\n  const chainStartY = topRowY + verticalSpacing;\\n  let canvasHeight;\\n\\n  if (maxVisibleChainLength \u003e 0) {\\n    // Bottom of the deepest chain node circle\\n    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;\\n  } else {\\n    // No chains: bottom of top row circles\\n    canvasHeight = topRowY + radius;\\n  }\\n\\n  if (showDepth) {\\n    // Depth labels: radius gap below circle + up to 2 lines of text\\n    canvasHeight += radius * 3;\\n  }\\n\\n  canvasHeight += radius; // Bottom padding\\n\\n  return {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth: totalSpacing * spacing\\n  };\\n}\\n\\n// Draw a circle with centered label\\nfunction drawCircleNode(ctx, x, y, radius, label, colors, fonts) {\\n  const { fill, stroke, text } = colors;\\n  const { fontFamily } = fonts;\\n\\n  // Circle\\n  ctx.beginPath();\\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\\n  ctx.fillStyle = fill;\\n  ctx.fill();\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.stroke();\\n\\n  // Label\\n  ctx.fillStyle = text;\\n  ctx.textAlign = 'center';\\n  ctx.textBaseline = 'middle';\\n\\n  // Font size based on label length\\n  let fontSize;\\n  if (label.length \u003c= 2) {\\n    fontSize = radius * 0.9;\\n  } else if (label.length === 3) {\\n    fontSize = radius * 0.75;\\n  } else {\\n    fontSize = radius * 0.6;\\n  }\\n\\n  ctx.font = `bold ${fontSize}px ${fontFamily}`;\\n  ctx.fillText(label, x, y);\\n}\\n\\n// Draw an arrowhead at the given tip position and angle\\nfunction drawArrowhead(ctx, tipX, tipY, angle, radius) {\\n  const size = Math.max(3, radius * 0.3);\\n  ctx.save();\\n  ctx.translate(tipX, tipY);\\n  ctx.rotate(angle);\\n  ctx.beginPath();\\n  ctx.moveTo(0, 0);\\n  ctx.lineTo(-size, -size * 0.6);\\n  ctx.lineTo(-size, size * 0.6);\\n  ctx.closePath();\\n  ctx.fill();\\n  ctx.restore();\\n}\\n\\n// Draw a connection line between two nodes with optional arrowhead\\nfunction drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {\\n  const { stroke } = colors;\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.lineCap = 'round';\\n\\n  // Calculate start and end points at circle boundary\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  const dist = Math.sqrt(dx * dx + dy * dy);\\n  const angle = Math.atan2(dy, dx);\\n\\n  const startX = x1 + (dx / dist) * radius;\\n  const startY = y1 + (dy / dist) * radius;\\n  const endX = x2 - (dx / dist) * radius;\\n  const endY = y2 - (dy / dist) * radius;\\n\\n  // Draw line\\n  ctx.beginPath();\\n  ctx.moveTo(startX, startY);\\n  ctx.lineTo(endX, endY);\\n  ctx.stroke();\\n\\n  // Draw arrowhead\\n  if (showArrows) {\\n    ctx.fillStyle = stroke;\\n    drawArrowhead(ctx, endX, endY, angle, radius);\\n  }\\n}\\n\\n// Draw three vertical ellipsis dots\\nfunction drawVerticalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\n// Draw three horizontal ellipsis dots\\nfunction drawHorizontalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nfunction draw(options) {\\n  const { canvas, api, width: containerWidth, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Default props\\n  const {\\n    columns: rawColumns = [],\\n    showDepth = false,\\n    showArrows = true,\\n    minWidth = 0,\\n  } = props;\\n\\n  if (!rawColumns || rawColumns.length === 0) {\\n    canvas.width = containerWidth;\\n    canvas.height = 100;\\n    ctx.fillStyle = api.getColor('muted-foreground');\\n    ctx.font = `14px ${api.getFont('default')}`;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'middle';\\n    ctx.fillText('No columns provided', containerWidth / 2, 50);\\n    api.requestResize(100);\\n    return;\\n  }\\n\\n  // Normalize columns\\n  const columns = normalizeColumns(rawColumns);\\n\\n  // Compute layout\\n  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });\\n  const {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth\\n  } = layout;\\n\\n  canvas.width = canvasWidth;\\n  canvas.height = canvasHeight;\\n\\n  // Colors (theme-aware)\\n  const foreground = api.getColor('foreground');\\n  const cardBg = api.getColor('card');\\n  const mutedBg = api.getColor('muted');\\n  const mutedFg = api.getColor('muted-foreground');\\n  const primaryColor = api.getColor('primary');\\n\\n  const colors = {\\n    stroke: foreground,\\n    fill: cardBg,\\n    mutedFill: mutedBg,\\n    text: foreground,\\n    ellipsis: mutedFg,\\n    depth: primaryColor\\n  };\\n\\n  const fonts = {\\n    fontFamily: api.getFont('default'),\\n    monoFamily: api.getFont('mono')\\n  };\\n\\n  // Track y-positions for each column's chain\\n  const columnYPositions = columns.map(() =\u003e []);\\n\\n  // Draw horizontal chain nodes\\n  for (let i = 0; i \u003c columns.length; i++) {\\n    const col = columns[i];\\n    const x = (i + 1) * spacing;\\n    const y = topRowY;\\n\\n    if (col.label === '...') {\\n      // Draw horizontal ellipsis dots instead of a circle\\n      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);\\n    } else {\\n      // First column uses muted background\\n      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;\\n      const nodeColors = { ...colors, fill: nodeFill };\\n      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);\\n    }\\n\\n    // Draw horizontal connection to next column\\n    if (i \u003c columns.length - 1) {\\n      const nextX = (i + 2) * spacing;\\n      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);\\n    }\\n\\n    // Track positions for vertical chains\\n    columnYPositions[i].push({ x, y });\\n  }\\n\\n  // Draw vertical chains\\n  for (let colIdx = 0; colIdx \u003c columns.length; colIdx++) {\\n    const col = columns[colIdx];\\n    if (col.chain.length === 0) continue;\\n\\n    const x = (colIdx + 1) * spacing;\\n    let currentY = chainStartY;\\n\\n    for (let chainIdx = 0; chainIdx \u003c col.chain.length; chainIdx++) {\\n      const label = col.chain[chainIdx];\\n      const isEllipsis = label === '...';\\n\\n      if (isEllipsis) {\\n        // Draw vertical ellipsis dots centered where the circle would be\\n        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      } else {\\n        // Draw regular node\\n        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      }\\n    }\\n  }\\n\\n  // Draw depth labels if enabled (for all columns except start and ellipsis)\\n  if (showDepth) {\\n    const fontSize = radius * 0.7;\\n    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\\n    ctx.fillStyle = colors.depth;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'top';\\n\\n    for (let colIdx = 1; colIdx \u003c columns.length; colIdx++) {\\n      const col = columns[colIdx];\\n      if (col.label === '...') continue;\\n      const x = (colIdx + 1) * spacing;\\n      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];\\n      const depth = col.depth ?? (colIdx + col.fullChainLength);\\n      const depthY = lastPos.y + radius * 2;\\n      const word = depth === 1 ? 'move' : 'moves';\\n      const singleLine = `${depth} ${word}`;\\n\\n      // Check if single line fits within column spacing\\n      const textWidth = ctx.measureText(singleLine).width;\\n      if (textWidth \u003c spacing * 0.95) {\\n        ctx.fillText(singleLine, x, depthY);\\n      } else {\\n        ctx.fillText(String(depth), x, depthY);\\n        ctx.fillText(word, x, depthY + fontSize * 1.2);\\n      }\\n    }\\n  }\\n\\n  // Resize iframe to fit canvas\\n  api.requestResize(canvasHeight);\\n}\\n```\\n:::\",\"dynamicBlocks\",[41,58,74,87,96,120,157,208],{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":49,\"_15\":55,\"_56\":57},\"type\",\"dynamic\",\"mode\",\"component\",\"componentId\",\"#strategy-tree\",\"props\",{\"_50\":51},\"columns\",[52,53,54],\"S\",\"3\",\"6\",\"Simple strategy: drop from floor 3, then floor 6\",\"sourceFile\",\"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/optimisation/egg-dropping.md\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":59,\"_15\":73,\"_56\":57},{\"_50\":60,\"_71\":72},[52,61,67],{\"_62\":53,\"_63\":64},\"label\",\"chain\",[65,66],1,2,{\"_62\":54,\"_63\":68},[69,70],4,5,\"showDepth\",true,\"Strategy tree: floors 3 and 6 with fallback chains\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":75,\"_15\":86,\"_56\":57},{\"_50\":76,\"_71\":72},[52,77,80,84],{\"_62\":78,\"_63\":79},\"2\",[65],{\"_62\":81,\"_63\":82},\"4\",[83],3,{\"_62\":54,\"_63\":85},[70],\"Strategy tree: floors 2, 4, and 6 with single fallbacks\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":88,\"_15\":95,\"_56\":57},{\"_50\":89,\"_71\":72},[52,90,92,54],{\"_62\":53,\"_63\":91},[65,66],{\"_62\":93,\"_63\":94},\"5\",[69],\"Optimal strategy tree for 6 floors\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":97,\"_15\":119,\"_56\":57},{\"_50\":98,\"_71\":72,\"_117\":118},[52,99,104,110],{\"_62\":100,\"_63\":101},\"50\",[65,66,102,102,102,102,103],\"...\",49,{\"_62\":105,\"_63\":106},\"75\",[107,108,102,109],51,52,74,{\"_62\":111,\"_63\":112},\"100\",[113,114,102,115,116],76,77,98,99,\"minWidth\",350,\"Strategy tree: binary split from floor 50\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":121,\"_15\":156,\"_56\":57},{\"_50\":122,\"_71\":72,\"_117\":155},[52,123,129,134,102,139,146,152],{\"_62\":124,\"_63\":125},\"10\",{\"_126\":65,\"_127\":128},\"from\",\"to\",9,{\"_62\":130,\"_63\":131},\"20\",{\"_126\":132,\"_127\":133},11,19,{\"_62\":135,\"_63\":136},\"30\",{\"_126\":137,\"_127\":138},21,29,{\"_62\":140,\"_63\":141,\"_144\":145},\"80\",{\"_126\":142,\"_127\":143},71,79,\"depth\",17,{\"_62\":147,\"_63\":148,\"_144\":151},\"90\",{\"_126\":149,\"_127\":150},81,89,18,{\"_62\":111,\"_63\":153,\"_144\":133},{\"_126\":154,\"_127\":116},91,550,\"Strategy tree: steps of 10\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":158,\"_15\":207,\"_56\":57},{\"_50\":159,\"_71\":72,\"_117\":206},[52,160,164,169,174,177,181,186,190,195,198,202,111],{\"_62\":161,\"_63\":162},\"14\",{\"_126\":65,\"_127\":163},13,{\"_62\":165,\"_63\":166},\"27\",{\"_126\":167,\"_127\":168},15,26,{\"_62\":170,\"_63\":171},\"39\",{\"_126\":172,\"_127\":173},28,38,{\"_62\":100,\"_63\":175},{\"_126\":176,\"_127\":103},40,{\"_62\":178,\"_63\":179},\"60\",{\"_126\":107,\"_127\":180},59,{\"_62\":182,\"_63\":183},\"69\",{\"_126\":184,\"_127\":185},61,68,{\"_62\":187,\"_63\":188},\"77\",{\"_126\":189,\"_127\":113},70,{\"_62\":191,\"_63\":192},\"84\",{\"_126\":193,\"_127\":194},78,83,{\"_62\":147,\"_63\":196},{\"_126\":197,\"_127\":150},85,{\"_62\":199,\"_63\":200},\"95\",{\"_126\":154,\"_127\":201},94,{\"_62\":203,\"_63\":204},\"99\",{\"_126\":205,\"_127\":115},96,700,\"Optimal strategy tree for 100 floors\",{\"_42\":43,\"_44\":45,\"_46\":47,\"_48\":209,\"_15\":244,\"_56\":57},{\"_50\":210,\"_71\":72,\"_117\":243},[52,211,213,215,217,219,221,223,225,227,229,231,233,238,242],{\"_62\":161,\"_63\":212},{\"_126\":65,\"_127\":163},{\"_62\":165,\"_63\":214},{\"_126\":167,\"_127\":168},{\"_62\":170,\"_63\":216},{\"_126\":172,\"_127\":173},{\"_62\":100,\"_63\":218},{\"_126\":176,\"_127\":103},{\"_62\":178,\"_63\":220},{\"_126\":107,\"_127\":180},{\"_62\":182,\"_63\":222},{\"_126\":184,\"_127\":185},{\"_62\":187,\"_63\":224},{\"_126\":189,\"_127\":113},{\"_62\":191,\"_63\":226},{\"_126\":193,\"_127\":194},{\"_62\":147,\"_63\":228},{\"_126\":197,\"_127\":150},{\"_62\":199,\"_63\":230},{\"_126\":154,\"_127\":201},{\"_62\":203,\"_63\":232},{\"_126\":205,\"_127\":115},{\"_62\":234,\"_63\":235},\"102\",[236,237],100,101,{\"_62\":239,\"_63\":240},\"104\",[241],103,\"105\",800,\"Maximum building height with 14 drops: 105 floors\",\"inlineComponents\",{\"_247\":248},\"strategy-tree\",{\"_13\":247,\"_249\":250,\"_251\":252},\"code\",\"// Normalize columns: expand ranges, compute full chain length\\nfunction normalizeColumns(rawColumns) {\\n  return rawColumns.map(col =\u003e {\\n    // Handle shorthand: plain string → { label: \\\"X\\\" }\\n    if (typeof col === 'string') {\\n      return { label: col, chain: [], fullChainLength: 0, depth: null };\\n    }\\n\\n    const { label, chain, depth } = col;\\n    let chainLabels = [];\\n    let fullLength = 0;\\n\\n    if (!chain) {\\n      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };\\n    }\\n\\n    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]\\n    if (typeof chain === 'object' \u0026\u0026 !Array.isArray(chain)) {\\n      const { from, to } = chain;\\n      fullLength = to - from + 1;\\n      for (let i = from; i \u003c= to; i++) {\\n        chainLabels.push(String(i));\\n      }\\n    } else {\\n      chainLabels = chain.map(String);\\n      // Derive full length from first and last numeric items\\n      const nums = chainLabels.filter(l =\u003e l !== '...').map(Number);\\n      if (nums.length \u003e= 2) {\\n        fullLength = nums[nums.length - 1] - nums[0] + 1;\\n      } else {\\n        fullLength = nums.length;\\n      }\\n    }\\n\\n    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };\\n  });\\n}\\n\\n// Compute layout parameters based on columns and container width\\nfunction computeLayout(columns, containerWidth, options) {\\n  const { showDepth, minWidth } = options;\\n  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;\\n  const numCols = columns.length;\\n\\n  // Column spacing (+1 for right-side padding so last node isn't clipped)\\n  const totalSpacing = numCols + 1;\\n  const spacing = Math.min(effectiveWidth / totalSpacing, 100);\\n  const radius = Math.min(spacing * 0.35, 20);\\n\\n  // Vertical spacing\\n  const verticalSpacing = radius * 3;\\n\\n  // Calculate height needed\\n  let maxVisibleChainLength = 0;\\n  for (const col of columns) {\\n    if (col.chain.length \u003e maxVisibleChainLength) {\\n      maxVisibleChainLength = col.chain.length;\\n    }\\n  }\\n\\n  const topRowY = radius * 2.5;\\n  const chainStartY = topRowY + verticalSpacing;\\n  let canvasHeight;\\n\\n  if (maxVisibleChainLength \u003e 0) {\\n    // Bottom of the deepest chain node circle\\n    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;\\n  } else {\\n    // No chains: bottom of top row circles\\n    canvasHeight = topRowY + radius;\\n  }\\n\\n  if (showDepth) {\\n    // Depth labels: radius gap below circle + up to 2 lines of text\\n    canvasHeight += radius * 3;\\n  }\\n\\n  canvasHeight += radius; // Bottom padding\\n\\n  return {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth: totalSpacing * spacing\\n  };\\n}\\n\\n// Draw a circle with centered label\\nfunction drawCircleNode(ctx, x, y, radius, label, colors, fonts) {\\n  const { fill, stroke, text } = colors;\\n  const { fontFamily } = fonts;\\n\\n  // Circle\\n  ctx.beginPath();\\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\\n  ctx.fillStyle = fill;\\n  ctx.fill();\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.stroke();\\n\\n  // Label\\n  ctx.fillStyle = text;\\n  ctx.textAlign = 'center';\\n  ctx.textBaseline = 'middle';\\n\\n  // Font size based on label length\\n  let fontSize;\\n  if (label.length \u003c= 2) {\\n    fontSize = radius * 0.9;\\n  } else if (label.length === 3) {\\n    fontSize = radius * 0.75;\\n  } else {\\n    fontSize = radius * 0.6;\\n  }\\n\\n  ctx.font = `bold ${fontSize}px ${fontFamily}`;\\n  ctx.fillText(label, x, y);\\n}\\n\\n// Draw an arrowhead at the given tip position and angle\\nfunction drawArrowhead(ctx, tipX, tipY, angle, radius) {\\n  const size = Math.max(3, radius * 0.3);\\n  ctx.save();\\n  ctx.translate(tipX, tipY);\\n  ctx.rotate(angle);\\n  ctx.beginPath();\\n  ctx.moveTo(0, 0);\\n  ctx.lineTo(-size, -size * 0.6);\\n  ctx.lineTo(-size, size * 0.6);\\n  ctx.closePath();\\n  ctx.fill();\\n  ctx.restore();\\n}\\n\\n// Draw a connection line between two nodes with optional arrowhead\\nfunction drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {\\n  const { stroke } = colors;\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.lineCap = 'round';\\n\\n  // Calculate start and end points at circle boundary\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  const dist = Math.sqrt(dx * dx + dy * dy);\\n  const angle = Math.atan2(dy, dx);\\n\\n  const startX = x1 + (dx / dist) * radius;\\n  const startY = y1 + (dy / dist) * radius;\\n  const endX = x2 - (dx / dist) * radius;\\n  const endY = y2 - (dy / dist) * radius;\\n\\n  // Draw line\\n  ctx.beginPath();\\n  ctx.moveTo(startX, startY);\\n  ctx.lineTo(endX, endY);\\n  ctx.stroke();\\n\\n  // Draw arrowhead\\n  if (showArrows) {\\n    ctx.fillStyle = stroke;\\n    drawArrowhead(ctx, endX, endY, angle, radius);\\n  }\\n}\\n\\n// Draw three vertical ellipsis dots\\nfunction drawVerticalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\n// Draw three horizontal ellipsis dots\\nfunction drawHorizontalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nfunction draw(options) {\\n  const { canvas, api, width: containerWidth, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Default props\\n  const {\\n    columns: rawColumns = [],\\n    showDepth = false,\\n    showArrows = true,\\n    minWidth = 0,\\n  } = props;\\n\\n  if (!rawColumns || rawColumns.length === 0) {\\n    canvas.width = containerWidth;\\n    canvas.height = 100;\\n    ctx.fillStyle = api.getColor('muted-foreground');\\n    ctx.font = `14px ${api.getFont('default')}`;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'middle';\\n    ctx.fillText('No columns provided', containerWidth / 2, 50);\\n    api.requestResize(100);\\n    return;\\n  }\\n\\n  // Normalize columns\\n  const columns = normalizeColumns(rawColumns);\\n\\n  // Compute layout\\n  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });\\n  const {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth\\n  } = layout;\\n\\n  canvas.width = canvasWidth;\\n  canvas.height = canvasHeight;\\n\\n  // Colors (theme-aware)\\n  const foreground = api.getColor('foreground');\\n  const cardBg = api.getColor('card');\\n  const mutedBg = api.getColor('muted');\\n  const mutedFg = api.getColor('muted-foreground');\\n  const primaryColor = api.getColor('primary');\\n\\n  const colors = {\\n    stroke: foreground,\\n    fill: cardBg,\\n    mutedFill: mutedBg,\\n    text: foreground,\\n    ellipsis: mutedFg,\\n    depth: primaryColor\\n  };\\n\\n  const fonts = {\\n    fontFamily: api.getFont('default'),\\n    monoFamily: api.getFont('mono')\\n  };\\n\\n  // Track y-positions for each column's chain\\n  const columnYPositions = columns.map(() =\u003e []);\\n\\n  // Draw horizontal chain nodes\\n  for (let i = 0; i \u003c columns.length; i++) {\\n    const col = columns[i];\\n    const x = (i + 1) * spacing;\\n    const y = topRowY;\\n\\n    if (col.label === '...') {\\n      // Draw horizontal ellipsis dots instead of a circle\\n      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);\\n    } else {\\n      // First column uses muted background\\n      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;\\n      const nodeColors = { ...colors, fill: nodeFill };\\n      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);\\n    }\\n\\n    // Draw horizontal connection to next column\\n    if (i \u003c columns.length - 1) {\\n      const nextX = (i + 2) * spacing;\\n      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);\\n    }\\n\\n    // Track positions for vertical chains\\n    columnYPositions[i].push({ x, y });\\n  }\\n\\n  // Draw vertical chains\\n  for (let colIdx = 0; colIdx \u003c columns.length; colIdx++) {\\n    const col = columns[colIdx];\\n    if (col.chain.length === 0) continue;\\n\\n    const x = (colIdx + 1) * spacing;\\n    let currentY = chainStartY;\\n\\n    for (let chainIdx = 0; chainIdx \u003c col.chain.length; chainIdx++) {\\n      const label = col.chain[chainIdx];\\n      const isEllipsis = label === '...';\\n\\n      if (isEllipsis) {\\n        // Draw vertical ellipsis dots centered where the circle would be\\n        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      } else {\\n        // Draw regular node\\n        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      }\\n    }\\n  }\\n\\n  // Draw depth labels if enabled (for all columns except start and ellipsis)\\n  if (showDepth) {\\n    const fontSize = radius * 0.7;\\n    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\\n    ctx.fillStyle = colors.depth;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'top';\\n\\n    for (let colIdx = 1; colIdx \u003c columns.length; colIdx++) {\\n      const col = columns[colIdx];\\n      if (col.label === '...') continue;\\n      const x = (colIdx + 1) * spacing;\\n      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];\\n      const depth = col.depth ?? (colIdx + col.fullChainLength);\\n      const depthY = lastPos.y + radius * 2;\\n      const word = depth === 1 ? 'move' : 'moves';\\n      const singleLine = `${depth} ${word}`;\\n\\n      // Check if single line fits within column spacing\\n      const textWidth = ctx.measureText(singleLine).width;\\n      if (textWidth \u003c spacing * 0.95) {\\n        ctx.fillText(singleLine, x, depthY);\\n      } else {\\n        ctx.fillText(String(depth), x, depthY);\\n        ctx.fillText(word, x, depthY + fontSize * 1.2);\\n      }\\n    }\\n  }\\n\\n  // Resize iframe to fit canvas\\n  api.requestResize(canvasHeight);\\n}\",\"startLine\",310,\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>