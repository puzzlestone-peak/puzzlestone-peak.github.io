<!DOCTYPE html><html lang="en" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1LM5FNK1VX"></script><meta name="color-scheme" content="dark light"/><link rel="preload" href="/assets/poppins-400-cpxAROuN.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-500-C8OXljZJ.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-600-zEkxB9Mr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-700-Qrb0O0WB.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Egg Dropping - Puzzlestone Peak</title><meta name="description" content="For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when..."/><meta property="og:title" content="Egg Dropping - Puzzlestone Peak"/><meta property="og:description" content="For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when..."/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Egg Dropping - Puzzlestone Peak"/><meta name="twitter:description" content="For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when..."/><meta name="keywords" content="optimisation, medium, logic puzzle"/><link rel="modulepreload" href="/assets/manifest-25fb394a.js"/><link rel="modulepreload" href="/assets/entry.client-BQEHofJp.js"/><link rel="modulepreload" href="/assets/index-DIth0oIc.js"/><link rel="modulepreload" href="/assets/root-BjuwspyJ.js"/><link rel="modulepreload" href="/assets/Logo-BRp-LhsU.js"/><link rel="modulepreload" href="/assets/use-dark-mode-mdHJdo6o.js"/><link rel="modulepreload" href="/assets/card-CeispfCi.js"/><link rel="modulepreload" href="/assets/NavHeightContext-BwIQMGhB.js"/><link rel="modulepreload" href="/assets/expeditionIndex-Dy75PiyG.js"/><link rel="modulepreload" href="/assets/puzzleIndex-CvT980ad.js"/><link rel="modulepreload" href="/assets/loader-circle-F5-c-Aqt.js"/><link rel="modulepreload" href="/assets/puzzle-detail-ByHrUMNS.js"/><link rel="modulepreload" href="/assets/useBack-BDsmIQAJ.js"/><link rel="modulepreload" href="/assets/ItemCardList-DC-u4o5t.js"/><link rel="modulepreload" href="/assets/ErrorBoundary-Ch767kHG.js"/><link rel="modulepreload" href="/assets/chevron-left-CY6pwb5D.js"/><script>
              (function initTheme() {
                if (localStorage.getItem('darkmode') === '1') {
                  document.documentElement.classList.add('dark');
                }
              })();
            </script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-1LM5FNK1VX');
            </script><link rel="stylesheet" href="/assets/root-DvvwlXDE.css"/><link rel="stylesheet" href="/assets/useBack-CyAuISp2.css"/></head><body><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><div class="min-h-screen bg-background"><nav class="sticky top-0 z-[1000] border-b border-border bg-card"><div class="container mx-auto px-6"><div class="flex h-16 items-center justify-between"><a class="flex items-center gap-3 text-nav-foreground no-underline" href="/" data-discover="true"><svg class="h-10 w-10 text-nav-foreground" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2211.37 2208.98" aria-label="Puzzlestone Peak Logo"><g><g><path fill="currentColor" d="M1108.28,0c649.77,5.24,1114.13,533.8,1102.89,1120-11.85,618.13-493.23,1100.61-1128,1088.81C450,2197-8.61,1690.25.12,1087.2,8.81,487.59,492.57,4.1,1108.28,0ZM121.13,1114.76c1.14,543.44,432.5,984.51,996.37,978.51,557.06-5.93,978-444.2,971.35-995.6C2082,528.37,1628.73,114,1095.67,118.84,573.44,123.64,121,538.05,121.13,1114.76Z"></path><path fill="currentColor" d="M2021.18,1304.81c-125.17-118.57-243.11-238.8-364.9-359.1-2.56,14.24,1.92,24,3.82,33.95,4.41,23.07,11.61,45.81,13.73,69.05,4,43.53,24.59,76.14,55.56,106,57.17,55,111.85,112.69,167.64,169.19,3.08,3.11,6.78,5.62,13.43,11.07l-29.92-94c24.62,13.75,40.06,32.2,57.87,47.59,20.91,18.06,40.77,37.34,61.77,55.28,8.84,7.54,10.58,14.7,7.36,25.8-20.06,69.13-47.63,135-81.34,198.6-9.36,17.65-14.91,9.53-22.48,0q-90.9-114.8-181.89-229.53-95.47-120.15-191.27-240c-1-1.26-2.64-2-7-5.25,9.72,71.9,28.35,139.3,37.91,208.53-107.81-169.7-206.63-344.59-311.28-516-9.22,3.51-3.87,12.13-10,16-12-7.35-18.72-20.06-27.45-30.66q-45.4-55.15-89.63-111.28c-9.15-11.66-14.16-9.84-23.87.14-12.63,13-13.15,24.45-6.86,40.56,17.11,43.76,35.07,87.25,48.64,132.33,1,3.28,1.72,6.64,3.84,14.9L1022.35,771.4l-2.78,2.64c13.51,22.36,26.89,44.8,40.55,67.06,24.58,40.09,49,80.27,74.21,120,6,9.48,6,15.92-1.51,24.54-28.26,32.31-55.84,65.21-83.61,97.95-15.86,18.69-15.92,18.85,1.06,35.86q114.7,114.87,229.51,229.63c2.84,2.84,5.41,6,11.73,12.92-46.79-8.28-88.16-19-132.09-25.8l298,291.64,3.93-2.17L1430.53,1306c23.59,34.58,44.25,64.91,65,95.22q123.36,180.63,251.43,357.94c1.38,1.9,2.39,4.13,4,5.79,13.32,13.77,9.47,24-4.25,35.81-47.75,41.22-98,78.83-151.9,111.65-8.1,4.94-16.34,5.41-25.27,5.45-104.54.45-203.43-26.94-300.81-61.29-107-37.74-210.39-84.76-315.67-126.92-149.26-59.78-302.65-102.49-463-118.55-55.13-5.53-110.43-4.65-165.7-3.63-9.28.18-16.45-.49-22-10-61.64-105.06-105-216.59-122.31-337.73-1.51-10.61,1.49-17.46,8.71-24.81q184.24-187.54,367.82-375.72c10-10.28,15.36-7.56,23.67,1.12,35.77,37.39,72.31,74.05,108,111.53,8.31,8.73,13.08,10.25,21.86.21Q871.5,787.48,1033.71,603.54c21-23.84,42.59-47.13,63.21-71.27,8.62-10.09,13.52-8.08,21.52,1q195.46,222.81,391.26,445.32c9.78,11.18,14.44,10.28,23.92.32,36.07-37.91,73.29-74.72,109.47-112.54,8.26-8.63,13.09-7.71,20.87.25q175.07,179.21,350.85,357.7c13.23,13.39,20.15,25.9,13.9,44.57C2025.39,1278.84,2024.3,1289.49,2021.18,1304.81ZM564.41,931.41c0,18.05-1.59,31,.28,43.31,7.16,47.25-7.05,85.12-43.68,116.5-15.75,13.5-32.89,30.56-38.74,49.32-11,35.33-14.27,73.08-20.87,110.49,8.29-1,11-6.85,14.51-11.08q84.69-101.51,174.52-198.49c8.71-9.46,11.86-16.15.08-25.48-9.14-7.24-16.56-16.62-24.93-24.86C606.56,972.43,587.42,953.86,564.41,931.41Z"></path><path fill="currentColor" d="M1258,2036.19c-156.22,31.67-307.68,13.84-456-37.14-128-44-242.37-111.53-346.16-205.19,33.78-3.18,62.72.36,91.57,3.41,177.71,18.78,340.49,86.11,502.68,155.25,63.74,27.17,127.88,53.3,193.63,75.29C1248.52,2029.42,1254.05,2029.85,1258,2036.19Z"></path><path fill="currentColor" d="M1461.61,671.32c.48-75.58,59.09-133.3,135-132.91,69.62.35,129.18,61.43,128.77,132.05-.43,74-59.91,132.06-134.66,131.48C1518.42,801.37,1461.15,743.42,1461.61,671.32Z"></path></g></g></svg><span class="text-[1.25rem] font-semibold leading-none">Puzzlestone Peak</span></a><div class="hidden items-center gap-6 md:flex"><ul class="flex items-center gap-8"><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/progress" data-discover="true">Progress</a></li></ul><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div><button class="flex h-8 w-8 cursor-pointer flex-col justify-around border-none bg-transparent p-1 text-nav-foreground md:hidden" aria-label="Toggle mobile menu" aria-expanded="false" aria-controls="mobile-menu"><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span></button></div></div></nav><div id="mobile-menu" class="fixed left-0 right-0 top-16 z-[999] border-b border-border bg-card shadow-lg transition-all duration-300 md:hidden pointer-events-none -translate-y-full opacity-0"><div class="px-6 pb-6 pt-4"><ul class="flex flex-col gap-3"><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/progress" data-discover="true">Progress</a></li></ul><div class="mt-4 flex justify-center border-t border-border pt-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div></div></div><main><div class="container mx-auto px-4 py-6 max-w-4xl"><a class="inline-flex items-center gap-1.5 text-link hover:text-link-hover hover:underline mb-6 cursor-pointer" href="/puzzles" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left size-4" aria-hidden="true"><path d="m15 18-6-6 6-6"></path></svg>Back</a><div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-4"><h1 class="text-4xl font-bold text-foreground sm:flex-1">Egg Dropping</h1><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><div class="space-y-4 border-b border-divider pb-6 mb-6"><div><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="text-sm text-muted-foreground"><span>Created: <!-- -->February 2, 2026</span></div></div><div class="markdown-content prose max-w-none space-y-4"><p>For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.</p>
<p>Near your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.</p>
<p>What is the minimum number of drops you’d ever need in the <strong>worst case</strong> to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.</p>
<details class="content-block hint-block" data-type="hint"><summary class="hint-label">Hint 1</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>Experiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.</p></div></details>
<details class="content-block hint-block" data-type="hint"><summary class="hint-label">Hint 2</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>If you only had 1 device, you cannot do better than 100 drops in the worst case. Why?</p><details class="content-block solution-block" data-type="solution"><summary class="solution-label">Solution</summary><div class="solution-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>Let’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.</p><p>This means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.</p></div></details><p>Now consider what happens when you have 2 devices.</p></div></details>
<details class="content-block hint-block" data-type="hint"><summary class="hint-label">Hint 3</summary><div class="hint-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>If your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?</p><details class="content-block solution-block" data-type="solution"><summary class="solution-label">Solution</summary><div class="solution-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>You would have to do 50 drops in the worst case scenario.</p><p><strong>Case 1</strong>: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.</p><p><strong>Case 2</strong>: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.</p></div></details></div></details>
<details class="content-block solution-block" data-type="solution"><summary class="solution-label">Solution</summary><div class="solution-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p><strong>Answer</strong>: 14 drops.</p><p>Let’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?</p><p>First, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:</p><ul>
<li>First drop: Drop from floor 3.
<ul>
<li>If it breaks, test floor 1, then 2. Worst case: 3 moves.</li>
<li>If it doesn’t break, drop from floor 6.
<ul>
<li>If it breaks, test floor 4, then 5. Worst case: 4 moves.</li>
<li>If it doesn’t break, then we know the device survives all 6 floors.</li>
</ul>
</li>
</ul>
</li>
</ul><p>This gives us a worst case of 4 moves.</p><p>Let’s come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.</p><div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,&quot;3&quot;,&quot;6&quot;]};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Simple strategy: drop from floor 3, then floor 6"></iframe></div><p>When the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we’re left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:</p><div class="dynamic-block-container overflow-x-auto"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;3&quot;,&quot;chain&quot;:[1,2]},{&quot;label&quot;:&quot;6&quot;,&quot;chain&quot;:[4,5]}],&quot;showDepth&quot;:true,&quot;minWidth&quot;:280};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;min-width:280px;height:300px" title="Strategy tree: floors 3 and 6 with fallback chains"></iframe></div><p>We can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let’s try a different strategy:</p><ul>
<li>First drop: Drop from floor 2.
<ul>
<li>If it breaks, test floor 1. Worst case: 2 moves.</li>
<li>If it doesn’t break, drop from floor 4.
<ul>
<li>If it breaks, test floor 3. Worst case: 3 moves.</li>
<li>If it doesn’t break, test floor 6.
<ul>
<li>If it breaks, test floor 5. Worst case: 4 moves</li>
<li>If it doesn’t break, then we know the device survives all 6 floors.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul><div class="dynamic-block-container overflow-x-auto"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;2&quot;,&quot;chain&quot;:[1]},{&quot;label&quot;:&quot;4&quot;,&quot;chain&quot;:[3]},{&quot;label&quot;:&quot;6&quot;,&quot;chain&quot;:[5]}],&quot;showDepth&quot;:true,&quot;minWidth&quot;:320};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;min-width:320px;height:300px" title="Strategy tree: floors 2, 4, and 6 with single fallbacks"></iframe></div><p>Hmm, we’re still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we’ve found the optimal number of drops?</p><p>No! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2) and (Start → 3 → 6 without breaking). In version 2, we have (Start → 2 → 1), (Start → 2 → 4 → 3), and (Start → 2 → 4 → 6 without breaking). If we could make these longer in order to shorten the worst-case path, we’ll find a better solution. And in fact, we can!</p><ul>
<li>First drop: Drop from floor 3.
<ul>
<li>If it breaks, test floor 1, then 2. Worst case: 3 moves.</li>
<li>If it doesn’t break, drop from floor 5.
<ul>
<li>If it breaks, test floor 4. Worst case: 3 moves.</li>
<li>If it doesn’t break, test floor 6. Worst case: 3 moves.</li>
</ul>
</li>
</ul>
</li>
</ul><div class="dynamic-block-container flex justify-center"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;3&quot;,&quot;chain&quot;:[1,2]},{&quot;label&quot;:&quot;5&quot;,&quot;chain&quot;:[4]},&quot;6&quot;],&quot;showDepth&quot;:true};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;height:300px" title="Optimal strategy tree for 6 floors"></iframe></div><p>No matter which path we take, we’ll always end up with 3 moves in the worst case.</p><p>With this visualisation in mind, let’s explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:</p><div class="dynamic-block-container overflow-x-auto"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;50&quot;,&quot;chain&quot;:[1,2,&quot;...&quot;,&quot;...&quot;,&quot;...&quot;,&quot;...&quot;,49]},{&quot;label&quot;:&quot;75&quot;,&quot;chain&quot;:[51,52,&quot;...&quot;,74]},{&quot;label&quot;:&quot;100&quot;,&quot;chain&quot;:[76,77,&quot;...&quot;,98,99]}],&quot;showDepth&quot;:true,&quot;minWidth&quot;:320};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;min-width:320px;height:300px" title="Strategy tree: binary split from floor 50"></iframe></div><p>Oof, that’s rough. It seems like we’re not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.</p><p>How about steps of 10? This time, we’ll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:</p><div class="dynamic-block-container overflow-x-auto"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;10&quot;,&quot;chain&quot;:{&quot;from&quot;:1,&quot;to&quot;:9}},{&quot;label&quot;:&quot;20&quot;,&quot;chain&quot;:{&quot;from&quot;:11,&quot;to&quot;:19}},{&quot;label&quot;:&quot;30&quot;,&quot;chain&quot;:{&quot;from&quot;:21,&quot;to&quot;:29}},&quot;...&quot;,{&quot;label&quot;:&quot;80&quot;,&quot;chain&quot;:{&quot;from&quot;:71,&quot;to&quot;:79},&quot;depth&quot;:17},{&quot;label&quot;:&quot;90&quot;,&quot;chain&quot;:{&quot;from&quot;:81,&quot;to&quot;:89},&quot;depth&quot;:18},{&quot;label&quot;:&quot;100&quot;,&quot;chain&quot;:{&quot;from&quot;:91,&quot;to&quot;:99},&quot;depth&quot;:19}],&quot;showDepth&quot;:true,&quot;minWidth&quot;:800};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;min-width:800px;height:300px" title="Strategy tree: steps of 10"></iframe></div><p>In the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let’s lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>14</mn><mo>+</mo><mn>13</mn><mo>=</mo><mn>27</mn></mrow><annotation>14 + 13 = 27</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">14</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">13</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">27</span></span></span></span>. Then the following drop should be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>27</mn><mo>+</mo><mn>12</mn><mo>=</mo><mn>39</mn></mrow><annotation>27 + 12 = 39</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">27</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">39</span></span></span></span>. Continuing this way, we get a chart of:</p><div class="dynamic-block-container overflow-x-auto"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;14&quot;,&quot;chain&quot;:{&quot;from&quot;:1,&quot;to&quot;:13}},{&quot;label&quot;:&quot;27&quot;,&quot;chain&quot;:{&quot;from&quot;:15,&quot;to&quot;:26}},{&quot;label&quot;:&quot;39&quot;,&quot;chain&quot;:{&quot;from&quot;:28,&quot;to&quot;:38}},{&quot;label&quot;:&quot;50&quot;,&quot;chain&quot;:{&quot;from&quot;:40,&quot;to&quot;:49}},{&quot;label&quot;:&quot;60&quot;,&quot;chain&quot;:{&quot;from&quot;:51,&quot;to&quot;:59}},{&quot;label&quot;:&quot;69&quot;,&quot;chain&quot;:{&quot;from&quot;:61,&quot;to&quot;:68}},{&quot;label&quot;:&quot;77&quot;,&quot;chain&quot;:{&quot;from&quot;:70,&quot;to&quot;:76}},{&quot;label&quot;:&quot;84&quot;,&quot;chain&quot;:{&quot;from&quot;:78,&quot;to&quot;:83}},{&quot;label&quot;:&quot;90&quot;,&quot;chain&quot;:{&quot;from&quot;:85,&quot;to&quot;:89}},{&quot;label&quot;:&quot;95&quot;,&quot;chain&quot;:{&quot;from&quot;:91,&quot;to&quot;:94}},{&quot;label&quot;:&quot;99&quot;,&quot;chain&quot;:{&quot;from&quot;:96,&quot;to&quot;:98}},&quot;100&quot;],&quot;showDepth&quot;:true,&quot;minWidth&quot;:1100};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;min-width:1100px;height:300px" title="Optimal strategy tree for 100 floors"></iframe></div><p>In the worst case scenario, we have 14 moves, and we can’t do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.</p><div class="dynamic-block-container overflow-x-auto"><iframe class="border-0 block" sandbox="allow-scripts" srcDoc="&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;; style-src &#x27;unsafe-inline&#x27;; img-src data:;&quot;&gt;
  &lt;style&gt;
    /* Prevent scrollbars in iframe while allowing content to expand */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #root {
      /* flex: 1; */
      /* min-height: 0; */
    }

    /* Theme CSS variables (light/dark mode) */
    /* Theme overrides and customizations */

:root {
  --width-container: 1000px;
}

/* Text selection styling (applied to both main app and iframes) */
::selection {
  background-color: var(--color-selection);
  color: var(--color-selection-foreground);
}


:root {
  --radius: 0.5rem;

  /* Navy */
  --color-navy-50: oklch(0.97 0.015 220);
  --color-navy-100: oklch(0.94 0.020 220);
  --color-navy-200: oklch(0.88 0.030 220);
  --color-navy-300: oklch(0.80 0.045 220);
  --color-navy-400: oklch(0.68 0.060 220);
  --color-navy-500: oklch(0.55 0.075 220);
  --color-navy-600: oklch(0.45 0.080 220);
  --color-navy-700: oklch(0.35 0.075 220);
  --color-navy-800: oklch(0.27 0.065 220);
  --color-navy-900: oklch(0.20 0.050 220);
  --color-navy-950: oklch(0.15 0.040 220);

  /* Frost */
  --color-frost-50: oklch(0.98 0.010 250);
  --color-frost-100: oklch(0.95 0.015 250);
  --color-frost-200: oklch(0.90 0.025 250);
  --color-frost-300: oklch(0.83 0.035 250);
  --color-frost-400: oklch(0.74 0.045 250);
  --color-frost-500: oklch(0.65 0.055 250);
  --color-frost-600: oklch(0.55 0.060 250);
  --color-frost-700: oklch(0.45 0.055 250);
  --color-frost-800: oklch(0.35 0.045 250);
  --color-frost-900: oklch(0.27 0.035 250);
  --color-frost-950: oklch(0.20 0.025 250);

  /* Lagoon */
  --color-lagoon-50: oklch(0.97 0.015 185);
  --color-lagoon-100: oklch(0.94 0.025 185);
  --color-lagoon-200: oklch(0.88 0.040 185);
  --color-lagoon-300: oklch(0.80 0.055 185);
  --color-lagoon-400: oklch(0.70 0.070 185);
  --color-lagoon-500: oklch(0.60 0.080 185);
  --color-lagoon-600: oklch(0.50 0.085 185);
  --color-lagoon-700: oklch(0.40 0.080 185);
  --color-lagoon-800: oklch(0.32 0.070 185);
  --color-lagoon-900: oklch(0.25 0.055 185);
  --color-lagoon-950: oklch(0.18 0.040 185);

  /* Evergreen */
  --color-evergreen-50: oklch(0.97 0.020 155);
  --color-evergreen-100: oklch(0.93 0.035 155);
  --color-evergreen-200: oklch(0.87 0.055 155);
  --color-evergreen-300: oklch(0.79 0.070 155);
  --color-evergreen-400: oklch(0.69 0.085 155);
  --color-evergreen-500: oklch(0.59 0.095 155);
  --color-evergreen-600: oklch(0.49 0.100 155);
  --color-evergreen-700: oklch(0.41 0.095 155);
  --color-evergreen-800: oklch(0.33 0.080 155);
  --color-evergreen-900: oklch(0.27 0.065 155);
  --color-evergreen-950: oklch(0.21 0.050 155);

  /* Sand */
  --color-sand-50: oklch(0.98 0.012 95);
  --color-sand-100: oklch(0.95 0.020 95);
  --color-sand-200: oklch(0.90 0.035 95);
  --color-sand-300: oklch(0.84 0.050 95);
  --color-sand-400: oklch(0.76 0.065 95);
  --color-sand-500: oklch(0.68 0.080 95);
  --color-sand-600: oklch(0.60 0.090 95);
  --color-sand-700: oklch(0.50 0.085 95);
  --color-sand-800: oklch(0.40 0.070 95);
  --color-sand-900: oklch(0.32 0.055 95);
  --color-sand-950: oklch(0.26 0.040 95);

  /* Error */
  --color-error-50: oklch(0.97 0.020 25);
  --color-error-100: oklch(0.94 0.035 25);
  --color-error-200: oklch(0.88 0.055 25);
  --color-error-300: oklch(0.80 0.075 25);
  --color-error-400: oklch(0.70 0.095 25);
  --color-error-500: oklch(0.60 0.110 25);
  --color-error-600: oklch(0.50 0.115 25);
  --color-error-700: oklch(0.42 0.110 25);
  --color-error-800: oklch(0.34 0.095 25);
  --color-error-900: oklch(0.28 0.075 25);
  --color-error-950: oklch(0.22 0.055 25);

  /* Warning */
  --color-warning-50: oklch(0.97 0.020 75);
  --color-warning-100: oklch(0.94 0.035 75);
  --color-warning-200: oklch(0.89 0.060 75);
  --color-warning-300: oklch(0.82 0.085 75);
  --color-warning-400: oklch(0.73 0.105 75);
  --color-warning-500: oklch(0.65 0.120 75);
  --color-warning-600: oklch(0.56 0.125 75);
  --color-warning-700: oklch(0.47 0.115 75);
  --color-warning-800: oklch(0.38 0.095 75);
  --color-warning-900: oklch(0.30 0.070 75);
  --color-warning-950: oklch(0.24 0.050 75);

  /* Success */
  --color-success-50: oklch(0.97 0.020 165);
  --color-success-100: oklch(0.93 0.035 165);
  --color-success-200: oklch(0.87 0.055 165);
  --color-success-300: oklch(0.79 0.075 165);
  --color-success-400: oklch(0.69 0.095 165);
  --color-success-500: oklch(0.59 0.110 165);
  --color-success-600: oklch(0.49 0.115 165);
  --color-success-700: oklch(0.41 0.105 165);
  --color-success-800: oklch(0.33 0.090 165);
  --color-success-900: oklch(0.27 0.070 165);
  --color-success-950: oklch(0.21 0.050 165);

  /* ======================================================
     Tailwind-like Colour Palette
     Inspired by standard Tailwind CSS v4 colours for
     diagrams and illustrations. For website UI, use the
     mountain theme palette above or semantic colours
     instead.
     ====================================================== */

  /* Red */
  --color-red-50: oklch(0.971 0.008 17.38);
  --color-red-100: oklch(0.936 0.019 17.717);
  --color-red-200: oklch(0.885 0.037 18.334);
  --color-red-300: oklch(0.808 0.068 19.571);
  --color-red-400: oklch(0.704 0.115 22.216);
  --color-red-500: oklch(0.637 0.142 25.331);
  --color-red-600: oklch(0.577 0.147 27.325);
  --color-red-700: oklch(0.505 0.128 27.518);
  --color-red-800: oklch(0.444 0.106 26.899);
  --color-red-900: oklch(0.396 0.085 25.723);
  --color-red-950: oklch(0.258 0.055 26.042);
  --color-red: var(--color-red-400);

  /* Orange */
  --color-orange-50: oklch(0.980 0.010 73.684);
  --color-orange-100: oklch(0.954 0.023 75.164);
  --color-orange-200: oklch(0.901 0.046 70.697);
  --color-orange-300: oklch(0.837 0.077 66.29);
  --color-orange-400: oklch(0.750 0.110 55.934);
  --color-orange-500: oklch(0.705 0.128 47.604);
  --color-orange-600: oklch(0.646 0.133 41.116);
  --color-orange-700: oklch(0.553 0.117 38.402);
  --color-orange-800: oklch(0.470 0.094 37.304);
  --color-orange-900: oklch(0.408 0.074 38.172);
  --color-orange-950: oklch(0.266 0.047 36.259);
  --color-orange: var(--color-orange-400);

  /* Amber */
  --color-amber-50: oklch(0.987 0.013 95.277);
  --color-amber-100: oklch(0.962 0.035 95.617);
  --color-amber-200: oklch(0.924 0.072 95.746);
  --color-amber-300: oklch(0.879 0.101 91.605);
  --color-amber-400: oklch(0.828 0.113 84.429);
  --color-amber-500: oklch(0.769 0.113 70.08);
  --color-amber-600: oklch(0.666 0.107 58.318);
  --color-amber-700: oklch(0.555 0.098 48.998);
  --color-amber-800: oklch(0.473 0.082 46.201);
  --color-amber-900: oklch(0.414 0.067 45.904);
  --color-amber-950: oklch(0.279 0.046 45.635);
  --color-amber: var(--color-amber-400);

  /* Yellow */
  --color-yellow-50: oklch(0.987 0.016 102.212);
  --color-yellow-100: oklch(0.973 0.043 103.193);
  --color-yellow-200: oklch(0.945 0.077 101.54);
  --color-yellow-300: oklch(0.905 0.109 98.111);
  --color-yellow-400: oklch(0.852 0.119 91.936);
  --color-yellow-500: oklch(0.795 0.110 86.047);
  --color-yellow-600: oklch(0.681 0.097 75.834);
  --color-yellow-700: oklch(0.554 0.081 66.442);
  --color-yellow-800: oklch(0.476 0.068 61.907);
  --color-yellow-900: oklch(0.421 0.057 57.708);
  --color-yellow-950: oklch(0.286 0.040 53.813);
  --color-yellow: var(--color-yellow-400);

  /* Lime */
  --color-lime-50: oklch(0.986 0.019 120.757);
  --color-lime-100: oklch(0.967 0.040 122.328);
  --color-lime-200: oklch(0.938 0.076 124.321);
  --color-lime-300: oklch(0.897 0.118 126.665);
  --color-lime-400: oklch(0.841 0.143 128.85);
  --color-lime-500: oklch(0.768 0.140 130.85);
  --color-lime-600: oklch(0.648 0.120 131.684);
  --color-lime-700: oklch(0.532 0.094 131.589);
  --color-lime-800: oklch(0.453 0.074 130.933);
  --color-lime-900: oklch(0.405 0.061 131.063);
  --color-lime-950: oklch(0.274 0.043 132.109);
  --color-lime: var(--color-lime-400);

  /* Green */
  --color-green-50: oklch(0.982 0.011 155.826);
  --color-green-100: oklch(0.962 0.026 156.743);
  --color-green-200: oklch(0.925 0.050 155.995);
  --color-green-300: oklch(0.871 0.090 154.449);
  --color-green-400: oklch(0.792 0.125 151.711);
  --color-green-500: oklch(0.723 0.131 149.579);
  --color-green-600: oklch(0.627 0.116 149.214);
  --color-green-700: oklch(0.527 0.092 150.069);
  --color-green-800: oklch(0.448 0.071 151.328);
  --color-green-900: oklch(0.393 0.057 152.535);
  --color-green-950: oklch(0.266 0.039 152.934);
  --color-green: var(--color-green-400);

  /* Emerald */
  --color-emerald-50: oklch(0.979 0.013 166.113);
  --color-emerald-100: oklch(0.950 0.031 163.051);
  --color-emerald-200: oklch(0.905 0.056 164.15);
  --color-emerald-300: oklch(0.845 0.086 164.978);
  --color-emerald-400: oklch(0.765 0.106 163.223);
  --color-emerald-500: oklch(0.696 0.102 162.48);
  --color-emerald-600: oklch(0.596 0.087 163.225);
  --color-emerald-700: oklch(0.508 0.071 165.612);
  --color-emerald-800: oklch(0.432 0.057 166.913);
  --color-emerald-900: oklch(0.378 0.046 168.94);
  --color-emerald-950: oklch(0.262 0.031 172.552);
  --color-emerald: var(--color-emerald-400);

  /* Teal */
  --color-teal-50: oklch(0.984 0.008 180.72);
  --color-teal-100: oklch(0.953 0.031 180.801);
  --color-teal-200: oklch(0.910 0.058 180.426);
  --color-teal-300: oklch(0.855 0.083 181.071);
  --color-teal-400: oklch(0.777 0.091 181.912);
  --color-teal-500: oklch(0.704 0.084 182.503);
  --color-teal-600: oklch(0.600 0.071 184.704);
  --color-teal-700: oklch(0.511 0.058 186.391);
  --color-teal-800: oklch(0.437 0.047 188.216);
  --color-teal-900: oklch(0.386 0.038 188.416);
  --color-teal-950: oklch(0.277 0.028 192.524);
  --color-teal: var(--color-teal-400);

  /* Cyan */
  --color-cyan-50: oklch(0.984 0.011 200.873);
  --color-cyan-100: oklch(0.956 0.027 203.388);
  --color-cyan-200: oklch(0.917 0.048 205.041);
  --color-cyan-300: oklch(0.865 0.076 207.078);
  --color-cyan-400: oklch(0.789 0.092 211.53);
  --color-cyan-500: oklch(0.715 0.086 215.221);
  --color-cyan-600: oklch(0.609 0.076 221.723);
  --color-cyan-700: oklch(0.520 0.063 223.128);
  --color-cyan-800: oklch(0.450 0.051 224.283);
  --color-cyan-900: oklch(0.398 0.042 227.392);
  --color-cyan-950: oklch(0.302 0.034 229.695);
  --color-cyan: var(--color-cyan-400);

  /* Sky */
  --color-sky-50: oklch(0.977 0.008 236.62);
  --color-sky-100: oklch(0.951 0.016 236.824);
  --color-sky-200: oklch(0.901 0.035 230.902);
  --color-sky-300: oklch(0.828 0.067 230.318);
  --color-sky-400: oklch(0.746 0.096 232.661);
  --color-sky-500: oklch(0.685 0.101 237.323);
  --color-sky-600: oklch(0.588 0.095 241.966);
  --color-sky-700: oklch(0.500 0.080 242.749);
  --color-sky-800: oklch(0.443 0.066 240.79);
  --color-sky-900: oklch(0.391 0.054 240.876);
  --color-sky-950: oklch(0.293 0.040 243.157);
  --color-sky: var(--color-sky-400);

  /* Blue */
  --color-blue-50: oklch(0.970 0.008 254.604);
  --color-blue-100: oklch(0.932 0.019 255.585);
  --color-blue-200: oklch(0.882 0.035 254.128);
  --color-blue-300: oklch(0.809 0.063 251.813);
  --color-blue-400: oklch(0.707 0.099 254.624);
  --color-blue-500: oklch(0.623 0.128 259.815);
  --color-blue-600: oklch(0.546 0.147 262.881);
  --color-blue-700: oklch(0.488 0.146 264.376);
  --color-blue-800: oklch(0.424 0.119 265.638);
  --color-blue-900: oklch(0.379 0.088 265.522);
  --color-blue-950: oklch(0.282 0.055 267.935);
  --color-blue: var(--color-blue-400);

  /* Indigo */
  --color-indigo-50: oklch(0.962 0.011 272.314);
  --color-indigo-100: oklch(0.930 0.020 272.788);
  --color-indigo-200: oklch(0.870 0.039 274.039);
  --color-indigo-300: oklch(0.785 0.069 274.713);
  --color-indigo-400: oklch(0.673 0.109 276.935);
  --color-indigo-500: oklch(0.585 0.140 277.117);
  --color-indigo-600: oklch(0.511 0.157 276.966);
  --color-indigo-700: oklch(0.457 0.144 277.023);
  --color-indigo-800: oklch(0.398 0.117 277.366);
  --color-indigo-900: oklch(0.359 0.086 278.697);
  --color-indigo-950: oklch(0.257 0.054 281.288);
  --color-indigo: var(--color-indigo-400);

  /* Violet */
  --color-violet-50: oklch(0.969 0.010 293.756);
  --color-violet-100: oklch(0.943 0.017 294.588);
  --color-violet-200: oklch(0.894 0.034 293.283);
  --color-violet-300: oklch(0.811 0.067 293.571);
  --color-violet-400: oklch(0.702 0.110 293.541);
  --color-violet-500: oklch(0.606 0.150 292.717);
  --color-violet-600: oklch(0.541 0.169 293.009);
  --color-violet-700: oklch(0.491 0.162 292.581);
  --color-violet-800: oklch(0.432 0.139 292.759);
  --color-violet-900: oklch(0.380 0.113 293.745);
  --color-violet-950: oklch(0.283 0.085 291.089);
  --color-violet: var(--color-violet-400);

  /* Purple */
  --color-purple-50: oklch(0.977 0.008 308.299);
  --color-purple-100: oklch(0.946 0.020 307.174);
  --color-purple-200: oklch(0.902 0.038 306.703);
  --color-purple-300: oklch(0.827 0.071 306.383);
  --color-purple-400: oklch(0.714 0.122 305.504);
  --color-purple-500: oklch(0.627 0.159 303.9);
  --color-purple-600: oklch(0.558 0.173 302.321);
  --color-purple-700: oklch(0.496 0.159 301.924);
  --color-purple-800: oklch(0.438 0.131 303.724);
  --color-purple-900: oklch(0.381 0.106 304.987);
  --color-purple-950: oklch(0.291 0.089 302.717);
  --color-purple: var(--color-purple-400);

  /* Fuchsia */
  --color-fuchsia-50: oklch(0.977 0.010 320.058);
  --color-fuchsia-100: oklch(0.952 0.022 318.852);
  --color-fuchsia-200: oklch(0.903 0.046 319.62);
  --color-fuchsia-300: oklch(0.833 0.087 321.434);
  --color-fuchsia-400: oklch(0.740 0.143 322.16);
  --color-fuchsia-500: oklch(0.667 0.177 322.15);
  --color-fuchsia-600: oklch(0.591 0.176 322.896);
  --color-fuchsia-700: oklch(0.518 0.152 323.949);
  --color-fuchsia-800: oklch(0.452 0.127 324.591);
  --color-fuchsia-900: oklch(0.401 0.102 325.612);
  --color-fuchsia-950: oklch(0.293 0.082 325.661);
  --color-fuchsia: var(--color-fuchsia-400);

  /* Pink */
  --color-pink-50: oklch(0.971 0.008 343.198);
  --color-pink-100: oklch(0.948 0.017 342.258);
  --color-pink-200: oklch(0.899 0.037 343.231);
  --color-pink-300: oklch(0.823 0.072 346.018);
  --color-pink-400: oklch(0.718 0.121 349.761);
  --color-pink-500: oklch(0.656 0.145 354.308);
  --color-pink-600: oklch(0.592 0.149 0.584);
  --color-pink-700: oklch(0.525 0.134 3.958);
  --color-pink-800: oklch(0.459 0.112 3.815);
  --color-pink-900: oklch(0.408 0.092 2.432);
  --color-pink-950: oklch(0.284 0.065 3.907);
  --color-pink: var(--color-pink-400);

  /* Rose */
  --color-rose-50: oklch(0.969 0.009 12.422);
  --color-rose-100: oklch(0.941 0.018 12.58);
  --color-rose-200: oklch(0.892 0.035 10.001);
  --color-rose-300: oklch(0.810 0.070 11.638);
  --color-rose-400: oklch(0.712 0.116 13.428);
  --color-rose-500: oklch(0.645 0.148 16.439);
  --color-rose-600: oklch(0.586 0.152 17.585);
  --color-rose-700: oklch(0.514 0.133 16.935);
  --color-rose-800: oklch(0.455 0.113 13.697);
  --color-rose-900: oklch(0.410 0.095 10.272);
  --color-rose-950: oklch(0.271 0.063 12.094);
  --color-rose: var(--color-rose-400);

  /* Slate */
  --color-slate-50: oklch(0.984 0.002 247.858);
  --color-slate-100: oklch(0.968 0.004 247.896);
  --color-slate-200: oklch(0.929 0.008 255.508);
  --color-slate-300: oklch(0.869 0.013 252.894);
  --color-slate-400: oklch(0.704 0.024 256.788);
  --color-slate-500: oklch(0.554 0.028 257.417);
  --color-slate-600: oklch(0.446 0.026 257.281);
  --color-slate-700: oklch(0.372 0.026 257.287);
  --color-slate-800: oklch(0.279 0.025 260.031);
  --color-slate-900: oklch(0.208 0.025 265.755);
  --color-slate-950: oklch(0.129 0.025 264.695);
  --color-slate: var(--color-slate-400);

  /* Gray */
  --color-gray-50: oklch(0.985 0.001 247.839);
  --color-gray-100: oklch(0.967 0.002 264.542);
  --color-gray-200: oklch(0.928 0.004 264.531);
  --color-gray-300: oklch(0.872 0.006 258.338);
  --color-gray-400: oklch(0.707 0.013 261.325);
  --color-gray-500: oklch(0.551 0.016 264.364);
  --color-gray-600: oklch(0.446 0.018 256.802);
  --color-gray-700: oklch(0.373 0.020 259.733);
  --color-gray-800: oklch(0.278 0.020 256.848);
  --color-gray-900: oklch(0.210 0.020 264.665);
  --color-gray-950: oklch(0.130 0.017 261.692);
  --color-gray: var(--color-gray-400);

  /* Zinc */
  --color-zinc-50: oklch(0.985 0 0);
  --color-zinc-100: oklch(0.967 0.001 286.375);
  --color-zinc-200: oklch(0.920 0.002 286.32);
  --color-zinc-300: oklch(0.871 0.004 286.286);
  --color-zinc-400: oklch(0.705 0.009 286.067);
  --color-zinc-500: oklch(0.552 0.010 285.938);
  --color-zinc-600: oklch(0.442 0.010 285.786);
  --color-zinc-700: oklch(0.370 0.008 285.805);
  --color-zinc-800: oklch(0.274 0.004 286.033);
  --color-zinc-900: oklch(0.210 0.004 285.885);
  --color-zinc-950: oklch(0.141 0.003 285.823);
  --color-zinc: var(--color-zinc-400);

  /* Neutral */
  --color-neutral-50: oklch(0.985 0 0);
  --color-neutral-100: oklch(0.970 0 0);
  --color-neutral-200: oklch(0.922 0 0);
  --color-neutral-300: oklch(0.870 0 0);
  --color-neutral-400: oklch(0.708 0 0);
  --color-neutral-500: oklch(0.556 0 0);
  --color-neutral-600: oklch(0.439 0 0);
  --color-neutral-700: oklch(0.371 0 0);
  --color-neutral-800: oklch(0.269 0 0);
  --color-neutral-900: oklch(0.205 0 0);
  --color-neutral-950: oklch(0.145 0 0);
  --color-neutral: var(--color-neutral-400);

  /* Stone */
  --color-stone-50: oklch(0.985 0.001 106.423);
  --color-stone-100: oklch(0.970 0.001 106.424);
  --color-stone-200: oklch(0.923 0.002 48.717);
  --color-stone-300: oklch(0.869 0.003 56.366);
  --color-stone-400: oklch(0.709 0.006 56.259);
  --color-stone-500: oklch(0.553 0.008 58.071);
  --color-stone-600: oklch(0.444 0.007 73.639);
  --color-stone-700: oklch(0.374 0.006 67.558);
  --color-stone-800: oklch(0.268 0.004 34.298);
  --color-stone-900: oklch(0.216 0.004 56.043);
  --color-stone-950: oklch(0.147 0.002 49.25);
  --color-stone: var(--color-stone-400);

  /* Pure white */
  --color-white: oklch(1 0 0);
}

/* Semantic UI Theme Variables */

:root {
  /* Base colors */
  --color-background: var(--color-frost-50);
  --color-foreground: var(--color-navy-950);

  /* Card */
  --color-card: var(--color-white);
  --color-card-foreground: var(--color-navy-950);

  /* Popover */
  --color-popover: var(--color-white);
  --color-popover-foreground: var(--color-navy-950);

  /* Primary */
  --color-primary: var(--color-navy-600);
  --color-primary-foreground: var(--color-white);

  /* Secondary */
  --color-secondary: var(--color-evergreen-600);
  --color-secondary-foreground: var(--color-white);

  /* Muted */
  --color-muted: var(--color-frost-100);
  --color-muted-foreground: var(--color-navy-600);

  /* Accent */
  --color-accent: var(--color-sand-600);
  --color-accent-foreground: var(--color-white);

  /* Destructive */
  --color-destructive: var(--color-error-600);
  --color-destructive-foreground: var(--color-white);

  /* Success */
  --color-success: var(--color-success-600);
  --color-success-foreground: var(--color-white);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-500);
  --color-completed-foreground: var(--color-white);

  /* Warning */
  --color-warning: var(--color-warning-600);
  --color-warning-foreground: var(--color-white);

  /* Info */
  --color-info: var(--color-navy-500);
  --color-info-foreground: var(--color-white);

  /* Border */
  --color-border: var(--color-frost-600);
  --color-input: var(--color-frost-300);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-frost-200);
  --color-surface: var(--color-white);
  --color-text-secondary: var(--color-frost-600);
  --color-text-emphasis: var(--color-navy-600);
  --color-link: var(--color-navy-600);
  --color-link-hover: var(--color-navy-700);

  /* Select component */
  --color-select-hover: var(--color-navy-50);
  --color-select-hover-foreground: var(--color-navy-950);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-600);
  --color-checkbox-checked-foreground: var(--color-white);

  /* Navigation */
  --color-nav-foreground: var(--color-navy-600);

  /* Text selection */
  --color-selection: var(--color-navy-200);
  --color-selection-foreground: var(--color-navy-900);

  /* Difficulty levels (puzzles) */
  --color-difficulty-easy: var(--color-success-100);
  --color-difficulty-easy-foreground: var(--color-success-800);
  --color-difficulty-medium: var(--color-navy-100);
  --color-difficulty-medium-foreground: var(--color-navy-800);
  --color-difficulty-hard: var(--color-warning-100);
  --color-difficulty-hard-foreground: var(--color-warning-800);
  --color-difficulty-expert: var(--color-error-100);
  --color-difficulty-expert-foreground: var(--color-error-800);
  --color-difficulty-open: var(--color-frost-200);
  --color-difficulty-open-foreground: var(--color-frost-900);

  /* Gradients */
  --gradient-recommendation-start: var(--color-evergreen-500);
  --gradient-recommendation-end: var(--color-navy-500);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


.dark {
  /* Base colors */
  --color-background: oklch(0.10 0.035 220); /* darker than navy-950, almost pure black */
  --color-foreground: var(--color-frost-200);

  /* Card */
  --color-card: var(--color-navy-900);
  --color-card-foreground: var(--color-frost-200);

  /* Popover */
  --color-popover: var(--color-navy-900);
  --color-popover-foreground: var(--color-frost-200);

  /* Primary */
  --color-primary: var(--color-navy-400);
  --color-primary-foreground: var(--color-navy-950);

  /* Secondary */
  --color-secondary: var(--color-evergreen-400);
  --color-secondary-foreground: var(--color-navy-950);

  /* Muted */
  --color-muted: var(--color-navy-800);
  --color-muted-foreground: var(--color-frost-400);

  /* Accent */
  --color-accent: var(--color-sand-400);
  --color-accent-foreground: var(--color-navy-950);

  /* Destructive */
  --color-destructive: var(--color-error-400);
  --color-destructive-foreground: var(--color-navy-950);

  /* Success */
  --color-success: var(--color-success-400);
  --color-success-foreground: var(--color-navy-950);

  /* Completed (for puzzle/expedition completion badges) */
  --color-completed: var(--color-evergreen-300);
  --color-completed-foreground: var(--color-navy-950);

  /* Warning */
  --color-warning: var(--color-warning-400);
  --color-warning-foreground: var(--color-navy-950);

  /* Info */
  --color-info: var(--color-navy-300);
  --color-info-foreground: var(--color-navy-950);

  /* Border */
  --color-border: var(--color-navy-700);
  --color-input: var(--color-navy-600);
  --color-ring: var(--color-navy-400);

  /* Additional semantic colors for UI elements */
  --color-divider: var(--color-navy-700);
  --color-surface: var(--color-navy-900);
  --color-text-secondary: var(--color-frost-400);
  --color-text-emphasis: var(--color-frost-50);
  --color-link: var(--color-navy-400);
  --color-link-hover: var(--color-navy-300);

  /* Select component */
  --color-select-hover: var(--color-navy-800);
  --color-select-hover-foreground: var(--color-frost-200);

  /* Checkbox */
  --color-checkbox-checked: var(--color-navy-400);
  --color-checkbox-checked-foreground: var(--color-navy-950);

  /* Navigation */
  --color-nav-foreground: var(--color-frost-200);

  /* Text selection */
  --color-selection: var(--color-navy-700);
  --color-selection-foreground: var(--color-navy-100);

  /* Difficulty levels (puzzles) - dark mode */
  --color-difficulty-easy: var(--color-success-900);
  --color-difficulty-easy-foreground: var(--color-success-200);
  --color-difficulty-medium: var(--color-navy-900);
  --color-difficulty-medium-foreground: var(--color-navy-200);
  --color-difficulty-hard: var(--color-warning-900);
  --color-difficulty-hard-foreground: var(--color-warning-200);
  --color-difficulty-expert: var(--color-error-900);
  --color-difficulty-expert-foreground: var(--color-error-200);
  --color-difficulty-open: var(--color-frost-700);
  --color-difficulty-open-foreground: var(--color-frost-200);

  /* Gradients - dark mode */
  --gradient-recommendation-start: var(--color-evergreen-600);
  --gradient-recommendation-end: var(--color-navy-600);
  --gradient-progress-start: var(--color-lagoon-600);
  --gradient-progress-end: var(--color-lagoon-500);
}


    /* Base Reset */
*, ::before, ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: var(--color-border);
}

html {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  tab-size: 4;
  font-family: &#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif;
  font-feature-settings: normal;
  font-variation-settings: normal;
}

body {
  margin: 0;
  line-height: inherit;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

/* Reset margins on common elements */
h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, hr {
  margin: 0;
}

/* Reset list styles */
ul, ol {
  padding: 0;
  list-style: none;
}

/* Reset buttons and inputs */
button, input, optgroup, select, textarea {
  font-family: inherit;
  font-feature-settings: inherit;
  font-variation-settings: inherit;
  font-size: 100%;
  font-weight: inherit;
  line-height: inherit;
  letter-spacing: inherit;
  color: inherit;
  margin: 0;
  padding: 0;
}

button, select {
  text-transform: none;
}

button, input:where([type=&#x27;button&#x27;]), input:where([type=&#x27;reset&#x27;]), input:where([type=&#x27;submit&#x27;]) {
  -webkit-appearance: button;
  background-color: transparent;
  background-image: none;
  cursor: pointer;
}

button:disabled, input:disabled {
  cursor: default;
}

/* Reset form elements */
input::placeholder, textarea::placeholder {
  opacity: 1;
  color: var(--color-muted-foreground);
}

/* Reset tables */
table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse;
}

/* Link styles */
a {
  color: var(--color-link);
  text-decoration: none;
}

a:hover {
  color: var(--color-link-hover);
  text-decoration: underline;
}

/* Reset headings */
h1, h2, h3, h4, h5, h6 {
  font-size: inherit;
  font-weight: inherit;
}

/* Reset images and media */
img, svg, video, canvas, audio, iframe, embed, object {
  display: block;
  vertical-align: middle;
}

img, video {
  max-width: 100%;
  height: auto;
}

/* Sandbox-specific UI styles */
.sandbox-select:invalid {
  color: var(--color-muted-foreground) !important;
}

.sandbox-select option {
  background-color: var(--color-popover) !important;
  color: var(--color-popover-foreground) !important;
  padding: 0.375rem 0.5rem !important;
}

.sandbox-select option:disabled {
  color: var(--color-muted-foreground) !important;
  background-color: var(--color-popover) !important;
}

.sandbox-select option:checked {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

.sandbox-select option:hover,
.sandbox-select option:focus,
.sandbox-select option:active {
  background-color: var(--color-select-hover) !important;
  color: var(--color-select-hover-foreground) !important;
}

/* Peer helper class for Radix UI components */
.peer { }
    
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

  &lt;!-- Runtime and globals script --&gt;
  &lt;script&gt;
    // Component props (available globally)
    window.__COMPONENT_PROPS__ = {&quot;columns&quot;:[&quot;S&quot;,{&quot;label&quot;:&quot;14&quot;,&quot;chain&quot;:{&quot;from&quot;:1,&quot;to&quot;:13}},{&quot;label&quot;:&quot;27&quot;,&quot;chain&quot;:{&quot;from&quot;:15,&quot;to&quot;:26}},{&quot;label&quot;:&quot;39&quot;,&quot;chain&quot;:{&quot;from&quot;:28,&quot;to&quot;:38}},{&quot;label&quot;:&quot;50&quot;,&quot;chain&quot;:{&quot;from&quot;:40,&quot;to&quot;:49}},{&quot;label&quot;:&quot;60&quot;,&quot;chain&quot;:{&quot;from&quot;:51,&quot;to&quot;:59}},{&quot;label&quot;:&quot;69&quot;,&quot;chain&quot;:{&quot;from&quot;:61,&quot;to&quot;:68}},{&quot;label&quot;:&quot;77&quot;,&quot;chain&quot;:{&quot;from&quot;:70,&quot;to&quot;:76}},{&quot;label&quot;:&quot;84&quot;,&quot;chain&quot;:{&quot;from&quot;:78,&quot;to&quot;:83}},{&quot;label&quot;:&quot;90&quot;,&quot;chain&quot;:{&quot;from&quot;:85,&quot;to&quot;:89}},{&quot;label&quot;:&quot;95&quot;,&quot;chain&quot;:{&quot;from&quot;:91,&quot;to&quot;:94}},{&quot;label&quot;:&quot;99&quot;,&quot;chain&quot;:{&quot;from&quot;:96,&quot;to&quot;:98}},{&quot;label&quot;:&quot;102&quot;,&quot;chain&quot;:[100,101]},{&quot;label&quot;:&quot;104&quot;,&quot;chain&quot;:[103]},&quot;105&quot;],&quot;showDepth&quot;:true,&quot;minWidth&quot;:800};

    // Canvas accessibility label (for canvas mode blocks)
    window.__CANVAS_ARIA_LABEL__ = null;

    // Injected sandbox runtime
    (() =&gt; {
  function createCSSGenerator() {
    const generatedClasses = /* @__PURE__ */ new Set();
    const styleSheet = new CSSStyleSheet();
    document.adoptedStyleSheets = [...document.adoptedStyleSheets, styleSheet];
    const spacingScale = {
      &quot;0&quot;: &quot;0&quot;,
      &quot;px&quot;: &quot;1px&quot;,
      &quot;0.5&quot;: &quot;0.125rem&quot;,
      &quot;1&quot;: &quot;0.25rem&quot;,
      &quot;1.5&quot;: &quot;0.375rem&quot;,
      &quot;2&quot;: &quot;0.5rem&quot;,
      &quot;2.5&quot;: &quot;0.625rem&quot;,
      &quot;3&quot;: &quot;0.75rem&quot;,
      &quot;3.5&quot;: &quot;0.875rem&quot;,
      &quot;4&quot;: &quot;1rem&quot;,
      &quot;5&quot;: &quot;1.25rem&quot;,
      &quot;6&quot;: &quot;1.5rem&quot;,
      &quot;7&quot;: &quot;1.75rem&quot;,
      &quot;8&quot;: &quot;2rem&quot;,
      &quot;9&quot;: &quot;2.25rem&quot;,
      &quot;10&quot;: &quot;2.5rem&quot;,
      &quot;11&quot;: &quot;2.75rem&quot;,
      &quot;12&quot;: &quot;3rem&quot;,
      &quot;14&quot;: &quot;3.5rem&quot;,
      &quot;16&quot;: &quot;4rem&quot;,
      &quot;20&quot;: &quot;5rem&quot;,
      &quot;24&quot;: &quot;6rem&quot;,
      &quot;28&quot;: &quot;7rem&quot;,
      &quot;32&quot;: &quot;8rem&quot;,
      &quot;36&quot;: &quot;9rem&quot;,
      &quot;40&quot;: &quot;10rem&quot;,
      &quot;44&quot;: &quot;11rem&quot;,
      &quot;48&quot;: &quot;12rem&quot;,
      &quot;52&quot;: &quot;13rem&quot;,
      &quot;56&quot;: &quot;14rem&quot;,
      &quot;60&quot;: &quot;15rem&quot;,
      &quot;64&quot;: &quot;16rem&quot;,
      &quot;72&quot;: &quot;18rem&quot;,
      &quot;80&quot;: &quot;20rem&quot;,
      &quot;96&quot;: &quot;24rem&quot;
    };
    const sizeValues = {
      &quot;auto&quot;: &quot;auto&quot;,
      &quot;full&quot;: &quot;100%&quot;,
      &quot;screen&quot;: &quot;100vw&quot;,
      // for width
      &quot;min&quot;: &quot;min-content&quot;,
      &quot;max&quot;: &quot;max-content&quot;,
      &quot;fit&quot;: &quot;fit-content&quot;
    };
    const parseArbitraryValue = (value) =&gt; {
      const match = value.match(/^\[(.+)\]$/);
      return match ? match[1] : null;
    };
    const parseOpacity = (className) =&gt; {
      const match = className.match(/^(.+?)\/(\d+)$/);
      if (match) {
        return { base: match[1], opacity: (parseInt(match[2]) / 100).toString() };
      }
      return { base: className, opacity: null };
    };
    const findMatchingBracket = (str, startIndex) =&gt; {
      if (str[startIndex] !== &quot;[&quot;) {
        return -1;
      }
      let depth = 0;
      for (let i = startIndex; i &lt; str.length; i++) {
        const char = str[i];
        if (char === &quot;[&quot;) {
          depth++;
        } else if (char === &quot;]&quot;) {
          depth--;
          if (depth === 0) {
            return i;
          }
        }
      }
      return -1;
    };
    const parseArbitrarySelector = (className) =&gt; {
      if (!className.startsWith(&quot;[&quot;)) {
        return null;
      }
      const closingBracketIndex = findMatchingBracket(className, 0);
      if (closingBracketIndex === -1 || className[closingBracketIndex + 1] !== &quot;:&quot;) {
        return null;
      }
      const bracketContent = className.substring(1, closingBracketIndex);
      if (!bracketContent.startsWith(&quot;&amp;&quot;)) {
        return null;
      }
      const selector = bracketContent.substring(1);
      const baseClass = className.substring(closingBracketIndex + 2);
      return { selector, baseClass };
    };
    const generateRule = (className) =&gt; {
      const arbitrarySelector = parseArbitrarySelector(className);
      if (arbitrarySelector) {
        const { selector, baseClass } = arbitrarySelector;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/&amp;/g, &quot;\\&amp;&quot;).replace(/&gt;/g, &quot;\\&gt;&quot;).replace(/\*/g, &quot;\\*&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\+/g, &quot;\\+&quot;).replace(/~/g, &quot;\\~&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const declarations = baseRule.substring(selectorEnd);
        return `.${escapedClass}${selector} ${declarations}`;
      }
      const variantMatch = className.match(/^(hover|focus|active|disabled|dark):(.+)$/);
      if (variantMatch) {
        const [, variant, baseClass] = variantMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;);
        const selectorEnd = baseRule.indexOf(&quot;{&quot;);
        const baseSelector = baseRule.substring(0, selectorEnd).trim();
        const declarations = baseRule.substring(selectorEnd);
        if (variant === &quot;hover&quot;) {
          return `.${escapedClass}:hover ${declarations}`;
        } else if (variant === &quot;focus&quot;) {
          return `.${escapedClass}:focus ${declarations}`;
        } else if (variant === &quot;active&quot;) {
          return `.${escapedClass}:active ${declarations}`;
        } else if (variant === &quot;disabled&quot;) {
          return `.${escapedClass}:disabled ${declarations}`;
        } else if (variant === &quot;dark&quot;) {
          const pseudoMatch = baseSelector.match(/(:(?:hover|focus|active|disabled|focus-visible)(?:\([^)]*\))?)$/);
          const pseudoSelector = pseudoMatch ? pseudoMatch[1] : &quot;&quot;;
          return `.dark .${escapedClass}${pseudoSelector} ${declarations}`;
        }
      }
      const { base, opacity } = parseOpacity(className);
      const spacingMatch = base.match(/^(px|py|pt|pb|pl|pr|mx|my|mt|mb|ml|mr|gap-x|gap-y|space-x|space-y|min-w|min-h|max-w|max-h|inset-x|inset-y|p|m|gap|w|h|top|right|bottom|left|inset)-(.+)$/);
      if (spacingMatch) {
        const [, property, value] = spacingMatch;
        const spacing = spacingScale[value] || sizeValues[value] || parseArbitraryValue(value);
        if (!spacing) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (property === &quot;space-x&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-x-reverse: 0; margin-inline-start: calc(${spacing} * var(--tw-space-x-reverse)); margin-inline-end: calc(${spacing} * calc(1 - var(--tw-space-x-reverse))); }`;
        }
        if (property === &quot;space-y&quot;) {
          return `.${escapedClass} &gt; :not(:last-child) { --tw-space-y-reverse: 0; margin-block-start: calc(${spacing} * var(--tw-space-y-reverse)); margin-block-end: calc(${spacing} * calc(1 - var(--tw-space-y-reverse))); }`;
        }
        const propertyMap = {
          &quot;p&quot;: [&quot;padding&quot;],
          &quot;px&quot;: [&quot;padding-left&quot;, &quot;padding-right&quot;],
          &quot;py&quot;: [&quot;padding-top&quot;, &quot;padding-bottom&quot;],
          &quot;pt&quot;: [&quot;padding-top&quot;],
          &quot;pb&quot;: [&quot;padding-bottom&quot;],
          &quot;pl&quot;: [&quot;padding-left&quot;],
          &quot;pr&quot;: [&quot;padding-right&quot;],
          &quot;m&quot;: [&quot;margin&quot;],
          &quot;mx&quot;: [&quot;margin-left&quot;, &quot;margin-right&quot;],
          &quot;my&quot;: [&quot;margin-top&quot;, &quot;margin-bottom&quot;],
          &quot;mt&quot;: [&quot;margin-top&quot;],
          &quot;mb&quot;: [&quot;margin-bottom&quot;],
          &quot;ml&quot;: [&quot;margin-left&quot;],
          &quot;mr&quot;: [&quot;margin-right&quot;],
          &quot;gap&quot;: [&quot;gap&quot;],
          &quot;gap-x&quot;: [&quot;column-gap&quot;],
          &quot;gap-y&quot;: [&quot;row-gap&quot;],
          &quot;w&quot;: [&quot;width&quot;],
          &quot;h&quot;: [&quot;height&quot;],
          &quot;min-w&quot;: [&quot;min-width&quot;],
          &quot;min-h&quot;: [&quot;min-height&quot;],
          &quot;max-w&quot;: [&quot;max-width&quot;],
          &quot;max-h&quot;: [&quot;max-height&quot;],
          &quot;top&quot;: [&quot;top&quot;],
          &quot;right&quot;: [&quot;right&quot;],
          &quot;bottom&quot;: [&quot;bottom&quot;],
          &quot;left&quot;: [&quot;left&quot;],
          &quot;inset&quot;: [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;],
          &quot;inset-x&quot;: [&quot;left&quot;, &quot;right&quot;],
          &quot;inset-y&quot;: [&quot;top&quot;, &quot;bottom&quot;]
        };
        const properties = propertyMap[property];
        if (!properties) return null;
        const declarations = properties.map((prop) =&gt; `${prop}: ${spacing}`).join(&quot;; &quot;);
        return `.${escapedClass} { ${declarations}; }`;
      }
      const textSizeMatch = base.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
      if (textSizeMatch) {
        const [, size] = textSizeMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const sizeMap = {
          &quot;xs&quot;: { fontSize: &quot;0.75rem&quot;, lineHeight: &quot;1rem&quot; },
          &quot;sm&quot;: { fontSize: &quot;0.875rem&quot;, lineHeight: &quot;1.25rem&quot; },
          &quot;base&quot;: { fontSize: &quot;1rem&quot;, lineHeight: &quot;1.5rem&quot; },
          &quot;lg&quot;: { fontSize: &quot;1.125rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;xl&quot;: { fontSize: &quot;1.25rem&quot;, lineHeight: &quot;1.75rem&quot; },
          &quot;2xl&quot;: { fontSize: &quot;1.5rem&quot;, lineHeight: &quot;2rem&quot; },
          &quot;3xl&quot;: { fontSize: &quot;1.875rem&quot;, lineHeight: &quot;2.25rem&quot; },
          &quot;4xl&quot;: { fontSize: &quot;2.25rem&quot;, lineHeight: &quot;2.5rem&quot; },
          &quot;5xl&quot;: { fontSize: &quot;3rem&quot;, lineHeight: &quot;1&quot; },
          &quot;6xl&quot;: { fontSize: &quot;3.75rem&quot;, lineHeight: &quot;1&quot; },
          &quot;7xl&quot;: { fontSize: &quot;4.5rem&quot;, lineHeight: &quot;1&quot; },
          &quot;8xl&quot;: { fontSize: &quot;6rem&quot;, lineHeight: &quot;1&quot; },
          &quot;9xl&quot;: { fontSize: &quot;8rem&quot;, lineHeight: &quot;1&quot; }
        };
        const { fontSize, lineHeight } = sizeMap[size];
        return `.${escapedClass} { font-size: ${fontSize}; line-height: ${lineHeight}; }`;
      }
      const fontWeightMatch = base.match(/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/);
      if (fontWeightMatch) {
        const [, weight] = fontWeightMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const weightMap = {
          &quot;thin&quot;: &quot;100&quot;,
          &quot;extralight&quot;: &quot;200&quot;,
          &quot;light&quot;: &quot;300&quot;,
          &quot;normal&quot;: &quot;400&quot;,
          &quot;medium&quot;: &quot;500&quot;,
          &quot;semibold&quot;: &quot;600&quot;,
          &quot;bold&quot;: &quot;700&quot;,
          &quot;extrabold&quot;: &quot;800&quot;,
          &quot;black&quot;: &quot;900&quot;
        };
        return `.${escapedClass} { font-weight: ${weightMap[weight]}; }`;
      }
      const fontFamilyMatch = base.match(/^font-(sans|serif|mono)$/);
      if (fontFamilyMatch) {
        const [, family] = fontFamilyMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        const familyMap = {
          &quot;sans&quot;: &quot;&#x27;Poppins&#x27;, ui-sans-serif, system-ui, -apple-system, sans-serif&quot;,
          &quot;serif&quot;: &quot;ui-serif, Georgia, Cambria, &#x27;Times New Roman&#x27;, Times, serif&quot;,
          &quot;mono&quot;: &quot;&#x27;Space Mono&#x27;, ui-monospace, &#x27;Cascadia Code&#x27;, monospace&quot;
        };
        return `.${escapedClass} { font-family: ${familyMap[family]}; }`;
      }
      const lineHeightMatch = base.match(/^leading-(.+)$/);
      if (lineHeightMatch) {
        const [, value] = lineHeightMatch;
        const heightMap = {
          &quot;none&quot;: &quot;1&quot;,
          &quot;tight&quot;: &quot;1.25&quot;,
          &quot;snug&quot;: &quot;1.375&quot;,
          &quot;normal&quot;: &quot;1.5&quot;,
          &quot;relaxed&quot;: &quot;1.625&quot;,
          &quot;loose&quot;: &quot;2&quot;
        };
        const lineHeight = heightMap[value] || parseArbitraryValue(value);
        if (!lineHeight) return null;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { line-height: ${lineHeight}; }`;
      }
      const flexMatch = base.match(/^flex-(.+)$/);
      if (flexMatch) {
        const [, value] = flexMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const flexValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { flex: ${flexValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { flex: var(${customProp}); }`;
        }
        const fractionMatch = value.match(/^(\d+)\/(\d+)$/);
        if (fractionMatch) {
          const [, numerator, denominator] = fractionMatch;
          return `.${escapedClass} { flex: calc(${numerator} / ${denominator} * 100%); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { flex: ${number}; }`;
        }
      }
      const gridColsMatch = base.match(/^grid-cols-(.+)$/);
      if (gridColsMatch) {
        const [, value] = gridColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-columns: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-columns: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const colsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-columns: ${colsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-columns: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-columns: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const gridRowsMatch = base.match(/^grid-rows-(.+)$/);
      if (gridRowsMatch) {
        const [, value] = gridRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;none&quot;) {
          return `.${escapedClass} { grid-template-rows: none; }`;
        }
        if (value === &quot;subgrid&quot;) {
          return `.${escapedClass} { grid-template-rows: subgrid; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          const rowsValue = arbitraryValue.replace(/_/g, &quot; &quot;);
          return `.${escapedClass} { grid-template-rows: ${rowsValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-template-rows: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-template-rows: repeat(${number}, minmax(0, 1fr)); }`;
        }
      }
      const colStartMatch = base.match(/^col-start-(.+)$/);
      if (colStartMatch) {
        const [, value] = colStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-start: ${number}; }`;
        }
      }
      const colEndMatch = base.match(/^col-end-(.+)$/);
      if (colEndMatch) {
        const [, value] = colEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-column-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column-end: ${number}; }`;
        }
      }
      const colSpanMatch = base.match(/^col-span-(.+)$/);
      if (colSpanMatch) {
        const [, value] = colSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-column: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-column: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-column: span ${number} / span ${number}; }`;
        }
      }
      const colMatch = base.match(/^col-(.+)$/);
      if (colMatch) {
        const [, value] = colMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-column: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-column: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-column: var(${customProp}); }`;
          }
        }
      }
      const rowStartMatch = base.match(/^row-start-(.+)$/);
      if (rowStartMatch) {
        const [, value] = rowStartMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-start: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-start: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-start: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-start: ${number}; }`;
        }
      }
      const rowEndMatch = base.match(/^row-end-(.+)$/);
      if (rowEndMatch) {
        const [, value] = rowEndMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-row-end: auto; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row-end: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row-end: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row-end: ${number}; }`;
        }
      }
      const rowSpanMatch = base.match(/^row-span-(.+)$/);
      if (rowSpanMatch) {
        const [, value] = rowSpanMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;full&quot;) {
          return `.${escapedClass} { grid-row: 1 / -1; }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-row: var(${customProp}); }`;
        }
        const numericMatch = value.match(/^(\d+)$/);
        if (numericMatch) {
          const number = numericMatch[1];
          return `.${escapedClass} { grid-row: span ${number} / span ${number}; }`;
        }
      }
      const rowMatch = base.match(/^row-(.+)$/);
      if (rowMatch) {
        const [, value] = rowMatch;
        if (value.startsWith(&quot;start-&quot;) || value.startsWith(&quot;end-&quot;) || value.startsWith(&quot;span-&quot;)) {
        } else {
          const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
          if (value === &quot;auto&quot;) {
            return `.${escapedClass} { grid-row: auto; }`;
          }
          const arbitraryValue = parseArbitraryValue(value);
          if (arbitraryValue) {
            return `.${escapedClass} { grid-row: ${arbitraryValue}; }`;
          }
          const customPropMatch = value.match(/^\((.+)\)$/);
          if (customPropMatch) {
            const customProp = customPropMatch[1];
            return `.${escapedClass} { grid-row: var(${customProp}); }`;
          }
        }
      }
      const autoColsMatch = base.match(/^auto-cols-(.+)$/);
      if (autoColsMatch) {
        const [, value] = autoColsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-columns: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-columns: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-columns: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-columns: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-columns: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-columns: var(${customProp}); }`;
        }
      }
      const autoRowsMatch = base.match(/^auto-rows-(.+)$/);
      if (autoRowsMatch) {
        const [, value] = autoRowsMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\(/g, &quot;\\(&quot;).replace(/\)/g, &quot;\\)&quot;).replace(/\./g, &quot;\\.&quot;);
        if (value === &quot;auto&quot;) {
          return `.${escapedClass} { grid-auto-rows: auto; }`;
        }
        if (value === &quot;min&quot;) {
          return `.${escapedClass} { grid-auto-rows: min-content; }`;
        }
        if (value === &quot;max&quot;) {
          return `.${escapedClass} { grid-auto-rows: max-content; }`;
        }
        if (value === &quot;fr&quot;) {
          return `.${escapedClass} { grid-auto-rows: minmax(0, 1fr); }`;
        }
        const arbitraryValue = parseArbitraryValue(value);
        if (arbitraryValue) {
          return `.${escapedClass} { grid-auto-rows: ${arbitraryValue}; }`;
        }
        const customPropMatch = value.match(/^\((.+)\)$/);
        if (customPropMatch) {
          const customProp = customPropMatch[1];
          return `.${escapedClass} { grid-auto-rows: var(${customProp}); }`;
        }
      }
      const gridFlowMatch = base.match(/^grid-flow-(.+)$/);
      if (gridFlowMatch) {
        const [, value] = gridFlowMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;);
        if (value === &quot;row&quot;) {
          return `.${escapedClass} { grid-auto-flow: row; }`;
        }
        if (value === &quot;col&quot;) {
          return `.${escapedClass} { grid-auto-flow: column; }`;
        }
        if (value === &quot;dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: dense; }`;
        }
        if (value === &quot;row-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: row dense; }`;
        }
        if (value === &quot;col-dense&quot;) {
          return `.${escapedClass} { grid-auto-flow: column dense; }`;
        }
      }
      const layoutUtilities = {
        // Display
        &quot;flex&quot;: &quot;display: flex&quot;,
        &quot;inline-flex&quot;: &quot;display: inline-flex&quot;,
        &quot;grid&quot;: &quot;display: grid&quot;,
        &quot;inline-grid&quot;: &quot;display: inline-grid&quot;,
        &quot;block&quot;: &quot;display: block&quot;,
        &quot;inline-block&quot;: &quot;display: inline-block&quot;,
        &quot;inline&quot;: &quot;display: inline&quot;,
        &quot;hidden&quot;: &quot;display: none&quot;,
        // Flex direction
        &quot;flex-row&quot;: &quot;flex-direction: row&quot;,
        &quot;flex-row-reverse&quot;: &quot;flex-direction: row-reverse&quot;,
        &quot;flex-col&quot;: &quot;flex-direction: column&quot;,
        &quot;flex-col-reverse&quot;: &quot;flex-direction: column-reverse&quot;,
        // Flex wrap
        &quot;flex-wrap&quot;: &quot;flex-wrap: wrap&quot;,
        &quot;flex-wrap-reverse&quot;: &quot;flex-wrap: wrap-reverse&quot;,
        &quot;flex-nowrap&quot;: &quot;flex-wrap: nowrap&quot;,
        // Flex shrink/grow
        &quot;shrink-0&quot;: &quot;flex-shrink: 0&quot;,
        &quot;shrink&quot;: &quot;flex-shrink: 1&quot;,
        &quot;grow-0&quot;: &quot;flex-grow: 0&quot;,
        &quot;grow&quot;: &quot;flex-grow: 1&quot;,
        // Flex sizing (common static values)
        &quot;flex-1&quot;: &quot;flex: 1 1 0%&quot;,
        &quot;flex-auto&quot;: &quot;flex: 1 1 auto&quot;,
        &quot;flex-initial&quot;: &quot;flex: 0 1 auto&quot;,
        &quot;flex-none&quot;: &quot;flex: none&quot;,
        // Flex/Grid alignment
        &quot;items-start&quot;: &quot;align-items: flex-start&quot;,
        &quot;items-end&quot;: &quot;align-items: flex-end&quot;,
        &quot;items-center&quot;: &quot;align-items: center&quot;,
        &quot;items-baseline&quot;: &quot;align-items: baseline&quot;,
        &quot;items-stretch&quot;: &quot;align-items: stretch&quot;,
        &quot;justify-start&quot;: &quot;justify-content: flex-start&quot;,
        &quot;justify-end&quot;: &quot;justify-content: flex-end&quot;,
        &quot;justify-center&quot;: &quot;justify-content: center&quot;,
        &quot;justify-between&quot;: &quot;justify-content: space-between&quot;,
        &quot;justify-around&quot;: &quot;justify-content: space-around&quot;,
        &quot;justify-evenly&quot;: &quot;justify-content: space-evenly&quot;,
        &quot;place-content-center&quot;: &quot;place-content: center&quot;,
        &quot;place-content-start&quot;: &quot;place-content: start&quot;,
        &quot;place-content-end&quot;: &quot;place-content: end&quot;,
        // Position
        &quot;relative&quot;: &quot;position: relative&quot;,
        &quot;absolute&quot;: &quot;position: absolute&quot;,
        &quot;fixed&quot;: &quot;position: fixed&quot;,
        &quot;sticky&quot;: &quot;position: sticky&quot;,
        // Overflow
        &quot;overflow-hidden&quot;: &quot;overflow: hidden&quot;,
        &quot;overflow-auto&quot;: &quot;overflow: auto&quot;,
        &quot;overflow-scroll&quot;: &quot;overflow: scroll&quot;,
        &quot;overflow-x-hidden&quot;: &quot;overflow-x: hidden&quot;,
        &quot;overflow-y-hidden&quot;: &quot;overflow-y: hidden&quot;,
        &quot;overflow-x-auto&quot;: &quot;overflow-x: auto&quot;,
        &quot;overflow-y-auto&quot;: &quot;overflow-y: auto&quot;,
        // Cursor
        &quot;cursor-pointer&quot;: &quot;cursor: pointer&quot;,
        &quot;cursor-default&quot;: &quot;cursor: default&quot;,
        &quot;cursor-not-allowed&quot;: &quot;cursor: not-allowed&quot;,
        // Text align
        &quot;text-left&quot;: &quot;text-align: left&quot;,
        &quot;text-center&quot;: &quot;text-align: center&quot;,
        &quot;text-right&quot;: &quot;text-align: right&quot;,
        // Text decoration
        &quot;underline&quot;: &quot;text-decoration: underline&quot;,
        &quot;overline&quot;: &quot;text-decoration: overline&quot;,
        &quot;line-through&quot;: &quot;text-decoration: line-through&quot;,
        &quot;no-underline&quot;: &quot;text-decoration: none&quot;,
        // Pointer events
        &quot;pointer-events-none&quot;: &quot;pointer-events: none&quot;,
        &quot;pointer-events-auto&quot;: &quot;pointer-events: auto&quot;,
        // Aspect ratio
        &quot;aspect-square&quot;: &quot;aspect-ratio: 1 / 1&quot;,
        &quot;aspect-video&quot;: &quot;aspect-ratio: 16 / 9&quot;,
        // Shadow
        &quot;shadow&quot;: &quot;box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-sm&quot;: &quot;box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)&quot;,
        &quot;shadow-md&quot;: &quot;box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-lg&quot;: &quot;box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)&quot;,
        &quot;shadow-none&quot;: &quot;box-shadow: none&quot;,
        // Outline
        &quot;outline-none&quot;: &quot;outline: 2px solid transparent; outline-offset: 2px&quot;,
        // Opacity (common values)
        &quot;opacity-0&quot;: &quot;opacity: 0&quot;,
        &quot;opacity-50&quot;: &quot;opacity: 0.5&quot;,
        &quot;opacity-100&quot;: &quot;opacity: 1&quot;,
        // Appearance
        &quot;appearance-none&quot;: &quot;appearance: none; -webkit-appearance: none; -moz-appearance: none&quot;,
        // Border
        &quot;border&quot;: &quot;border-width: 1px; border-style: solid&quot;,
        // Peer
        &quot;peer&quot;: &quot;&quot;
      };
      if (layoutUtilities[className]) {
        return `.${className} { ${layoutUtilities[className]}; }`;
      }
      const opacityMatch = base.match(/^opacity-(\d+)$/);
      if (opacityMatch) {
        const [, value] = opacityMatch;
        const opacityValue = parseInt(value) / 100;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass} { opacity: ${opacityValue}; }`;
      }
      const colorMatch = base.match(/^(bg|text|border|ring|outline|fill)-(.+)$/);
      if (colorMatch) {
        const [, property, colorName] = colorMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const propertyMap = {
          &quot;bg&quot;: &quot;background-color&quot;,
          &quot;text&quot;: &quot;color&quot;,
          &quot;border&quot;: &quot;border-color&quot;,
          &quot;ring&quot;: &quot;--tw-ring-color&quot;,
          &quot;outline&quot;: &quot;outline-color&quot;,
          &quot;fill&quot;: &quot;fill&quot;
        };
        const cssProp = propertyMap[property];
        if (!cssProp) return null;
        if (opacity) {
          return `.${escapedClass} { ${cssProp}: oklch(from var(--color-${colorName}) l c h / ${opacity}); }`;
        } else {
          return `.${escapedClass} { ${cssProp}: var(--color-${colorName}); }`;
        }
      }
      if (className === &quot;transition-colors&quot;) {
        return `.transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition&quot;) {
        return `.transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      if (className === &quot;transition-opacity&quot;) {
        return `.transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }`;
      }
      const borderWidthMatch = base.match(/^border(-[trbl])?-(\d+)$/);
      if (borderWidthMatch) {
        const [, side, width] = borderWidthMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (side) {
          const sideMap = {
            &quot;-t&quot;: &quot;border-top-width&quot;,
            &quot;-r&quot;: &quot;border-right-width&quot;,
            &quot;-b&quot;: &quot;border-bottom-width&quot;,
            &quot;-l&quot;: &quot;border-left-width&quot;
          };
          return `.${escapedClass} { ${sideMap[side]}: ${width}px; }`;
        } else {
          return `.${escapedClass} { border-width: ${width}px; }`;
        }
      }
      const roundedMatch = base.match(/^rounded(-[trblxy])?(-(.+))?$/);
      if (roundedMatch) {
        const [, corner, , value] = roundedMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        const roundedValues = {
          &quot;none&quot;: &quot;0&quot;,
          &quot;sm&quot;: &quot;calc(var(--radius) - 4px)&quot;,
          &quot;md&quot;: &quot;calc(var(--radius) - 2px)&quot;,
          &quot;lg&quot;: &quot;var(--radius)&quot;,
          &quot;xl&quot;: &quot;0.75rem&quot;,
          &quot;2xl&quot;: &quot;1rem&quot;,
          &quot;3xl&quot;: &quot;1.5rem&quot;,
          &quot;full&quot;: &quot;9999px&quot;
        };
        const radiusValue = value ? roundedValues[value] || spacingScale[value] || parseArbitraryValue(value) : &quot;0.25rem&quot;;
        if (!radiusValue) return null;
        const cornerMap = {
          &quot;-t&quot;: [&quot;border-top-left-radius&quot;, &quot;border-top-right-radius&quot;],
          &quot;-r&quot;: [&quot;border-top-right-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-b&quot;: [&quot;border-bottom-left-radius&quot;, &quot;border-bottom-right-radius&quot;],
          &quot;-l&quot;: [&quot;border-top-left-radius&quot;, &quot;border-bottom-left-radius&quot;],
          &quot;-tl&quot;: [&quot;border-top-left-radius&quot;],
          &quot;-tr&quot;: [&quot;border-top-right-radius&quot;],
          &quot;-bl&quot;: [&quot;border-bottom-left-radius&quot;],
          &quot;-br&quot;: [&quot;border-bottom-right-radius&quot;]
        };
        if (corner &amp;&amp; cornerMap[corner]) {
          const declarations = cornerMap[corner].map((prop) =&gt; `${prop}: ${radiusValue}`).join(&quot;; &quot;);
          return `.${escapedClass} { ${declarations}; }`;
        } else {
          return `.${escapedClass} { border-radius: ${radiusValue}; }`;
        }
      }
      const ringMatch = className.match(/^ring(-offset)?(-(\d+))?$/);
      if (ringMatch) {
        const [, offset, , width] = ringMatch;
        const escapedClass = className.replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        if (offset) {
          const ringWidth = width || &quot;2&quot;;
          return `.${escapedClass} { --tw-ring-offset-width: ${ringWidth}px; }`;
        } else {
          const ringWidth = width || &quot;3&quot;;
          return `.${escapedClass} { --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(${ringWidth}px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }`;
        }
      }
      if (className === &quot;ring-offset-background&quot;) {
        return `.ring-offset-background { --tw-ring-offset-color: var(--color-background); }`;
      }
      const focusVisibleMatch = className.match(/^focus-visible:(.+)$/);
      if (focusVisibleMatch) {
        const [, baseClass] = focusVisibleMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}:focus-visible ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      const dataMatch = className.match(/^data-\[(.+?)\]:(.+)$/);
      if (dataMatch) {
        const [, dataAttr, baseClass] = dataMatch;
        const baseRule = generateRule(baseClass);
        if (!baseRule) return null;
        const escapedClass = className.replace(/:/g, &quot;\\:&quot;).replace(/\//g, &quot;\\/&quot;).replace(/\[/g, &quot;\\[&quot;).replace(/]/g, &quot;\\]&quot;).replace(/=/g, &quot;\\=&quot;).replace(/\./g, &quot;\\.&quot;);
        return `.${escapedClass}[data-${dataAttr}] ${baseRule.substring(baseRule.indexOf(&quot;{&quot;))}`;
      }
      return null;
    };
    const css = (classNames) =&gt; {
      const classes = classNames.trim().split(/\s+/).filter(Boolean);
      for (const className of classes) {
        if (generatedClasses.has(className)) continue;
        const rule = generateRule(className);
        if (rule) {
          try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
            generatedClasses.add(className);
          } catch (error) {
            console.error(`[DynamicBlock Error] Failed to generate CSS for class: ${className}`, error);
          }
        }
      }
      return classNames;
    };
    return css;
  }
  function createUIHelpers(cssGenerator) {
    const isSelector = (arg) =&gt; typeof arg === &quot;string&quot;;
    const applyClasses = (element, baseClasses, customClassName) =&gt; {
      const allClasses = customClassName ? `${baseClasses} ${customClassName}`.replace(/\s+/g, &quot; &quot;).trim() : baseClasses;
      cssGenerator(allClasses);
      if (element instanceof SVGElement) {
        element.setAttribute(&quot;class&quot;, allClasses);
      } else {
        element.className = allClasses;
      }
    };
    const applyStyles = (element, styles) =&gt; {
      if (!styles) return;
      Object.entries(styles).forEach(([property, value]) =&gt; {
        if (element instanceof HTMLElement) {
          element.style.setProperty(property, value);
        } else {
          const currentStyle = element.getAttribute(&quot;style&quot;) || &quot;&quot;;
          const newStyle = `${currentStyle}${currentStyle ? &quot;; &quot; : &quot;&quot;}${property}: ${value}`;
          element.setAttribute(&quot;style&quot;, newStyle);
        }
      });
    };
    return {
      /**
       * Button helper - creates or enhances button elements
       */
      button(selectorOrOptions, options) {
        const baseClasses = &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50&quot;;
        const getVariantClasses = (variant2 = &quot;contained&quot;, color2 = &quot;primary&quot;, size2 = &quot;md&quot;) =&gt; {
          const variantBaseMap = {
            contained: &quot;&quot;,
            outlined: &quot;border bg-background&quot;,
            text: &quot;&quot;,
            ghost: &quot;&quot;
          };
          const variantColorMap = {
            contained: `bg-${color2} text-${color2}-foreground hover:bg-${color2}/80`,
            outlined: `border-${color2} text-${color2} hover:bg-${color2}/20`,
            text: `text-${color2} hover:bg-${color2}/20`,
            ghost: `text-${color2} hover:bg-${color2} hover:text-background`
          };
          const sizeMap = {
            sm: &quot;h-9 rounded-md px-3 text-sm&quot;,
            md: &quot;h-10 px-4 py-2&quot;,
            lg: &quot;h-12 rounded-md px-6 text-base&quot;,
            xl: &quot;h-14 rounded-md px-8 text-lg&quot;,
            icon: &quot;h-10 w-10&quot;
          };
          const variantBase = variantBaseMap[variant2] || variantBaseMap.contained;
          const variantColor = variantColorMap[variant2] || variantColorMap.contained;
          const sizeClasses = sizeMap[size2] || sizeMap.md;
          return `${baseClasses} ${variantBase} ${variantColor} ${sizeClasses}`.replace(/\s+/g, &quot; &quot;).trim();
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((btn2) =&gt; {
            const { variant: variant2, color: color2, size: size2, disabled: disabled2, onClick: onClick2, className: className2, style: style2 } = options || {};
            applyClasses(btn2, getVariantClasses(variant2, color2, size2), className2);
            applyStyles(btn2, style2);
            if (disabled2 !== void 0) btn2.disabled = disabled2;
            if (onClick2) btn2.addEventListener(&quot;click&quot;, onClick2);
          });
          return elements;
        }
        const { label, variant, color, size, disabled, onClick, className, style } = selectorOrOptions;
        const btn = document.createElement(&quot;button&quot;);
        btn.type = &quot;button&quot;;
        if (label) btn.textContent = label;
        applyClasses(btn, getVariantClasses(variant, color, size), className);
        applyStyles(btn, style);
        if (disabled) btn.disabled = disabled;
        if (onClick) btn.addEventListener(&quot;click&quot;, onClick);
        return btn;
      },
      /**
       * Input helper - creates or enhances input elements
       */
      input(selectorOrOptions, options) {
        const baseClasses = &quot;flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((input2) =&gt; {
            const { type: type2, placeholder: placeholder2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(input2, baseClasses, className2);
            applyStyles(input2, style2);
            if (type2) input2.type = type2;
            if (placeholder2) input2.placeholder = placeholder2;
            if (disabled2 !== void 0) input2.disabled = disabled2;
            if (value2 !== void 0) input2.value = value2;
            if (onInput2) input2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) input2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { type, placeholder, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const input = document.createElement(&quot;input&quot;);
        input.type = type || &quot;text&quot;;
        applyClasses(input, baseClasses, className);
        applyStyles(input, style);
        if (placeholder) input.placeholder = placeholder;
        if (disabled) input.disabled = disabled;
        if (value !== void 0) input.value = value;
        if (onInput) input.addEventListener(&quot;input&quot;, onInput);
        if (onChange) input.addEventListener(&quot;change&quot;, onChange);
        return input;
      },
      /**
       * Textarea helper - creates or enhances textarea elements
       */
      textarea(selectorOrOptions, options) {
        const baseClasses = &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;;
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((textarea2) =&gt; {
            const { placeholder: placeholder2, rows: rows2, disabled: disabled2, value: value2, onInput: onInput2, onChange: onChange2, className: className2, style: style2 } = options || {};
            applyClasses(textarea2, baseClasses, className2);
            applyStyles(textarea2, style2);
            if (placeholder2) textarea2.placeholder = placeholder2;
            if (rows2) textarea2.rows = rows2;
            if (disabled2 !== void 0) textarea2.disabled = disabled2;
            if (value2 !== void 0) textarea2.value = value2;
            if (onInput2) textarea2.addEventListener(&quot;input&quot;, onInput2);
            if (onChange2) textarea2.addEventListener(&quot;change&quot;, onChange2);
          });
          return elements;
        }
        const { placeholder, rows, disabled, value, onInput, onChange, className, style } = selectorOrOptions;
        const textarea = document.createElement(&quot;textarea&quot;);
        applyClasses(textarea, baseClasses, className);
        applyStyles(textarea, style);
        if (placeholder) textarea.placeholder = placeholder;
        if (rows) textarea.rows = rows;
        if (disabled) textarea.disabled = disabled;
        if (value !== void 0) textarea.value = value;
        if (onInput) textarea.addEventListener(&quot;input&quot;, onInput);
        if (onChange) textarea.addEventListener(&quot;change&quot;, onChange);
        return textarea;
      },
      /**
       * Select helper - creates or enhances select elements
       * Uses native HTML select with chevron icon styling to match shadcn
       */
      select(selectorOrOptions, options) {
        const createSelectWrapper = (items2, value2, placeholder2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;relative w-full&quot;, className2);
          applyStyles(wrapper, style2);
          const select = document.createElement(&quot;select&quot;);
          const selectClasses = &quot;sandbox-select flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 appearance-none cursor-pointer&quot;;
          applyClasses(select, selectClasses);
          if (placeholder2) {
            const placeholderOption = document.createElement(&quot;option&quot;);
            placeholderOption.value = &quot;&quot;;
            placeholderOption.textContent = placeholder2;
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            select.appendChild(placeholderOption);
            select.required = true;
          }
          if (items2) {
            items2.forEach((item) =&gt; {
              const option = document.createElement(&quot;option&quot;);
              option.value = item.value;
              option.textContent = item.label;
              select.appendChild(option);
            });
          }
          if (value2) {
            select.value = value2;
            if (placeholder2) select.required = false;
          }
          if (disabled2) select.disabled = disabled2;
          if (onChange2) {
            select.addEventListener(&quot;change&quot;, (e) =&gt; {
              const newValue = e.target.value;
              if (placeholder2) {
                select.required = newValue === &quot;&quot;;
              }
              onChange2(newValue);
            });
          }
          const chevron = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(chevron, &quot;h-4 w-4 opacity-50 pointer-events-none&quot;);
          chevron.style.position = &quot;absolute&quot;;
          chevron.style.right = &quot;0.75rem&quot;;
          chevron.style.top = &quot;50%&quot;;
          chevron.style.transform = &quot;translateY(-50%)&quot;;
          chevron.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          chevron.setAttribute(&quot;width&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;height&quot;, &quot;24&quot;);
          chevron.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          chevron.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          chevron.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          chevron.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          chevron.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          chevron.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;6 9 12 15 18 9&quot;);
          chevron.appendChild(polyline);
          select.style.paddingRight = &quot;2.5rem&quot;;
          wrapper.appendChild(select);
          wrapper.appendChild(chevron);
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          const wrappers = [];
          elements.forEach((select) =&gt; {
            const { items: items2, value: value2, placeholder: placeholder2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const wrapper = createSelectWrapper(items2, value2, placeholder2, disabled2, onChange2, className2, style2);
            select.replaceWith(wrapper);
            wrappers.push(wrapper);
          });
          return document.querySelectorAll(&quot;.relative:has(select)&quot;);
        }
        const { items, value, placeholder, disabled, onChange, className, style } = selectorOrOptions;
        return createSelectWrapper(items, value, placeholder, disabled, onChange, className, style);
      },
      /**
       * Checkbox helper - creates checkbox elements matching shadcn Radix UI styling
       * Uses custom div-based checkbox with check icon for visual parity
       */
      checkbox(selectorOrOptions, options) {
        const createCheckbox = (checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const checkboxContainer = document.createElement(&quot;button&quot;);
          checkboxContainer.type = &quot;button&quot;;
          checkboxContainer.role = &quot;checkbox&quot;;
          checkboxContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          const checkboxClasses = &quot;grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer&quot;;
          applyClasses(checkboxContainer, checkboxClasses);
          const updateCheckboxStyles = (isChecked2) =&gt; {
            if (isChecked2) {
              checkboxContainer.style.backgroundColor = &quot;var(--color-checkbox-checked)&quot;;
              checkboxContainer.style.color = &quot;var(--color-checkbox-checked-foreground)&quot;;
            } else {
              checkboxContainer.style.backgroundColor = &quot;&quot;;
              checkboxContainer.style.color = &quot;&quot;;
            }
          };
          updateCheckboxStyles(!!checked2);
          if (disabled2) {
            checkboxContainer.disabled = true;
          }
          const checkIcon = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          applyClasses(checkIcon, &quot;h-4 w-4&quot;);
          checkIcon.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          checkIcon.setAttribute(&quot;width&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;height&quot;, &quot;24&quot;);
          checkIcon.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          checkIcon.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          checkIcon.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          checkIcon.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          checkIcon.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          checkIcon.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          const polyline = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;polyline&quot;);
          polyline.setAttribute(&quot;points&quot;, &quot;20 6 9 17 4 12&quot;);
          checkIcon.appendChild(polyline);
          if (checked2) {
            checkboxContainer.appendChild(checkIcon);
          }
          let isChecked = !!checked2;
          checkboxContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            isChecked = !isChecked;
            checkboxContainer.setAttribute(&quot;aria-checked&quot;, isChecked ? &quot;true&quot; : &quot;false&quot;);
            updateCheckboxStyles(isChecked);
            if (isChecked) {
              checkboxContainer.appendChild(checkIcon);
            } else {
              if (checkIcon.parentNode === checkboxContainer) {
                checkboxContainer.removeChild(checkIcon);
              }
            }
            if (onChange2) onChange2(isChecked);
          });
          wrapper.appendChild(checkboxContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) checkboxContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const checkboxWrapper = createCheckbox(checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(checkboxWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createCheckbox(checked, label, disabled, onChange, className, style);
      },
      /**
       * Radio helper - creates radio button elements matching shadcn Radix UI styling
       * Uses custom button-based radio with circle fill indicator for visual parity
       */
      radio(selectorOrOptions, options) {
        const createRadio = (name2, value2, checked2, label2, disabled2, onChange2, className2, style2) =&gt; {
          const wrapper = document.createElement(&quot;div&quot;);
          applyClasses(wrapper, &quot;flex items-center gap-2&quot;, className2);
          applyStyles(wrapper, style2);
          const radioContainer = document.createElement(&quot;button&quot;);
          radioContainer.type = &quot;button&quot;;
          radioContainer.role = &quot;radio&quot;;
          radioContainer.setAttribute(&quot;aria-checked&quot;, checked2 ? &quot;true&quot; : &quot;false&quot;);
          radioContainer.setAttribute(&quot;data-name&quot;, name2);
          radioContainer.setAttribute(&quot;data-value&quot;, value2);
          const radioClasses = &quot;aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer flex items-center justify-center&quot;;
          applyClasses(radioContainer, radioClasses);
          if (disabled2) {
            radioContainer.disabled = true;
          }
          const circleIndicator = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
          circleIndicator.setAttribute(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;);
          circleIndicator.setAttribute(&quot;width&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;height&quot;, &quot;24&quot;);
          circleIndicator.setAttribute(&quot;viewBox&quot;, &quot;0 0 24 24&quot;);
          circleIndicator.setAttribute(&quot;fill&quot;, &quot;none&quot;);
          circleIndicator.setAttribute(&quot;stroke&quot;, &quot;currentColor&quot;);
          circleIndicator.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
          circleIndicator.setAttribute(&quot;stroke-linecap&quot;, &quot;round&quot;);
          circleIndicator.setAttribute(&quot;stroke-linejoin&quot;, &quot;round&quot;);
          applyClasses(circleIndicator, &quot;h-3.5 w-3.5 fill-primary&quot;);
          const circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;circle&quot;);
          circle.setAttribute(&quot;cx&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;cy&quot;, &quot;12&quot;);
          circle.setAttribute(&quot;r&quot;, &quot;10&quot;);
          circleIndicator.appendChild(circle);
          if (checked2) {
            radioContainer.appendChild(circleIndicator);
          }
          radioContainer.addEventListener(&quot;click&quot;, (e) =&gt; {
            if (disabled2) return;
            e.preventDefault();
            const allRadiosInGroup = document.querySelectorAll(`[role=&quot;radio&quot;][data-name=&quot;${name2}&quot;]`);
            allRadiosInGroup.forEach((radio) =&gt; {
              radio.setAttribute(&quot;aria-checked&quot;, &quot;false&quot;);
              while (radio.firstChild) {
                radio.removeChild(radio.firstChild);
              }
            });
            radioContainer.setAttribute(&quot;aria-checked&quot;, &quot;true&quot;);
            radioContainer.appendChild(circleIndicator);
            if (onChange2) onChange2(value2);
          });
          wrapper.appendChild(radioContainer);
          if (label2) {
            const labelEl = document.createElement(&quot;label&quot;);
            applyClasses(labelEl, &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer&quot;);
            labelEl.textContent = label2;
            labelEl.addEventListener(&quot;click&quot;, () =&gt; {
              if (!disabled2) radioContainer.click();
            });
            wrapper.appendChild(labelEl);
          }
          return wrapper;
        };
        if (isSelector(selectorOrOptions)) {
          const elements = document.querySelectorAll(selectorOrOptions);
          elements.forEach((el) =&gt; {
            const { name: name2, value: value2, checked: checked2, label: label2, disabled: disabled2, onChange: onChange2, className: className2, style: style2 } = options || {};
            const radioWrapper = createRadio(name2, value2, checked2, label2, disabled2, onChange2, className2, style2);
            el.replaceWith(radioWrapper);
          });
          return document.querySelectorAll(selectorOrOptions);
        }
        const { name, value, checked, label, disabled, onChange, className, style } = selectorOrOptions;
        return createRadio(name, value, checked, label, disabled, onChange, className, style);
      }
    };
  }
  function scanAndGenerateClasses(api) {
    const classNames = /* @__PURE__ */ new Set();
    const elements = document.querySelectorAll(&quot;[class]&quot;);
    elements.forEach((element) =&gt; {
      const classList = element.className;
      if (typeof classList === &quot;string&quot;) {
        classList.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
    });
    const scripts = document.querySelectorAll(&quot;script&quot;);
    scripts.forEach((script) =&gt; {
      const content = script.textContent || &quot;&quot;;
      const stringMatches = content.matchAll(/(?:className|class)\s*[=:]\s*[&quot;&#x27;`]([^&quot;&#x27;`]+)[&quot;&#x27;`]/g);
      for (const match of stringMatches) {
        const classes = match[1];
        classes.split(/\s+/).forEach((cls) =&gt; {
          if (cls) classNames.add(cls);
        });
      }
      const templateMatches = content.matchAll(/`([^`]*(?:p-|m-|bg-|text-|border-|rounded|flex|grid|grid-cols-|grid-rows-|grid-flow-|auto-cols-|auto-rows-|col-|row-|w-|h-|gap-)[^`]*)`/g);
      for (const match of templateMatches) {
        const classes = match[1];
        const tailwindMatches = classes.matchAll(/\b((?:p|px|py|pt|pb|pl|pr|m|mx|my|mt|mb|ml|mr|gap|gap-x|gap-y|w|h|min-w|min-h|max-w|max-h|bg|text|border|rounded|flex|grid|grid-cols|grid-rows|grid-flow|auto-cols|auto-rows|col|row|inline|block|hidden|top|right|bottom|left|inset)(?:-[\w[\]/:.%-]+)?)\b/g);
        for (const tailwindMatch of tailwindMatches) {
          if (tailwindMatch[1]) classNames.add(tailwindMatch[1]);
        }
      }
    });
    if (classNames.size &gt; 0) {
      const allClasses = Array.from(classNames).join(&quot; &quot;);
      api.css(allClasses);
    }
  }
  function setupMutationObserver(api) {
    const sandboxWindow2 = window;
    const config = sandboxWindow2.$CONFIG || {};
    const autoDetectClasses = config.autoDetectClasses !== false;
    if (!autoDetectClasses) {
      return;
    }
    const observer = new MutationObserver((mutations) =&gt; {
      const classNames = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        mutation.addedNodes.forEach((node) =&gt; {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
              element.className.split(/\s+/).forEach((cls) =&gt; {
                if (cls) classNames.add(cls);
              });
            }
            element.querySelectorAll(&quot;[class]&quot;).forEach((child) =&gt; {
              if (typeof child.className === &quot;string&quot;) {
                child.className.split(/\s+/).forEach((cls) =&gt; {
                  if (cls) classNames.add(cls);
                });
              }
            });
          }
        });
        if (mutation.type === &quot;attributes&quot; &amp;&amp; mutation.attributeName === &quot;class&quot;) {
          const element = mutation.target;
          if (element.className &amp;&amp; typeof element.className === &quot;string&quot;) {
            element.className.split(/\s+/).forEach((cls) =&gt; {
              if (cls) classNames.add(cls);
            });
          }
        }
      }
      if (classNames.size &gt; 0) {
        const allClasses = Array.from(classNames).join(&quot; &quot;);
        api.css(allClasses);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [&quot;class&quot;]
    });
  }
  const clamp = (v, min, max) =&gt; Math.min(Math.max(v, min), max);
  function parseColor(input) {
    const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${input}`).trim();
    const colorStr = cssVar || input;
    const oklchMatch = colorStr.match(/oklch\(([^)]+)\)/);
    if (oklchMatch) {
      const parts = oklchMatch[1].split(&quot;/&quot;);
      const channels = parts[0].trim().split(/\s+/);
      if (channels.length === 3) {
        const parseVal = (s, pctScale) =&gt; s.endsWith(&quot;%&quot;) ? parseFloat(s) / 100 * pctScale : parseFloat(s);
        const l = parseVal(channels[0], 1);
        const c = parseVal(channels[1], 1);
        const h = parseVal(channels[2], 360);
        let a2 = 1;
        if (parts[1] != null) {
          const alphaStr = parts[1].trim();
          a2 = alphaStr.endsWith(&quot;%&quot;) ? parseFloat(alphaStr) / 100 : parseFloat(alphaStr);
        }
        if (!isNaN(l) &amp;&amp; !isNaN(c) &amp;&amp; !isNaN(h) &amp;&amp; !isNaN(a2)) {
          return oklchToRgb({ l, c, h, a: a2 });
        }
      }
    }
    const canvas = document.createElement(&quot;canvas&quot;);
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext(&quot;2d&quot;);
    ctx.fillStyle = colorStr;
    ctx.fillRect(0, 0, 1, 1);
    const [r, g, b, a] = ctx.getImageData(0, 0, 1, 1).data;
    return { r: r / 255, g: g / 255, b: b / 255, a: a / 255 };
  }
  function srgbToLinear(c) {
    return c &lt;= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  function linearToSrgb(c) {
    return c &lt;= 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }
  function rgbToOklab(rgb) {
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    const l_ = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    const m_ = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    const s_ = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    const l = Math.cbrt(l_);
    const m = Math.cbrt(m_);
    const s = Math.cbrt(s_);
    return {
      L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
      a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
      b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s,
      alpha: rgb.a
    };
  }
  function oklabToRgb(lab) {
    const l = lab.L + 0.3963377774 * lab.a + 0.2158037573 * lab.b;
    const m = lab.L - 0.1055613458 * lab.a - 0.0638541728 * lab.b;
    const s = lab.L - 0.0894841775 * lab.a - 1.291485548 * lab.b;
    const l3 = l * l * l;
    const m3 = m * m * m;
    const s3 = s * s * s;
    return {
      r: clamp(linearToSrgb(4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3), 0, 1),
      g: clamp(linearToSrgb(-1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3), 0, 1),
      b: clamp(linearToSrgb(-0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3), 0, 1),
      a: lab.alpha
    };
  }
  function oklabToOklch(lab) {
    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
    let h = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    if (h &lt; 0) h += 360;
    return { l: lab.L, c, h, a: lab.alpha };
  }
  function oklchToOklab(oklch) {
    const hRad = oklch.h * Math.PI / 180;
    return {
      L: oklch.l,
      a: oklch.c * Math.cos(hRad),
      b: oklch.c * Math.sin(hRad),
      alpha: oklch.a
    };
  }
  function rgbToOklch(rgb) {
    return oklabToOklch(rgbToOklab(rgb));
  }
  function oklchToRgb(oklch) {
    return oklabToRgb(oklchToOklab(oklch));
  }
  function rgbToHsl(rgb) {
    const { r, g, b } = rgb;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const d = max - min;
    const l = (max + min) / 2;
    if (d === 0) return { h: 0, s: 0, l: l * 100, a: rgb.a };
    const s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    let h = 0;
    if (max === r) h = ((g - b) / d + (g &lt; b ? 6 : 0)) / 6;
    else if (max === g) h = ((b - r) / d + 2) / 6;
    else h = ((r - g) / d + 4) / 6;
    return { h: h * 360, s: s * 100, l: l * 100, a: rgb.a };
  }
  function hslToRgb(hsl) {
    const h = hsl.h / 360;
    const s = hsl.s / 100;
    const l = hsl.l / 100;
    if (s === 0) return { r: l, g: l, b: l, a: hsl.a };
    const hue2rgb = (p2, q2, t) =&gt; {
      if (t &lt; 0) t += 1;
      if (t &gt; 1) t -= 1;
      if (t &lt; 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t &lt; 1 / 2) return q2;
      if (t &lt; 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return {
      r: hue2rgb(p, q, h + 1 / 3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1 / 3),
      a: hsl.a
    };
  }
  function formatOklch(oklch) {
    const l = Math.round(oklch.l * 1e3) / 1e3;
    const c = Math.round(oklch.c * 1e3) / 1e3;
    const h = Math.round(oklch.h * 100) / 100;
    if (oklch.a &lt; 1) {
      const a = Math.round(oklch.a * 1e3) / 1e3;
      return `oklch(${l} ${c} ${h} / ${a})`;
    }
    return `oklch(${l} ${c} ${h})`;
  }
  function determineAdjustSpace(opts) {
    if (opts.space) return opts.space;
    const hasOklch = opts.lightness != null || opts.chroma != null || opts.hue != null;
    const hasHsl = opts.saturation != null;
    const hasRgb = opts.red != null || opts.green != null || opts.blue != null;
    if (hasHsl &amp;&amp; !hasOklch &amp;&amp; !hasRgb) return &quot;hsl&quot;;
    if (hasRgb &amp;&amp; !hasOklch &amp;&amp; !hasHsl) return &quot;rgb&quot;;
    if (hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    if (!hasOklch &amp;&amp; !hasHsl &amp;&amp; !hasRgb) return &quot;oklch&quot;;
    throw new Error(
      &quot;[getColor] Cannot mix channels from different color spaces. Use the space parameter to disambiguate, or only use channels from one space.&quot;
    );
  }
  function adjustColor(input, opts) {
    const rgba = parseColor(input);
    const space = determineAdjustSpace(opts);
    const alphaAdj = opts.alpha ?? 0;
    if (space === &quot;oklch&quot;) {
      const oklch = rgbToOklch(rgba);
      oklch.l = clamp(oklch.l + (opts.lightness ?? 0), 0, 1);
      oklch.c = Math.max(0, oklch.c + (opts.chroma ?? 0));
      oklch.h = ((oklch.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      oklch.a = clamp(oklch.a + alphaAdj, 0, 1);
      return formatOklch(oklch);
    }
    if (space === &quot;hsl&quot;) {
      const hsl = rgbToHsl(rgba);
      hsl.h = ((hsl.h + (opts.hue ?? 0)) % 360 + 360) % 360;
      hsl.s = clamp(hsl.s + (opts.saturation ?? 0), 0, 100);
      hsl.l = clamp(hsl.l + (opts.lightness ?? 0), 0, 100);
      hsl.a = clamp(hsl.a + alphaAdj, 0, 1);
      const rgb = hslToRgb(hsl);
      return formatOklch(rgbToOklch(rgb));
    }
    const r = clamp(rgba.r + (opts.red ?? 0) / 255, 0, 1);
    const g = clamp(rgba.g + (opts.green ?? 0) / 255, 0, 1);
    const b = clamp(rgba.b + (opts.blue ?? 0) / 255, 0, 1);
    const a = clamp(rgba.a + alphaAdj, 0, 1);
    return formatOklch(rgbToOklch({ r, g, b, a }));
  }
  function initializeSandbox() {
    const themeChangeCallbacks = [];
    const resizeCallbacks = [];
    let currentTheme = document.documentElement.classList.contains(&quot;dark&quot;) ? &quot;dark&quot; : &quot;light&quot;;
    const cssGenerator = createCSSGenerator();
    const api = {
      get theme() {
        return currentTheme;
      },
      size: {
        get width() {
          return window.innerWidth;
        }
      },
      onResize: (callback) =&gt; {
        resizeCallbacks.push(callback);
        callback(window.innerWidth);
      },
      onThemeChange: (callback) =&gt; {
        themeChangeCallbacks.push(callback);
        callback(currentTheme);
      },
      requestResize: (height) =&gt; {
        window.parent.postMessage(
          {
            event: &quot;resize-request&quot;,
            data: { height }
          },
          &quot;*&quot;
        );
      },
      getColor: (color, adjust) =&gt; {
        if (adjust) {
          return adjustColor(color, adjust);
        }
        const cssVar = getComputedStyle(document.documentElement).getPropertyValue(`--color-${color}`).trim();
        if (cssVar) return cssVar;
        return formatOklch(rgbToOklch(parseColor(color)));
      },
      getFont: (name) =&gt; {
        if (name === &quot;default&quot;) {
          const value = getComputedStyle(document.body).fontFamily;
          return value.trim();
        } else if (name === &quot;mono&quot;) {
          return &#x27;&quot;Space Mono&quot;, ui-monospace, &quot;Cascadia Code&quot;, monospace&#x27;;
        }
        return &quot;&quot;;
      },
      css: cssGenerator,
      ui: createUIHelpers(cssGenerator),
      emit: (event, data) =&gt; {
        void event;
        void data;
      }
    };
    window.addEventListener(&quot;message&quot;, (event) =&gt; {
      if (event.data?.event === &quot;theme-change&quot;) {
        const newTheme = event.data.data.theme;
        if (newTheme === &quot;dark&quot;) {
          document.documentElement.classList.add(&quot;dark&quot;);
        } else {
          document.documentElement.classList.remove(&quot;dark&quot;);
        }
        currentTheme = newTheme;
        themeChangeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newTheme);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onThemeChange callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }
    });
    let resizeTimeout;
    window.addEventListener(&quot;resize&quot;, () =&gt; {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() =&gt; {
        const newWidth = window.innerWidth;
        resizeCallbacks.forEach((callback) =&gt; {
          try {
            callback(newWidth);
          } catch (error) {
            console.error(&quot;[DynamicBlock Error] Error in onResize callback:&quot;, error);
            console.error(&quot;Stack trace:&quot;, error.stack);
          }
        });
      }, 150);
    });
    const sandboxWindow2 = window;
    sandboxWindow2.sandboxContext = api;
    setupAutoResize(api);
    scanAndGenerateClasses(api);
    setupMutationObserver(api);
  }
  function setupAutoResize(api) {
    let lastHeight = 0;
    const updateHeight = () =&gt; {
      const root2 = document.getElementById(&quot;root&quot;);
      if (!root2) return;
      const currentHeight = root2.scrollHeight;
      if (currentHeight !== lastHeight) {
        lastHeight = currentHeight;
        api.requestResize(currentHeight);
      }
    };
    const resizeObserver = new ResizeObserver(() =&gt; {
      updateHeight();
    });
    const root = document.getElementById(&quot;root&quot;);
    if (root) {
      resizeObserver.observe(root);
    }
    setTimeout(updateHeight, 0);
  }
  initializeSandbox();
  function executeMountIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const root = document.getElementById(&quot;root&quot;);
      if (!root) {
        console.error(&quot;[DynamicBlock Error] Root element not found - cannot execute mount()&quot;);
        return;
      }
      if (typeof sandboxWindow2.mount === &quot;function&quot;) {
        try {
          sandboxWindow2.mount({ root, api, props });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in mount() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error in executeMountIfExists():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  function executeDrawIfExists(props = {}) {
    try {
      const sandboxWindow2 = window;
      const api = sandboxWindow2.sandboxContext;
      const drawFn = sandboxWindow2.draw;
      if (!api) {
        console.error(&quot;[DynamicBlock Error] Sandbox context not initialized&quot;);
        return;
      }
      if (typeof drawFn !== &quot;function&quot;) {
        return;
      }
      let canvas = document.querySelector(&quot;canvas&quot;);
      if (!canvas) {
        const root = document.getElementById(&quot;root&quot;);
        if (!root) {
          console.error(&quot;[DynamicBlock Error] Root element not found - cannot create canvas&quot;);
          return;
        }
        root.innerHTML = &quot;&quot;;
        canvas = document.createElement(&quot;canvas&quot;);
        canvas.className = api.css(&quot;[&amp;:not([width])]:w-full [&amp;[width]]:mx-auto&quot;);
        root.appendChild(canvas);
      }
      const ariaLabel = sandboxWindow2.__CANVAS_ARIA_LABEL__;
      if (ariaLabel &amp;&amp; typeof ariaLabel === &quot;string&quot;) {
        canvas.setAttribute(&quot;aria-label&quot;, ariaLabel);
      }
      const autoRedrawConfig = sandboxWindow2.autoRedraw || {
        onThemeChange: true,
        onResize: true
      };
      const themeChangeConfig = autoRedrawConfig.onThemeChange === false ? false : autoRedrawConfig.onThemeChange || 0;
      const resizeConfig = autoRedrawConfig.onResize === false ? false : autoRedrawConfig.onResize === true ? 150 : autoRedrawConfig.onResize;
      let resizeTimeout;
      const executeDraw = () =&gt; {
        try {
          const theme = api.theme;
          const width = window.innerWidth;
          drawFn({ canvas, api, theme, width, props });
          requestAnimationFrame(() =&gt; {
            const root = document.getElementById(&quot;root&quot;);
            if (root) {
              const height = root.scrollHeight;
              if (height &gt; 0) {
                api.requestResize(height);
              }
            }
          });
        } catch (error) {
          console.error(&quot;[DynamicBlock Error] Error in draw() function:&quot;, error);
          console.error(&quot;Stack trace:&quot;, error.stack);
        }
      };
      executeDraw();
      if (themeChangeConfig !== false) {
        api.onThemeChange(() =&gt; {
          const debounce = typeof themeChangeConfig === &quot;number&quot; ? themeChangeConfig : 0;
          if (debounce === 0) {
            executeDraw();
          } else {
            setTimeout(executeDraw, debounce);
          }
        });
      }
      if (resizeConfig !== false) {
        api.onResize(() =&gt; {
          clearTimeout(resizeTimeout);
          const debounce = typeof resizeConfig === &quot;number&quot; ? resizeConfig : 150;
          resizeTimeout = window.setTimeout(executeDraw, debounce);
        });
      }
    } catch (error) {
      console.error(&quot;[DynamicBlock Error] Fatal error setting up draw():&quot;, error);
      console.error(&quot;Stack trace:&quot;, error.stack);
    }
  }
  const sandboxWindow = window;
  sandboxWindow.executeMountIfExists = executeMountIfExists;
  sandboxWindow.executeDrawIfExists = executeDrawIfExists;
})();

  &lt;/script&gt;

  &lt;!-- User code script with source mapping --&gt;
  &lt;script&gt;//# sourceURL=content/puzzles/optimisation/egg-dropping.md
























































































































































































































































































































// Normalize columns: expand ranges, compute full chain length
function normalizeColumns(rawColumns) {
  return rawColumns.map(col =&gt; {
    // Handle shorthand: plain string → { label: &quot;X&quot; }
    if (typeof col === &#x27;string&#x27;) {
      return { label: col, chain: [], fullChainLength: 0, depth: null };
    }

    const { label, chain, depth } = col;
    let chainLabels = [];
    let fullLength = 0;

    if (!chain) {
      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };
    }

    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]
    if (typeof chain === &#x27;object&#x27; &amp;&amp; !Array.isArray(chain)) {
      const { from, to } = chain;
      fullLength = to - from + 1;
      for (let i = from; i &lt;= to; i++) {
        chainLabels.push(String(i));
      }
    } else {
      chainLabels = chain.map(String);
      // Derive full length from first and last numeric items
      const nums = chainLabels.filter(l =&gt; l !== &#x27;...&#x27;).map(Number);
      if (nums.length &gt;= 2) {
        fullLength = nums[nums.length - 1] - nums[0] + 1;
      } else {
        fullLength = nums.length;
      }
    }

    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };
  });
}

// Compute layout parameters based on columns and container width
function computeLayout(columns, containerWidth, options) {
  const { showDepth, minWidth } = options;
  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;
  const numCols = columns.length;

  // Column spacing (+1 for right-side padding so last node isn&#x27;t clipped)
  const totalSpacing = numCols + 1;
  const spacing = Math.min(effectiveWidth / totalSpacing, 100);
  const radius = Math.min(spacing * 0.35, 20);

  // Vertical spacing
  const verticalSpacing = radius * 3;

  // Calculate height needed
  let maxVisibleChainLength = 0;
  for (const col of columns) {
    if (col.chain.length &gt; maxVisibleChainLength) {
      maxVisibleChainLength = col.chain.length;
    }
  }

  const topRowY = radius * 2.5;
  const chainStartY = topRowY + verticalSpacing;
  let canvasHeight;

  if (maxVisibleChainLength &gt; 0) {
    // Bottom of the deepest chain node circle
    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;
  } else {
    // No chains: bottom of top row circles
    canvasHeight = topRowY + radius;
  }

  if (showDepth) {
    // Depth labels: radius gap below circle + up to 2 lines of text
    canvasHeight += radius * 3;
  }

  canvasHeight += radius; // Bottom padding

  // Calculate canvas width with extra space for &quot;(if no breaks)&quot; label
  let canvasWidth = totalSpacing * spacing;

  // Check if we need to add space for the &quot;(if no breaks)&quot; label
  if (showDepth) {
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);
    const lastCol = columns[lastNonEllipsisIndex];
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const shouldShowLabel = lastCol.label !== &#x27;...&#x27;
      &amp;&amp; lastCol.chain.length &gt; 0
      &amp;&amp; Number(lastCol.label) === maxFloor;

    if (shouldShowLabel) {
      // Count horizontal moves to calculate label width
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      // Calculate actual label width for two-line format: &quot;X moves&quot; / &quot;(if no breaks)&quot;
      // We need to estimate based on character count since we don&#x27;t have canvas context here
      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7
      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace
      const firstLineWidth = firstLine.length * avgCharWidth;
      const secondLineWidth = secondLine.length * avgCharWidth;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Add label width + spacing + padding
      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;
    }
  }

  return {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  };
}

// Draw a circle with centered label
function drawCircleNode(ctx, x, y, radius, label, colors, fonts) {
  const { fill, stroke, text } = colors;
  const { fontFamily } = fonts;

  // Circle
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = text;
  ctx.textAlign = &#x27;center&#x27;;
  ctx.textBaseline = &#x27;middle&#x27;;

  // Font size based on label length
  let fontSize;
  if (label.length &lt;= 2) {
    fontSize = radius * 0.9;
  } else if (label.length === 3) {
    fontSize = radius * 0.75;
  } else {
    fontSize = radius * 0.6;
  }

  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.fillText(label, x, y);
}

// Draw an arrowhead at the given tip position and angle
function drawArrowhead(ctx, tipX, tipY, angle, radius) {
  const size = Math.max(3, radius * 0.3);
  ctx.save();
  ctx.translate(tipX, tipY);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size * 0.6);
  ctx.lineTo(-size, size * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// Draw a connection line between two nodes with optional arrowhead
function drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {
  const { stroke } = colors;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5;
  ctx.lineCap = &#x27;round&#x27;;

  // Calculate start and end points at circle boundary
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);

  const startX = x1 + (dx / dist) * radius;
  const startY = y1 + (dy / dist) * radius;
  const endX = x2 - (dx / dist) * radius;
  const endY = y2 - (dy / dist) * radius;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Draw arrowhead
  if (showArrows) {
    ctx.fillStyle = stroke;
    drawArrowhead(ctx, endX, endY, angle, radius);
  }
}

// Draw three vertical ellipsis dots
function drawVerticalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Draw three horizontal ellipsis dots
function drawHorizontalEllipsis(ctx, x, y, color, radius) {
  ctx.fillStyle = color;
  const dotRadius = Math.max(1.5, radius * 0.125);
  const gap = Math.max(5, radius * 0.4);

  for (let i = -1; i &lt;= 1; i++) {
    ctx.beginPath();
    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function draw(options) {
  const { canvas, api, width: containerWidth, props } = options;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  // Default props
  const {
    columns: rawColumns = [],
    showDepth = false,
    showArrows = true,
    minWidth = 0,
  } = props;

  if (!rawColumns || rawColumns.length === 0) {
    canvas.width = containerWidth;
    canvas.height = 100;
    ctx.fillStyle = api.getColor(&#x27;muted-foreground&#x27;);
    ctx.font = `14px ${api.getFont(&#x27;default&#x27;)}`;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;middle&#x27;;
    ctx.fillText(&#x27;No columns provided&#x27;, containerWidth / 2, 50);
    api.requestResize(100);
    return;
  }

  // Normalize columns
  const columns = normalizeColumns(rawColumns);

  // Compute layout
  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });
  const {
    spacing,
    radius,
    verticalSpacing,
    topRowY,
    chainStartY,
    canvasHeight,
    canvasWidth
  } = layout;

  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  // Colors (theme-aware)
  const foreground = api.getColor(&#x27;foreground&#x27;);
  const cardBg = api.getColor(&#x27;card&#x27;);
  const mutedBg = api.getColor(&#x27;muted&#x27;);
  const mutedFg = api.getColor(&#x27;muted-foreground&#x27;);
  const primaryColor = api.getColor(&#x27;primary&#x27;);

  const colors = {
    stroke: foreground,
    fill: cardBg,
    mutedFill: mutedBg,
    text: foreground,
    ellipsis: mutedFg,
    depth: primaryColor
  };

  const fonts = {
    fontFamily: api.getFont(&#x27;default&#x27;),
    monoFamily: api.getFont(&#x27;mono&#x27;)
  };

  // Track y-positions for each column&#x27;s chain
  const columnYPositions = columns.map(() =&gt; []);

  // Draw horizontal chain nodes
  for (let i = 0; i &lt; columns.length; i++) {
    const col = columns[i];
    const x = (i + 1) * spacing;
    const y = topRowY;

    if (col.label === &#x27;...&#x27;) {
      // Draw horizontal ellipsis dots instead of a circle
      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);
    } else {
      // First column uses muted background
      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;
      const nodeColors = { ...colors, fill: nodeFill };
      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);
    }

    // Draw horizontal connection to next column
    if (i &lt; columns.length - 1) {
      const nextX = (i + 2) * spacing;
      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);
    }

    // Track positions for vertical chains
    columnYPositions[i].push({ x, y });
  }

  // Draw vertical chains
  for (let colIdx = 0; colIdx &lt; columns.length; colIdx++) {
    const col = columns[colIdx];
    if (col.chain.length === 0) continue;

    const x = (colIdx + 1) * spacing;
    let currentY = chainStartY;

    for (let chainIdx = 0; chainIdx &lt; col.chain.length; chainIdx++) {
      const label = col.chain[chainIdx];
      const isEllipsis = label === &#x27;...&#x27;;

      if (isEllipsis) {
        // Draw vertical ellipsis dots centered where the circle would be
        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      } else {
        // Draw regular node
        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);
        columnYPositions[colIdx].push({ x, y: currentY });

        // Connection from previous
        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];
        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);

        currentY += verticalSpacing;
      }
    }
  }

  // Draw depth labels if enabled (for all columns except start and ellipsis)
  if (showDepth) {
    const fontSize = radius * 0.7;
    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
    ctx.fillStyle = colors.depth;
    ctx.textAlign = &#x27;center&#x27;;
    ctx.textBaseline = &#x27;top&#x27;;

    for (let colIdx = 1; colIdx &lt; columns.length; colIdx++) {
      const col = columns[colIdx];
      if (col.label === &#x27;...&#x27;) continue;
      const x = (colIdx + 1) * spacing;
      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];
      const depth = col.depth ?? (colIdx + col.fullChainLength);
      const depthY = lastPos.y + radius * 2;
      const word = depth === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const singleLine = `${depth} ${word}`;

      // Check if single line fits within column spacing
      const textWidth = ctx.measureText(singleLine).width;
      if (textWidth &lt; spacing * 0.95) {
        ctx.fillText(singleLine, x, depthY);
      } else {
        ctx.fillText(String(depth), x, depthY);
        ctx.fillText(word, x, depthY + fontSize * 1.2);
      }
    }
  }

  // Draw &quot;(if no breaks)&quot; label to the right of horizontal chain
  // Show when: last column AND has a chain AND its floor number equals max floor
  if (showDepth) {
    // Find last non-ellipsis column index
    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =&gt;
      col.label !== &#x27;...&#x27; ? i : idx, 0);

    // Find maximum floor number across all columns and chains
    const maxFloor = Math.max(
      ...columns.filter(c =&gt; c.label !== &#x27;...&#x27; &amp;&amp; !isNaN(c.label)).map(c =&gt; Number(c.label)),
      ...columns.flatMap(c =&gt; c.chain.filter(l =&gt; l !== &#x27;...&#x27; &amp;&amp; !isNaN(l)).map(Number))
    );

    const col = columns[lastNonEllipsisIndex];
    const shouldShowLabel = col.label !== &#x27;...&#x27;
      &amp;&amp; col.chain.length &gt; 0
      &amp;&amp; Number(col.label) === maxFloor;

    if (shouldShowLabel) {
      const x = (lastNonEllipsisIndex + 1) * spacing;
      const y = topRowY;
      const fontSize = radius * 0.7; // Match the depth label font size

      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;
      ctx.fillStyle = colors.depth;
      ctx.textAlign = &#x27;center&#x27;;
      ctx.textBaseline = &#x27;middle&#x27;;

      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)
      let lastEllipsisIndex = -1;
      for (let i = columns.length - 1; i &gt;= 0; i--) {
        if (columns[i] === &#x27;...&#x27; || columns[i].label === &#x27;...&#x27;) {
          lastEllipsisIndex = i;
          break;
        }
      }

      // Count non-start columns from after the last ellipsis to the end
      let horizontalMoves = 0;
      for (let i = Math.max(1, lastEllipsisIndex + 1); i &lt;= lastNonEllipsisIndex; i++) {
        if (columns[i] !== &#x27;...&#x27; &amp;&amp; columns[i].label !== &#x27;...&#x27;) {
          horizontalMoves++;
        }
      }

      const word = horizontalMoves === 1 ? &#x27;move&#x27; : &#x27;moves&#x27;;
      const firstLine = `${horizontalMoves} ${word}`;
      const secondLine = &#x27;(if no breaks)&#x27;;

      // Measure both lines to find the widest one
      const firstLineWidth = ctx.measureText(firstLine).width;
      const secondLineWidth = ctx.measureText(secondLine).width;
      const maxWidth = Math.max(firstLineWidth, secondLineWidth);

      // Position label so it starts after the circle with spacing, centered on maxWidth
      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;
      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);
      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);
    }
  }

  // Resize iframe to fit canvas
  api.requestResize(canvasHeight);
}&lt;/script&gt;

  &lt;!-- Execution script --&gt;
  &lt;script&gt;
    // Execute mount() if defined, passing props
    if (typeof executeMountIfExists === &#x27;function&#x27;) {
      executeMountIfExists(window.__COMPONENT_PROPS__);
    }

    // Execute draw() if defined, passing props
    if (typeof executeDrawIfExists === &#x27;function&#x27;) {
      executeDrawIfExists(window.__COMPONENT_PROPS__);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" style="width:100%;min-width:800px;height:300px" title="Maximum building height with 14 drops: 105 floors"></iframe></div><div class="content-block note-block note-note" data-type="note" data-note-type="note"><div class="note-header note-note-header">An Extension</div><div class="note-content markdown-content prose max-w-none px-4 py-4 space-y-4"><p>Now that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:</p><ol>
<li>For 2 devices, what is the minimum worst-case number of drops for a building of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation>n</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> storeys?</li>
<li>For 2 devices, what is the maximum building height coverable with at most <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation>k</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span> drops in the worst case?</li>
<li>For <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation>d</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">d</span></span></span></span> devices and an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation>n</annotation></semantics></math></span><span class="katex-html"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span>-storey building, what is the minimum worst-case number of drops?</li>
</ol></div></div></div></details>
<div class="inline-component-definition" style="display:none"></div></div><div class="flex justify-center my-8"><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><section class="mt-12"><h2 class="mb-6 text-xl font-bold text-foreground lg:text-2xl">Try These Next</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/chain-link-2" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Chain Link 2</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">An apprentice is working for you, the village’s master blacksmith, for 21 days. For payment, you have agreed to give him a gold chain with 21 links, one link...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/two-bullet-russian-roulette" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Two-Bullet Russian Roulette</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">After offending the toughest guy, Big Billy, at the saloon, he challenges you to a game of Russian Roulette. He takes out a revolver with 6 chambers and loads...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/watermelons-drying-in-the-sun" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Watermelons Drying in The Sun</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">A farmer is proud of his newest feat: growing a 120 kg watermelon that he wants to enter in the farming contest next week. Using a special sensor, he detects...</p></div></a></div></section></div></main></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":false,"unstable_splitRouteModules":false,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-25fb394a.js";
import * as route0 from "/assets/root-BjuwspyJ.js";
import * as route1 from "/assets/puzzle-detail-ByHrUMNS.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/puzzle-detail":route1};

import("/assets/entry.client-BQEHofJp.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_255\":-5,\"_256\":-5},\"loaderData\",{\"_3\":4},\"routes/puzzle-detail\",{\"_5\":6,\"_7\":8,\"_9\":10},\"status\",\"success\",\"slug\",\"egg-dropping\",\"puzzle\",{\"_7\":8,\"_11\":12,\"_37\":38,\"_39\":40,\"_41\":42,\"_247\":248},\"metadata\",{\"_13\":14,\"_15\":16,\"_17\":18,\"_19\":20,\"_22\":23,\"_26\":27,\"_29\":30,\"_31\":30,\"_32\":33,\"_34\":35,\"_36\":35},\"id\",\"puzzle-39\",\"title\",\"Egg Dropping\",\"questionPreview\",\"You’ve devised an egg-protection device for a school project. With two prototypes and a 100-storey building, what’s the fewest drops to find the break floor?\\n\",\"concepts\",[21],\"optimisation\",\"difficulty\",{\"_19\":24,\"_25\":24},\"medium\",\"reasoning\",\"tags\",[28],\"has-solution\",\"dateCreated\",\"2026-02-02\",\"lastUpdated\",\"credit\",\"Classic puzzle.\\nQuestion and solution by Puzzlestone Peak.\\n\",\"preview\",\"For a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when...\",\"websitePreview\",\"content\",\"\u003cp\u003eFor a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.\u003c/p\u003e\\n\u003cp\u003eNear your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.\u003c/p\u003e\\n\u003cp\u003eWhat is the minimum number of drops you’d ever need in the \u003cstrong\u003eworst case\u003c/strong\u003e to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.\u003c/p\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint 1\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eExperiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint 2\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eIf you only had 1 device, you cannot do better than 100 drops in the worst case. Why?\u003c/p\u003e\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eLet’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.\u003c/p\u003e\u003cp\u003eThis means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\u003cp\u003eNow consider what happens when you have 2 devices.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint 3\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eIf your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?\u003c/p\u003e\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eYou would have to do 50 drops in the worst case scenario.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCase 1\u003c/strong\u003e: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCase 2\u003c/strong\u003e: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003e\u003cstrong\u003eAnswer\u003c/strong\u003e: 14 drops.\u003c/p\u003e\u003cp\u003eLet’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?\u003c/p\u003e\u003cp\u003eFirst, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eFirst drop: Drop from floor 3.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 1, then 2. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, drop from floor 6.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 4, then 5. Worst case: 4 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, then we know the device survives all 6 floors.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\u003cp\u003eThis gives us a worst case of 4 moves.\u003c/p\u003e\u003cp\u003eLet’s come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"0\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWhen the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we’re left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"1\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let’s try a different strategy:\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eFirst drop: Drop from floor 2.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 1. Worst case: 2 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, drop from floor 4.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 3. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, test floor 6.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 5. Worst case: 4 moves\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, then we know the device survives all 6 floors.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"2\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eHmm, we’re still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we’ve found the optimal number of drops?\u003c/p\u003e\u003cp\u003eNo! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2) and (Start → 3 → 6 without breaking). In version 2, we have (Start → 2 → 1), (Start → 2 → 4 → 3), and (Start → 2 → 4 → 6 without breaking). If we could make these longer in order to shorten the worst-case path, we’ll find a better solution. And in fact, we can!\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eFirst drop: Drop from floor 3.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 1, then 2. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, drop from floor 5.\\n\u003cul\u003e\\n\u003cli\u003eIf it breaks, test floor 4. Worst case: 3 moves.\u003c/li\u003e\\n\u003cli\u003eIf it doesn’t break, test floor 6. Worst case: 3 moves.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"3\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNo matter which path we take, we’ll always end up with 3 moves in the worst case.\u003c/p\u003e\u003cp\u003eWith this visualisation in mind, let’s explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"4\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eOof, that’s rough. It seems like we’re not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.\u003c/p\u003e\u003cp\u003eHow about steps of 10? This time, we’ll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"5\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIn the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let’s lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmn\u003e14\u003c/mn\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e13\u003c/mn\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e27\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation\u003e14 + 13 = 27\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e14\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mbin\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e13\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mrel\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e27\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e. Then the following drop should be \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmn\u003e27\u003c/mn\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmn\u003e12\u003c/mn\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e39\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation\u003e27 + 12 = 39\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e27\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mbin\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e12\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mrel\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e39\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e. Continuing this way, we get a chart of:\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"6\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIn the worst case scenario, we have 14 moves, and we can’t do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"7\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cdiv class=\\\"content-block note-block note-note\\\" data-type=\\\"note\\\" data-note-type=\\\"note\\\"\u003e\u003cdiv class=\\\"note-header note-note-header\\\"\u003eAn Extension\u003c/div\u003e\u003cdiv class=\\\"note-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eNow that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:\u003c/p\u003e\u003col\u003e\\n\u003cli\u003eFor 2 devices, what is the minimum worst-case number of drops for a building of \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e storeys?\u003c/li\u003e\\n\u003cli\u003eFor 2 devices, what is the maximum building height coverable with at most \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ek\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003ek\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\"\u003ek\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e drops in the worst case?\u003c/li\u003e\\n\u003cli\u003eFor \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ed\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003ed\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003ed\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e devices and an \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e-storey building, what is the minimum worst-case number of drops?\u003c/li\u003e\\n\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\",\"rawContent\",\"\\nFor a school project, you’ve devised an egg-protection device — a little contraption that wraps around an egg and is supposed to keep it from breaking when dropped from a height. You’ve built two prototypes and now you need to figure out just how effective they are.\\n\\nNear your school is a 100-storey building. The device might fail from as low as the first floor, or it might protect the egg all the way from the 100th — you have no idea. You need to find the “break floor” — the lowest floor from which a protected egg will still break on impact. Note that the device may survive even a drop from the 100th floor, in which case there is no break floor.\\n\\nWhat is the minimum number of drops you’d ever need in the **worst case** to determine the break floor? You’re allowed to break both eggs, as long as you can identify the correct floor afterwards.\\n\\n\\n:::hint[Hint 1]\\nExperiment with simpler versions of the problem. Perhaps you can try a shorter building, or you can try having only 1 device instead of 2.\\n:::\\n\\n::::hint[Hint 2]\\nIf you only had 1 device, you cannot do better than 100 drops in the worst case. Why?\\n\\n:::solution\\nLet’s start from the beginning. If you dropped the device from the 2nd floor and it broke, you know the break floor is either 1 or 2, but you don’t have any devices left to test. The same goes for any floor above the 2nd floor.\\n\\nThis means you have to test the 1st floor, then the 2nd floor, and so on; all the way up to the 100th floor. In the worst case, the device doesn’t break at all, and you’d have to test the drop from all 100 floors.\\n:::\\n\\nNow consider what happens when you have 2 devices.\\n::::\\n\\n::::hint[Hint 3]\\nIf your first move is to drop from the 50th floor, what’s the minimum number of drops you’d have to do in the worst case scenario?\\n\\n:::solution\\nYou would have to do 50 drops in the worst case scenario.\\n\\n**Case 1**: If the device breaks at the 50th floor, we’re now left with 1 device to test the remaining floors 1 to 49. That’s a total of 49 drops + the first drop for a total of 50.\\n\\n**Case 2**: If the device doesn’t break at the 50th floor, we can drop the device once more on any floor in the middle, so let’s go with the 75th floor. If it breaks, we can test floors 51 to 74 for a total of 26 drops in the worst case. If it doesn’t break, we can still test the remaining 25 floors with a naive brute force solution and still come up with 27 drops in total. Either way, you cannot do as bad as the 50 drops required in case 1.\\n:::\\n::::\\n\\n::::solution\\n**Answer**: 14 drops.\\n\\nLet’s work our way up to a solution. As we’ve seen from the hints, once the device has broken, you will need to brute force ALL the remaining floors in the worst case scenario. But how do we optimise this then?\\n\\nFirst, let’s start with a simpler version of the problem with 6 floors and 2 devices. We’ll start with a naive solution for now:\\n\\n- First drop: Drop from floor 3.\\n    - If it breaks, test floor 1, then 2. Worst case: 3 moves.\\n    - If it doesn’t break, drop from floor 6.\\n        - If it breaks, test floor 4, then 5. Worst case: 4 moves.\\n        - If it doesn’t break, then we know the device survives all 6 floors.\\n\\nThis gives us a worst case of 4 moves.\\n\\nLet’s come up with a way to visualise this. We indicate the drops with device 1 on a horizontal line. We start from the left point, and each step to the right indicates a drop.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Simple strategy: drop from floor 3, then floor 6\\\"\\nariaLabel: Three nodes in a horizontal chain — start, floor 3, floor 6\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - \\\"3\\\"\\n    - \\\"6\\\"\\n```\\n:::\\n\\nWhen the device breaks on a specific floor, we can no longer make a horizontal step, so we must now take vertical steps downward. From hint 2, we know that once we’re left with 1 device, we must test all the floors sequentially. If the device breaks at floor 3, we need to test floors 1 and 2. If the device breaks at floor 6, we need to test floors 4 and 5. This gives us the following diagram:\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: floors 3 and 6 with fallback chains\\\"\\nariaLabel: Strategy tree with start node, floor 3 with chain 1 and 2 below, floor 6 with chain 4 and 5 below\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"3\\\"\\n      chain: [1, 2]\\n    - label: \\\"6\\\"\\n      chain: [4, 5]\\n  showDepth: true\\n  minWidth: 280\\n```\\n:::\\n\\nWe can see from this diagram that we have a worst-case of 4 moves (Start → 3 → 6 → 4 → 5). Can we do better? Let’s try a different strategy:\\n\\n- First drop: Drop from floor 2.\\n    - If it breaks, test floor 1. Worst case: 2 moves.\\n    - If it doesn’t break, drop from floor 4.\\n        - If it breaks, test floor 3. Worst case: 3 moves.\\n        - If it doesn’t break, test floor 6.\\n            - If it breaks, test floor 5. Worst case: 4 moves\\n            - If it doesn’t break, then we know the device survives all 6 floors.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: floors 2, 4, and 6 with single fallbacks\\\"\\nariaLabel: Strategy tree with start, floor 2 dropping to 1, floor 4 dropping to 3, floor 6 dropping to 5\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"2\\\"\\n      chain: [1]\\n    - label: \\\"4\\\"\\n      chain: [3]\\n    - label: \\\"6\\\"\\n      chain: [5]\\n  showDepth: true\\n  minWidth: 320\\n```\\n:::\\n\\nHmm, we’re still stuck with a worst-case of 4 moves (Start → 2 → 4 → 6 → 5). But does that mean we’ve found the optimal number of drops?\\n\\nNo! Notice how in both versions of the diagram, we have short paths that terminate early. In version 1, we have (Start → 3 → 1 → 2) and (Start → 3 → 6 without breaking). In version 2, we have (Start → 2 → 1), (Start → 2 → 4 → 3), and (Start → 2 → 4 → 6 without breaking). If we could make these longer in order to shorten the worst-case path, we’ll find a better solution. And in fact, we can!\\n\\n- First drop: Drop from floor 3.\\n    - If it breaks, test floor 1, then 2. Worst case: 3 moves.\\n    - If it doesn’t break, drop from floor 5.\\n        - If it breaks, test floor 4. Worst case: 3 moves.\\n        - If it doesn’t break, test floor 6. Worst case: 3 moves.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Optimal strategy tree for 6 floors\\\"\\nariaLabel: Strategy tree with start, floor 3 dropping to 2 then 1, floor 5 dropping to 4, floor 6 with no chain\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"3\\\"\\n      chain: [1, 2]\\n    - label: \\\"5\\\"\\n      chain: [4]\\n    - \\\"6\\\"\\n  showDepth: true\\n```\\n:::\\n\\nNo matter which path we take, we’ll always end up with 3 moves in the worst case.\\n\\nWith this visualisation in mind, let’s explore some solutions for the 100-storey version of the puzzle. In hint 3, we offered a naive solution of dropping from the 50th floor. Visualising it with our new diagram, it looks like this:\\n\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: binary split from floor 50\\\"\\nariaLabel: Strategy tree showing drops from floors 50, 75, and 100 with long fallback chains\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"50\\\"\\n      chain: [1, 2, \\\"...\\\", \\\"...\\\", \\\"...\\\", \\\"...\\\", 49]\\n    - label: \\\"75\\\"\\n      chain: [51, 52, \\\"...\\\", 74]\\n    - label: \\\"100\\\"\\n      chain: [76, 77, \\\"...\\\", 98, 99]\\n  showDepth: true\\n  minWidth: 320\\n```\\n:::\\n\\nOof, that’s rough. It seems like we’re not taking proper advantage of the first device (the rightward movement on the diagram). So instead of making such huge jumps with the first device, we should instead move it in smaller steps.\\n\\nHow about steps of 10? This time, we’ll try dropping the first device from floor 10, then 20, then 30, and so on. At the first floor that it breaks on, we will test the remaining floors in between the last 2 drops. For example, if the first device breaks on floor 60, then we will drop the second device from floor 51, 52, ..., 59. Our diagram now looks like this:\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Strategy tree: steps of 10\\\"\\nariaLabel: Strategy tree showing drops from floors 10, 20, 30 with full fallback chains of 9 floors each\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"10\\\"\\n      chain: { from: 1, to: 9 }\\n    - label: \\\"20\\\"\\n      chain: { from: 11, to: 19 }\\n    - label: \\\"30\\\"\\n      chain: { from: 21, to: 29 }\\n    - \\\"...\\\"\\n    - label: \\\"80\\\"\\n      chain: { from: 71, to: 79 }\\n      depth: 17\\n    - label: \\\"90\\\"\\n      chain: { from: 81, to: 89 }\\n      depth: 18\\n    - label: \\\"100\\\"\\n      chain: { from: 91, to: 99 }\\n      depth: 19\\n  showDepth: true\\n  minWidth: 800\\n```\\n:::\\n\\nIn the worst case scenario, we have 19 moves (Start → 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80 → 90 → 100 → 91 → 92 → 93 → 94 → 95 → 96 → 97 → 98 → 99). But notice how the shorter chains have only 10 moves, 11 moves, and so on? Let’s lengthen them. Instead of having the first drop at 10, we can have the first drop at 14 (a jump of 14). Then our next jump should be $14 + 13 = 27$. Then the following drop should be $27 + 12 = 39$. Continuing this way, we get a chart of:\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Optimal strategy tree for 100 floors\\\"\\nariaLabel: Strategy tree with decreasing jumps starting at floor 14, covering all 100 floors in at most 14 drops\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"14\\\"\\n      chain: { from: 1, to: 13 }\\n    - label: \\\"27\\\"\\n      chain: { from: 15, to: 26 }\\n    - label: \\\"39\\\"\\n      chain: { from: 28, to: 38 }\\n    - label: \\\"50\\\"\\n      chain: { from: 40, to: 49 }\\n    - label: \\\"60\\\"\\n      chain: { from: 51, to: 59 }\\n    - label: \\\"69\\\"\\n      chain: { from: 61, to: 68 }\\n    - label: \\\"77\\\"\\n      chain: { from: 70, to: 76 }\\n    - label: \\\"84\\\"\\n      chain: { from: 78, to: 83 }\\n    - label: \\\"90\\\"\\n      chain: { from: 85, to: 89 }\\n    - label: \\\"95\\\"\\n      chain: { from: 91, to: 94 }\\n    - label: \\\"99\\\"\\n      chain: { from: 96, to: 98 }\\n    - \\\"100\\\"\\n  showDepth: true\\n  minWidth: 1100\\n```\\n:::\\n\\nIn the worst case scenario, we have 14 moves, and we can’t do any better than this. However, through this diagram, we see that for a maximum of 14 moves, this strategy works up to a maximum building height of 105 storeys.\\n\\n:::dynamic\\n```yaml\\nuse: '#strategy-tree'\\ntitle: \\\"Maximum building height with 14 drops: 105 floors\\\"\\nariaLabel: Strategy tree for 14 drops covering up to 105 floors, with every path exactly 14 steps\\nprops:\\n  columns:\\n    - \\\"S\\\"\\n    - label: \\\"14\\\"\\n      chain: { from: 1, to: 13 }\\n    - label: \\\"27\\\"\\n      chain: { from: 15, to: 26 }\\n    - label: \\\"39\\\"\\n      chain: { from: 28, to: 38 }\\n    - label: \\\"50\\\"\\n      chain: { from: 40, to: 49 }\\n    - label: \\\"60\\\"\\n      chain: { from: 51, to: 59 }\\n    - label: \\\"69\\\"\\n      chain: { from: 61, to: 68 }\\n    - label: \\\"77\\\"\\n      chain: { from: 70, to: 76 }\\n    - label: \\\"84\\\"\\n      chain: { from: 78, to: 83 }\\n    - label: \\\"90\\\"\\n      chain: { from: 85, to: 89 }\\n    - label: \\\"95\\\"\\n      chain: { from: 91, to: 94 }\\n    - label: \\\"99\\\"\\n      chain: { from: 96, to: 98 }\\n    - label: \\\"102\\\"\\n      chain: [100, 101]\\n    - label: \\\"104\\\"\\n      chain: [103]\\n    - \\\"105\\\"\\n  showDepth: true\\n  minWidth: 800\\n```\\n:::\\n\\n:::note[An Extension]\\nNow that you’ve found the optimal strategy for 2 devices and 100 storeys, try to generalise:\\n\\n1. For 2 devices, what is the minimum worst-case number of drops for a building of $n$ storeys?\\n2. For 2 devices, what is the maximum building height coverable with at most $k$ drops in the worst case?\\n3. For $d$ devices and an $n$-storey building, what is the minimum worst-case number of drops?\\n:::\\n\\n::::\\n\\n\\n:::component[strategy-tree]\\n```yaml\\nmode: canvas\\ntitle: Strategy tree diagram\\nariaLabel: Horizontal chain of decision nodes with vertical fallback chains descending below\\n```\\n\\n```js\\n// Normalize columns: expand ranges, compute full chain length\\nfunction normalizeColumns(rawColumns) {\\n  return rawColumns.map(col =\u003e {\\n    // Handle shorthand: plain string → { label: \\\"X\\\" }\\n    if (typeof col === 'string') {\\n      return { label: col, chain: [], fullChainLength: 0, depth: null };\\n    }\\n\\n    const { label, chain, depth } = col;\\n    let chainLabels = [];\\n    let fullLength = 0;\\n\\n    if (!chain) {\\n      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };\\n    }\\n\\n    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]\\n    if (typeof chain === 'object' \u0026\u0026 !Array.isArray(chain)) {\\n      const { from, to } = chain;\\n      fullLength = to - from + 1;\\n      for (let i = from; i \u003c= to; i++) {\\n        chainLabels.push(String(i));\\n      }\\n    } else {\\n      chainLabels = chain.map(String);\\n      // Derive full length from first and last numeric items\\n      const nums = chainLabels.filter(l =\u003e l !== '...').map(Number);\\n      if (nums.length \u003e= 2) {\\n        fullLength = nums[nums.length - 1] - nums[0] + 1;\\n      } else {\\n        fullLength = nums.length;\\n      }\\n    }\\n\\n    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };\\n  });\\n}\\n\\n// Compute layout parameters based on columns and container width\\nfunction computeLayout(columns, containerWidth, options) {\\n  const { showDepth, minWidth } = options;\\n  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;\\n  const numCols = columns.length;\\n\\n  // Column spacing (+1 for right-side padding so last node isn't clipped)\\n  const totalSpacing = numCols + 1;\\n  const spacing = Math.min(effectiveWidth / totalSpacing, 100);\\n  const radius = Math.min(spacing * 0.35, 20);\\n\\n  // Vertical spacing\\n  const verticalSpacing = radius * 3;\\n\\n  // Calculate height needed\\n  let maxVisibleChainLength = 0;\\n  for (const col of columns) {\\n    if (col.chain.length \u003e maxVisibleChainLength) {\\n      maxVisibleChainLength = col.chain.length;\\n    }\\n  }\\n\\n  const topRowY = radius * 2.5;\\n  const chainStartY = topRowY + verticalSpacing;\\n  let canvasHeight;\\n\\n  if (maxVisibleChainLength \u003e 0) {\\n    // Bottom of the deepest chain node circle\\n    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;\\n  } else {\\n    // No chains: bottom of top row circles\\n    canvasHeight = topRowY + radius;\\n  }\\n\\n  if (showDepth) {\\n    // Depth labels: radius gap below circle + up to 2 lines of text\\n    canvasHeight += radius * 3;\\n  }\\n\\n  canvasHeight += radius; // Bottom padding\\n\\n  // Calculate canvas width with extra space for \\\"(if no breaks)\\\" label\\n  let canvasWidth = totalSpacing * spacing;\\n\\n  // Check if we need to add space for the \\\"(if no breaks)\\\" label\\n  if (showDepth) {\\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =\u003e\\n      col.label !== '...' ? i : idx, 0);\\n    const lastCol = columns[lastNonEllipsisIndex];\\n    const maxFloor = Math.max(\\n      ...columns.filter(c =\u003e c.label !== '...' \u0026\u0026 !isNaN(c.label)).map(c =\u003e Number(c.label)),\\n      ...columns.flatMap(c =\u003e c.chain.filter(l =\u003e l !== '...' \u0026\u0026 !isNaN(l)).map(Number))\\n    );\\n\\n    const shouldShowLabel = lastCol.label !== '...'\\n      \u0026\u0026 lastCol.chain.length \u003e 0\\n      \u0026\u0026 Number(lastCol.label) === maxFloor;\\n\\n    if (shouldShowLabel) {\\n      // Count horizontal moves to calculate label width\\n      let lastEllipsisIndex = -1;\\n      for (let i = columns.length - 1; i \u003e= 0; i--) {\\n        if (columns[i] === '...' || columns[i].label === '...') {\\n          lastEllipsisIndex = i;\\n          break;\\n        }\\n      }\\n\\n      let horizontalMoves = 0;\\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i \u003c= lastNonEllipsisIndex; i++) {\\n        if (columns[i] !== '...' \u0026\u0026 columns[i].label !== '...') {\\n          horizontalMoves++;\\n        }\\n      }\\n\\n      // Calculate actual label width for two-line format: \\\"X moves\\\" / \\\"(if no breaks)\\\"\\n      // We need to estimate based on character count since we don't have canvas context here\\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\\n      const firstLine = `${horizontalMoves} ${word}`;\\n      const secondLine = '(if no breaks)';\\n\\n      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7\\n      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace\\n      const firstLineWidth = firstLine.length * avgCharWidth;\\n      const secondLineWidth = secondLine.length * avgCharWidth;\\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\\n\\n      // Add label width + spacing + padding\\n      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;\\n    }\\n  }\\n\\n  return {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth\\n  };\\n}\\n\\n// Draw a circle with centered label\\nfunction drawCircleNode(ctx, x, y, radius, label, colors, fonts) {\\n  const { fill, stroke, text } = colors;\\n  const { fontFamily } = fonts;\\n\\n  // Circle\\n  ctx.beginPath();\\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\\n  ctx.fillStyle = fill;\\n  ctx.fill();\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.stroke();\\n\\n  // Label\\n  ctx.fillStyle = text;\\n  ctx.textAlign = 'center';\\n  ctx.textBaseline = 'middle';\\n\\n  // Font size based on label length\\n  let fontSize;\\n  if (label.length \u003c= 2) {\\n    fontSize = radius * 0.9;\\n  } else if (label.length === 3) {\\n    fontSize = radius * 0.75;\\n  } else {\\n    fontSize = radius * 0.6;\\n  }\\n\\n  ctx.font = `bold ${fontSize}px ${fontFamily}`;\\n  ctx.fillText(label, x, y);\\n}\\n\\n// Draw an arrowhead at the given tip position and angle\\nfunction drawArrowhead(ctx, tipX, tipY, angle, radius) {\\n  const size = Math.max(3, radius * 0.3);\\n  ctx.save();\\n  ctx.translate(tipX, tipY);\\n  ctx.rotate(angle);\\n  ctx.beginPath();\\n  ctx.moveTo(0, 0);\\n  ctx.lineTo(-size, -size * 0.6);\\n  ctx.lineTo(-size, size * 0.6);\\n  ctx.closePath();\\n  ctx.fill();\\n  ctx.restore();\\n}\\n\\n// Draw a connection line between two nodes with optional arrowhead\\nfunction drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {\\n  const { stroke } = colors;\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.lineCap = 'round';\\n\\n  // Calculate start and end points at circle boundary\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  const dist = Math.sqrt(dx * dx + dy * dy);\\n  const angle = Math.atan2(dy, dx);\\n\\n  const startX = x1 + (dx / dist) * radius;\\n  const startY = y1 + (dy / dist) * radius;\\n  const endX = x2 - (dx / dist) * radius;\\n  const endY = y2 - (dy / dist) * radius;\\n\\n  // Draw line\\n  ctx.beginPath();\\n  ctx.moveTo(startX, startY);\\n  ctx.lineTo(endX, endY);\\n  ctx.stroke();\\n\\n  // Draw arrowhead\\n  if (showArrows) {\\n    ctx.fillStyle = stroke;\\n    drawArrowhead(ctx, endX, endY, angle, radius);\\n  }\\n}\\n\\n// Draw three vertical ellipsis dots\\nfunction drawVerticalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\n// Draw three horizontal ellipsis dots\\nfunction drawHorizontalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nfunction draw(options) {\\n  const { canvas, api, width: containerWidth, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Default props\\n  const {\\n    columns: rawColumns = [],\\n    showDepth = false,\\n    showArrows = true,\\n    minWidth = 0,\\n  } = props;\\n\\n  if (!rawColumns || rawColumns.length === 0) {\\n    canvas.width = containerWidth;\\n    canvas.height = 100;\\n    ctx.fillStyle = api.getColor('muted-foreground');\\n    ctx.font = `14px ${api.getFont('default')}`;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'middle';\\n    ctx.fillText('No columns provided', containerWidth / 2, 50);\\n    api.requestResize(100);\\n    return;\\n  }\\n\\n  // Normalize columns\\n  const columns = normalizeColumns(rawColumns);\\n\\n  // Compute layout\\n  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });\\n  const {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth\\n  } = layout;\\n\\n  canvas.width = canvasWidth;\\n  canvas.height = canvasHeight;\\n\\n  // Colors (theme-aware)\\n  const foreground = api.getColor('foreground');\\n  const cardBg = api.getColor('card');\\n  const mutedBg = api.getColor('muted');\\n  const mutedFg = api.getColor('muted-foreground');\\n  const primaryColor = api.getColor('primary');\\n\\n  const colors = {\\n    stroke: foreground,\\n    fill: cardBg,\\n    mutedFill: mutedBg,\\n    text: foreground,\\n    ellipsis: mutedFg,\\n    depth: primaryColor\\n  };\\n\\n  const fonts = {\\n    fontFamily: api.getFont('default'),\\n    monoFamily: api.getFont('mono')\\n  };\\n\\n  // Track y-positions for each column's chain\\n  const columnYPositions = columns.map(() =\u003e []);\\n\\n  // Draw horizontal chain nodes\\n  for (let i = 0; i \u003c columns.length; i++) {\\n    const col = columns[i];\\n    const x = (i + 1) * spacing;\\n    const y = topRowY;\\n\\n    if (col.label === '...') {\\n      // Draw horizontal ellipsis dots instead of a circle\\n      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);\\n    } else {\\n      // First column uses muted background\\n      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;\\n      const nodeColors = { ...colors, fill: nodeFill };\\n      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);\\n    }\\n\\n    // Draw horizontal connection to next column\\n    if (i \u003c columns.length - 1) {\\n      const nextX = (i + 2) * spacing;\\n      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);\\n    }\\n\\n    // Track positions for vertical chains\\n    columnYPositions[i].push({ x, y });\\n  }\\n\\n  // Draw vertical chains\\n  for (let colIdx = 0; colIdx \u003c columns.length; colIdx++) {\\n    const col = columns[colIdx];\\n    if (col.chain.length === 0) continue;\\n\\n    const x = (colIdx + 1) * spacing;\\n    let currentY = chainStartY;\\n\\n    for (let chainIdx = 0; chainIdx \u003c col.chain.length; chainIdx++) {\\n      const label = col.chain[chainIdx];\\n      const isEllipsis = label === '...';\\n\\n      if (isEllipsis) {\\n        // Draw vertical ellipsis dots centered where the circle would be\\n        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      } else {\\n        // Draw regular node\\n        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      }\\n    }\\n  }\\n\\n  // Draw depth labels if enabled (for all columns except start and ellipsis)\\n  if (showDepth) {\\n    const fontSize = radius * 0.7;\\n    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\\n    ctx.fillStyle = colors.depth;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'top';\\n\\n    for (let colIdx = 1; colIdx \u003c columns.length; colIdx++) {\\n      const col = columns[colIdx];\\n      if (col.label === '...') continue;\\n      const x = (colIdx + 1) * spacing;\\n      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];\\n      const depth = col.depth ?? (colIdx + col.fullChainLength);\\n      const depthY = lastPos.y + radius * 2;\\n      const word = depth === 1 ? 'move' : 'moves';\\n      const singleLine = `${depth} ${word}`;\\n\\n      // Check if single line fits within column spacing\\n      const textWidth = ctx.measureText(singleLine).width;\\n      if (textWidth \u003c spacing * 0.95) {\\n        ctx.fillText(singleLine, x, depthY);\\n      } else {\\n        ctx.fillText(String(depth), x, depthY);\\n        ctx.fillText(word, x, depthY + fontSize * 1.2);\\n      }\\n    }\\n  }\\n\\n  // Draw \\\"(if no breaks)\\\" label to the right of horizontal chain\\n  // Show when: last column AND has a chain AND its floor number equals max floor\\n  if (showDepth) {\\n    // Find last non-ellipsis column index\\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =\u003e\\n      col.label !== '...' ? i : idx, 0);\\n\\n    // Find maximum floor number across all columns and chains\\n    const maxFloor = Math.max(\\n      ...columns.filter(c =\u003e c.label !== '...' \u0026\u0026 !isNaN(c.label)).map(c =\u003e Number(c.label)),\\n      ...columns.flatMap(c =\u003e c.chain.filter(l =\u003e l !== '...' \u0026\u0026 !isNaN(l)).map(Number))\\n    );\\n\\n    const col = columns[lastNonEllipsisIndex];\\n    const shouldShowLabel = col.label !== '...'\\n      \u0026\u0026 col.chain.length \u003e 0\\n      \u0026\u0026 Number(col.label) === maxFloor;\\n\\n    if (shouldShowLabel) {\\n      const x = (lastNonEllipsisIndex + 1) * spacing;\\n      const y = topRowY;\\n      const fontSize = radius * 0.7; // Match the depth label font size\\n\\n      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\\n      ctx.fillStyle = colors.depth;\\n      ctx.textAlign = 'center';\\n      ctx.textBaseline = 'middle';\\n\\n      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)\\n      let lastEllipsisIndex = -1;\\n      for (let i = columns.length - 1; i \u003e= 0; i--) {\\n        if (columns[i] === '...' || columns[i].label === '...') {\\n          lastEllipsisIndex = i;\\n          break;\\n        }\\n      }\\n\\n      // Count non-start columns from after the last ellipsis to the end\\n      let horizontalMoves = 0;\\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i \u003c= lastNonEllipsisIndex; i++) {\\n        if (columns[i] !== '...' \u0026\u0026 columns[i].label !== '...') {\\n          horizontalMoves++;\\n        }\\n      }\\n\\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\\n      const firstLine = `${horizontalMoves} ${word}`;\\n      const secondLine = '(if no breaks)';\\n\\n      // Measure both lines to find the widest one\\n      const firstLineWidth = ctx.measureText(firstLine).width;\\n      const secondLineWidth = ctx.measureText(secondLine).width;\\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\\n\\n      // Position label so it starts after the circle with spacing, centered on maxWidth\\n      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;\\n      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);\\n      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);\\n    }\\n  }\\n\\n  // Resize iframe to fit canvas\\n  api.requestResize(canvasHeight);\\n}\\n```\\n:::\",\"dynamicBlocks\",[43,60,78,92,101,123,160,211],{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":51,\"_15\":57,\"_58\":59},\"type\",\"dynamic\",\"mode\",\"component\",\"componentId\",\"#strategy-tree\",\"props\",{\"_52\":53},\"columns\",[54,55,56],\"S\",\"3\",\"6\",\"Simple strategy: drop from floor 3, then floor 6\",\"sourceFile\",\"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/optimisation/egg-dropping.md\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":61,\"_15\":77,\"_58\":59},{\"_52\":62,\"_73\":74,\"_75\":76},[54,63,69],{\"_64\":55,\"_65\":66},\"label\",\"chain\",[67,68],1,2,{\"_64\":56,\"_65\":70},[71,72],4,5,\"showDepth\",true,\"minWidth\",280,\"Strategy tree: floors 3 and 6 with fallback chains\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":79,\"_15\":91,\"_58\":59},{\"_52\":80,\"_73\":74,\"_75\":90},[54,81,84,88],{\"_64\":82,\"_65\":83},\"2\",[67],{\"_64\":85,\"_65\":86},\"4\",[87],3,{\"_64\":56,\"_65\":89},[72],320,\"Strategy tree: floors 2, 4, and 6 with single fallbacks\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":93,\"_15\":100,\"_58\":59},{\"_52\":94,\"_73\":74},[54,95,97,56],{\"_64\":55,\"_65\":96},[67,68],{\"_64\":98,\"_65\":99},\"5\",[71],\"Optimal strategy tree for 6 floors\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":102,\"_15\":122,\"_58\":59},{\"_52\":103,\"_73\":74,\"_75\":90},[54,104,109,115],{\"_64\":105,\"_65\":106},\"50\",[67,68,107,107,107,107,108],\"...\",49,{\"_64\":110,\"_65\":111},\"75\",[112,113,107,114],51,52,74,{\"_64\":116,\"_65\":117},\"100\",[118,119,107,120,121],76,77,98,99,\"Strategy tree: binary split from floor 50\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":124,\"_15\":159,\"_58\":59},{\"_52\":125,\"_73\":74,\"_75\":158},[54,126,132,137,107,142,149,155],{\"_64\":127,\"_65\":128},\"10\",{\"_129\":67,\"_130\":131},\"from\",\"to\",9,{\"_64\":133,\"_65\":134},\"20\",{\"_129\":135,\"_130\":136},11,19,{\"_64\":138,\"_65\":139},\"30\",{\"_129\":140,\"_130\":141},21,29,{\"_64\":143,\"_65\":144,\"_147\":148},\"80\",{\"_129\":145,\"_130\":146},71,79,\"depth\",17,{\"_64\":150,\"_65\":151,\"_147\":154},\"90\",{\"_129\":152,\"_130\":153},81,89,18,{\"_64\":116,\"_65\":156,\"_147\":136},{\"_129\":157,\"_130\":121},91,800,\"Strategy tree: steps of 10\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":161,\"_15\":210,\"_58\":59},{\"_52\":162,\"_73\":74,\"_75\":209},[54,163,167,172,177,180,184,189,193,198,201,205,116],{\"_64\":164,\"_65\":165},\"14\",{\"_129\":67,\"_130\":166},13,{\"_64\":168,\"_65\":169},\"27\",{\"_129\":170,\"_130\":171},15,26,{\"_64\":173,\"_65\":174},\"39\",{\"_129\":175,\"_130\":176},28,38,{\"_64\":105,\"_65\":178},{\"_129\":179,\"_130\":108},40,{\"_64\":181,\"_65\":182},\"60\",{\"_129\":112,\"_130\":183},59,{\"_64\":185,\"_65\":186},\"69\",{\"_129\":187,\"_130\":188},61,68,{\"_64\":190,\"_65\":191},\"77\",{\"_129\":192,\"_130\":118},70,{\"_64\":194,\"_65\":195},\"84\",{\"_129\":196,\"_130\":197},78,83,{\"_64\":150,\"_65\":199},{\"_129\":200,\"_130\":153},85,{\"_64\":202,\"_65\":203},\"95\",{\"_129\":157,\"_130\":204},94,{\"_64\":206,\"_65\":207},\"99\",{\"_129\":208,\"_130\":120},96,1100,\"Optimal strategy tree for 100 floors\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":212,\"_15\":246,\"_58\":59},{\"_52\":213,\"_73\":74,\"_75\":158},[54,214,216,218,220,222,224,226,228,230,232,234,236,241,245],{\"_64\":164,\"_65\":215},{\"_129\":67,\"_130\":166},{\"_64\":168,\"_65\":217},{\"_129\":170,\"_130\":171},{\"_64\":173,\"_65\":219},{\"_129\":175,\"_130\":176},{\"_64\":105,\"_65\":221},{\"_129\":179,\"_130\":108},{\"_64\":181,\"_65\":223},{\"_129\":112,\"_130\":183},{\"_64\":185,\"_65\":225},{\"_129\":187,\"_130\":188},{\"_64\":190,\"_65\":227},{\"_129\":192,\"_130\":118},{\"_64\":194,\"_65\":229},{\"_129\":196,\"_130\":197},{\"_64\":150,\"_65\":231},{\"_129\":200,\"_130\":153},{\"_64\":202,\"_65\":233},{\"_129\":157,\"_130\":204},{\"_64\":206,\"_65\":235},{\"_129\":208,\"_130\":120},{\"_64\":237,\"_65\":238},\"102\",[239,240],100,101,{\"_64\":242,\"_65\":243},\"104\",[244],103,\"105\",\"Maximum building height with 14 drops: 105 floors\",\"inlineComponents\",{\"_249\":250},\"strategy-tree\",{\"_13\":249,\"_251\":252,\"_253\":254},\"code\",\"// Normalize columns: expand ranges, compute full chain length\\nfunction normalizeColumns(rawColumns) {\\n  return rawColumns.map(col =\u003e {\\n    // Handle shorthand: plain string → { label: \\\"X\\\" }\\n    if (typeof col === 'string') {\\n      return { label: col, chain: [], fullChainLength: 0, depth: null };\\n    }\\n\\n    const { label, chain, depth } = col;\\n    let chainLabels = [];\\n    let fullLength = 0;\\n\\n    if (!chain) {\\n      return { label, chain: [], fullChainLength: 0, depth: depth ?? null };\\n    }\\n\\n    // Expand range syntax: { from: 1, to: 49 } → [1, 2, ..., 49]\\n    if (typeof chain === 'object' \u0026\u0026 !Array.isArray(chain)) {\\n      const { from, to } = chain;\\n      fullLength = to - from + 1;\\n      for (let i = from; i \u003c= to; i++) {\\n        chainLabels.push(String(i));\\n      }\\n    } else {\\n      chainLabels = chain.map(String);\\n      // Derive full length from first and last numeric items\\n      const nums = chainLabels.filter(l =\u003e l !== '...').map(Number);\\n      if (nums.length \u003e= 2) {\\n        fullLength = nums[nums.length - 1] - nums[0] + 1;\\n      } else {\\n        fullLength = nums.length;\\n      }\\n    }\\n\\n    return { label, chain: chainLabels, fullChainLength: fullLength, depth: depth ?? null };\\n  });\\n}\\n\\n// Compute layout parameters based on columns and container width\\nfunction computeLayout(columns, containerWidth, options) {\\n  const { showDepth, minWidth } = options;\\n  const effectiveWidth = minWidth ? Math.max(containerWidth, minWidth) : containerWidth;\\n  const numCols = columns.length;\\n\\n  // Column spacing (+1 for right-side padding so last node isn't clipped)\\n  const totalSpacing = numCols + 1;\\n  const spacing = Math.min(effectiveWidth / totalSpacing, 100);\\n  const radius = Math.min(spacing * 0.35, 20);\\n\\n  // Vertical spacing\\n  const verticalSpacing = radius * 3;\\n\\n  // Calculate height needed\\n  let maxVisibleChainLength = 0;\\n  for (const col of columns) {\\n    if (col.chain.length \u003e maxVisibleChainLength) {\\n      maxVisibleChainLength = col.chain.length;\\n    }\\n  }\\n\\n  const topRowY = radius * 2.5;\\n  const chainStartY = topRowY + verticalSpacing;\\n  let canvasHeight;\\n\\n  if (maxVisibleChainLength \u003e 0) {\\n    // Bottom of the deepest chain node circle\\n    canvasHeight = chainStartY + (maxVisibleChainLength - 1) * verticalSpacing + radius;\\n  } else {\\n    // No chains: bottom of top row circles\\n    canvasHeight = topRowY + radius;\\n  }\\n\\n  if (showDepth) {\\n    // Depth labels: radius gap below circle + up to 2 lines of text\\n    canvasHeight += radius * 3;\\n  }\\n\\n  canvasHeight += radius; // Bottom padding\\n\\n  // Calculate canvas width with extra space for \\\"(if no breaks)\\\" label\\n  let canvasWidth = totalSpacing * spacing;\\n\\n  // Check if we need to add space for the \\\"(if no breaks)\\\" label\\n  if (showDepth) {\\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =\u003e\\n      col.label !== '...' ? i : idx, 0);\\n    const lastCol = columns[lastNonEllipsisIndex];\\n    const maxFloor = Math.max(\\n      ...columns.filter(c =\u003e c.label !== '...' \u0026\u0026 !isNaN(c.label)).map(c =\u003e Number(c.label)),\\n      ...columns.flatMap(c =\u003e c.chain.filter(l =\u003e l !== '...' \u0026\u0026 !isNaN(l)).map(Number))\\n    );\\n\\n    const shouldShowLabel = lastCol.label !== '...'\\n      \u0026\u0026 lastCol.chain.length \u003e 0\\n      \u0026\u0026 Number(lastCol.label) === maxFloor;\\n\\n    if (shouldShowLabel) {\\n      // Count horizontal moves to calculate label width\\n      let lastEllipsisIndex = -1;\\n      for (let i = columns.length - 1; i \u003e= 0; i--) {\\n        if (columns[i] === '...' || columns[i].label === '...') {\\n          lastEllipsisIndex = i;\\n          break;\\n        }\\n      }\\n\\n      let horizontalMoves = 0;\\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i \u003c= lastNonEllipsisIndex; i++) {\\n        if (columns[i] !== '...' \u0026\u0026 columns[i].label !== '...') {\\n          horizontalMoves++;\\n        }\\n      }\\n\\n      // Calculate actual label width for two-line format: \\\"X moves\\\" / \\\"(if no breaks)\\\"\\n      // We need to estimate based on character count since we don't have canvas context here\\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\\n      const firstLine = `${horizontalMoves} ${word}`;\\n      const secondLine = '(if no breaks)';\\n\\n      // Estimate width: ~7-8px per character for monospace at fontSize = radius * 0.7\\n      const avgCharWidth = radius * 0.7 * 0.6; // Conservative estimate for monospace\\n      const firstLineWidth = firstLine.length * avgCharWidth;\\n      const secondLineWidth = secondLine.length * avgCharWidth;\\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\\n\\n      // Add label width + spacing + padding\\n      canvasWidth += radius + spacing * 0.3 + maxWidth + spacing * 0.6;\\n    }\\n  }\\n\\n  return {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth\\n  };\\n}\\n\\n// Draw a circle with centered label\\nfunction drawCircleNode(ctx, x, y, radius, label, colors, fonts) {\\n  const { fill, stroke, text } = colors;\\n  const { fontFamily } = fonts;\\n\\n  // Circle\\n  ctx.beginPath();\\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\\n  ctx.fillStyle = fill;\\n  ctx.fill();\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.stroke();\\n\\n  // Label\\n  ctx.fillStyle = text;\\n  ctx.textAlign = 'center';\\n  ctx.textBaseline = 'middle';\\n\\n  // Font size based on label length\\n  let fontSize;\\n  if (label.length \u003c= 2) {\\n    fontSize = radius * 0.9;\\n  } else if (label.length === 3) {\\n    fontSize = radius * 0.75;\\n  } else {\\n    fontSize = radius * 0.6;\\n  }\\n\\n  ctx.font = `bold ${fontSize}px ${fontFamily}`;\\n  ctx.fillText(label, x, y);\\n}\\n\\n// Draw an arrowhead at the given tip position and angle\\nfunction drawArrowhead(ctx, tipX, tipY, angle, radius) {\\n  const size = Math.max(3, radius * 0.3);\\n  ctx.save();\\n  ctx.translate(tipX, tipY);\\n  ctx.rotate(angle);\\n  ctx.beginPath();\\n  ctx.moveTo(0, 0);\\n  ctx.lineTo(-size, -size * 0.6);\\n  ctx.lineTo(-size, size * 0.6);\\n  ctx.closePath();\\n  ctx.fill();\\n  ctx.restore();\\n}\\n\\n// Draw a connection line between two nodes with optional arrowhead\\nfunction drawConnection(ctx, x1, y1, x2, y2, radius, showArrows, colors) {\\n  const { stroke } = colors;\\n  ctx.strokeStyle = stroke;\\n  ctx.lineWidth = 1.5;\\n  ctx.lineCap = 'round';\\n\\n  // Calculate start and end points at circle boundary\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  const dist = Math.sqrt(dx * dx + dy * dy);\\n  const angle = Math.atan2(dy, dx);\\n\\n  const startX = x1 + (dx / dist) * radius;\\n  const startY = y1 + (dy / dist) * radius;\\n  const endX = x2 - (dx / dist) * radius;\\n  const endY = y2 - (dy / dist) * radius;\\n\\n  // Draw line\\n  ctx.beginPath();\\n  ctx.moveTo(startX, startY);\\n  ctx.lineTo(endX, endY);\\n  ctx.stroke();\\n\\n  // Draw arrowhead\\n  if (showArrows) {\\n    ctx.fillStyle = stroke;\\n    drawArrowhead(ctx, endX, endY, angle, radius);\\n  }\\n}\\n\\n// Draw three vertical ellipsis dots\\nfunction drawVerticalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x, y + i * gap, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\n// Draw three horizontal ellipsis dots\\nfunction drawHorizontalEllipsis(ctx, x, y, color, radius) {\\n  ctx.fillStyle = color;\\n  const dotRadius = Math.max(1.5, radius * 0.125);\\n  const gap = Math.max(5, radius * 0.4);\\n\\n  for (let i = -1; i \u003c= 1; i++) {\\n    ctx.beginPath();\\n    ctx.arc(x + i * gap, y, dotRadius, 0, Math.PI * 2);\\n    ctx.fill();\\n  }\\n}\\n\\nfunction draw(options) {\\n  const { canvas, api, width: containerWidth, props } = options;\\n  const ctx = canvas.getContext('2d');\\n\\n  // Default props\\n  const {\\n    columns: rawColumns = [],\\n    showDepth = false,\\n    showArrows = true,\\n    minWidth = 0,\\n  } = props;\\n\\n  if (!rawColumns || rawColumns.length === 0) {\\n    canvas.width = containerWidth;\\n    canvas.height = 100;\\n    ctx.fillStyle = api.getColor('muted-foreground');\\n    ctx.font = `14px ${api.getFont('default')}`;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'middle';\\n    ctx.fillText('No columns provided', containerWidth / 2, 50);\\n    api.requestResize(100);\\n    return;\\n  }\\n\\n  // Normalize columns\\n  const columns = normalizeColumns(rawColumns);\\n\\n  // Compute layout\\n  const layout = computeLayout(columns, containerWidth, { showDepth, minWidth });\\n  const {\\n    spacing,\\n    radius,\\n    verticalSpacing,\\n    topRowY,\\n    chainStartY,\\n    canvasHeight,\\n    canvasWidth\\n  } = layout;\\n\\n  canvas.width = canvasWidth;\\n  canvas.height = canvasHeight;\\n\\n  // Colors (theme-aware)\\n  const foreground = api.getColor('foreground');\\n  const cardBg = api.getColor('card');\\n  const mutedBg = api.getColor('muted');\\n  const mutedFg = api.getColor('muted-foreground');\\n  const primaryColor = api.getColor('primary');\\n\\n  const colors = {\\n    stroke: foreground,\\n    fill: cardBg,\\n    mutedFill: mutedBg,\\n    text: foreground,\\n    ellipsis: mutedFg,\\n    depth: primaryColor\\n  };\\n\\n  const fonts = {\\n    fontFamily: api.getFont('default'),\\n    monoFamily: api.getFont('mono')\\n  };\\n\\n  // Track y-positions for each column's chain\\n  const columnYPositions = columns.map(() =\u003e []);\\n\\n  // Draw horizontal chain nodes\\n  for (let i = 0; i \u003c columns.length; i++) {\\n    const col = columns[i];\\n    const x = (i + 1) * spacing;\\n    const y = topRowY;\\n\\n    if (col.label === '...') {\\n      // Draw horizontal ellipsis dots instead of a circle\\n      drawHorizontalEllipsis(ctx, x, y, colors.ellipsis, radius);\\n    } else {\\n      // First column uses muted background\\n      const nodeFill = i === 0 ? colors.mutedFill : colors.fill;\\n      const nodeColors = { ...colors, fill: nodeFill };\\n      drawCircleNode(ctx, x, y, radius, col.label, nodeColors, fonts);\\n    }\\n\\n    // Draw horizontal connection to next column\\n    if (i \u003c columns.length - 1) {\\n      const nextX = (i + 2) * spacing;\\n      drawConnection(ctx, x, y, nextX, y, radius, showArrows, colors);\\n    }\\n\\n    // Track positions for vertical chains\\n    columnYPositions[i].push({ x, y });\\n  }\\n\\n  // Draw vertical chains\\n  for (let colIdx = 0; colIdx \u003c columns.length; colIdx++) {\\n    const col = columns[colIdx];\\n    if (col.chain.length === 0) continue;\\n\\n    const x = (colIdx + 1) * spacing;\\n    let currentY = chainStartY;\\n\\n    for (let chainIdx = 0; chainIdx \u003c col.chain.length; chainIdx++) {\\n      const label = col.chain[chainIdx];\\n      const isEllipsis = label === '...';\\n\\n      if (isEllipsis) {\\n        // Draw vertical ellipsis dots centered where the circle would be\\n        drawVerticalEllipsis(ctx, x, currentY, colors.ellipsis, radius);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      } else {\\n        // Draw regular node\\n        drawCircleNode(ctx, x, currentY, radius, label, colors, fonts);\\n        columnYPositions[colIdx].push({ x, y: currentY });\\n\\n        // Connection from previous\\n        const prevPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 2];\\n        drawConnection(ctx, prevPos.x, prevPos.y, x, currentY, radius, showArrows, colors);\\n\\n        currentY += verticalSpacing;\\n      }\\n    }\\n  }\\n\\n  // Draw depth labels if enabled (for all columns except start and ellipsis)\\n  if (showDepth) {\\n    const fontSize = radius * 0.7;\\n    ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\\n    ctx.fillStyle = colors.depth;\\n    ctx.textAlign = 'center';\\n    ctx.textBaseline = 'top';\\n\\n    for (let colIdx = 1; colIdx \u003c columns.length; colIdx++) {\\n      const col = columns[colIdx];\\n      if (col.label === '...') continue;\\n      const x = (colIdx + 1) * spacing;\\n      const lastPos = columnYPositions[colIdx][columnYPositions[colIdx].length - 1];\\n      const depth = col.depth ?? (colIdx + col.fullChainLength);\\n      const depthY = lastPos.y + radius * 2;\\n      const word = depth === 1 ? 'move' : 'moves';\\n      const singleLine = `${depth} ${word}`;\\n\\n      // Check if single line fits within column spacing\\n      const textWidth = ctx.measureText(singleLine).width;\\n      if (textWidth \u003c spacing * 0.95) {\\n        ctx.fillText(singleLine, x, depthY);\\n      } else {\\n        ctx.fillText(String(depth), x, depthY);\\n        ctx.fillText(word, x, depthY + fontSize * 1.2);\\n      }\\n    }\\n  }\\n\\n  // Draw \\\"(if no breaks)\\\" label to the right of horizontal chain\\n  // Show when: last column AND has a chain AND its floor number equals max floor\\n  if (showDepth) {\\n    // Find last non-ellipsis column index\\n    const lastNonEllipsisIndex = columns.reduce((idx, col, i) =\u003e\\n      col.label !== '...' ? i : idx, 0);\\n\\n    // Find maximum floor number across all columns and chains\\n    const maxFloor = Math.max(\\n      ...columns.filter(c =\u003e c.label !== '...' \u0026\u0026 !isNaN(c.label)).map(c =\u003e Number(c.label)),\\n      ...columns.flatMap(c =\u003e c.chain.filter(l =\u003e l !== '...' \u0026\u0026 !isNaN(l)).map(Number))\\n    );\\n\\n    const col = columns[lastNonEllipsisIndex];\\n    const shouldShowLabel = col.label !== '...'\\n      \u0026\u0026 col.chain.length \u003e 0\\n      \u0026\u0026 Number(col.label) === maxFloor;\\n\\n    if (shouldShowLabel) {\\n      const x = (lastNonEllipsisIndex + 1) * spacing;\\n      const y = topRowY;\\n      const fontSize = radius * 0.7; // Match the depth label font size\\n\\n      ctx.font = `bold ${fontSize}px ${fonts.monoFamily}`;\\n      ctx.fillStyle = colors.depth;\\n      ctx.textAlign = 'center';\\n      ctx.textBaseline = 'middle';\\n\\n      // Count consecutive non-ellipsis columns at the end (after last ellipsis, if any)\\n      let lastEllipsisIndex = -1;\\n      for (let i = columns.length - 1; i \u003e= 0; i--) {\\n        if (columns[i] === '...' || columns[i].label === '...') {\\n          lastEllipsisIndex = i;\\n          break;\\n        }\\n      }\\n\\n      // Count non-start columns from after the last ellipsis to the end\\n      let horizontalMoves = 0;\\n      for (let i = Math.max(1, lastEllipsisIndex + 1); i \u003c= lastNonEllipsisIndex; i++) {\\n        if (columns[i] !== '...' \u0026\u0026 columns[i].label !== '...') {\\n          horizontalMoves++;\\n        }\\n      }\\n\\n      const word = horizontalMoves === 1 ? 'move' : 'moves';\\n      const firstLine = `${horizontalMoves} ${word}`;\\n      const secondLine = '(if no breaks)';\\n\\n      // Measure both lines to find the widest one\\n      const firstLineWidth = ctx.measureText(firstLine).width;\\n      const secondLineWidth = ctx.measureText(secondLine).width;\\n      const maxWidth = Math.max(firstLineWidth, secondLineWidth);\\n\\n      // Position label so it starts after the circle with spacing, centered on maxWidth\\n      const labelX = x + radius + spacing * 0.3 + maxWidth / 2;\\n      ctx.fillText(firstLine, labelX, y - fontSize * 0.6);\\n      ctx.fillText(secondLine, labelX, y + fontSize * 0.6);\\n    }\\n  }\\n\\n  // Resize iframe to fit canvas\\n  api.requestResize(canvasHeight);\\n}\",\"startLine\",314,\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>