<!DOCTYPE html><html lang="en" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="color-scheme" content="dark light"/><link rel="preload" href="/assets/poppins-400-cpxAROuN.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-500-C8OXljZJ.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-600-zEkxB9Mr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-700-Qrb0O0WB.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Traversing the Hypercube - Puzzlestone Peak</title><meta name="description" content="Ossarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if..."/><meta property="og:title" content="Traversing the Hypercube - Puzzlestone Peak"/><meta property="og:description" content="Ossarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if..."/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Traversing the Hypercube - Puzzlestone Peak"/><meta name="twitter:description" content="Ossarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if..."/><meta name="keywords" content="graph-theory, hamiltonian-cycles, induction, hard, logic puzzle"/><link rel="modulepreload" href="/assets/manifest-e73eb6ee.js"/><link rel="modulepreload" href="/assets/entry.client-BQEHofJp.js"/><link rel="modulepreload" href="/assets/index-DIth0oIc.js"/><link rel="modulepreload" href="/assets/root-DeKCuioB.js"/><link rel="modulepreload" href="/assets/Logo-BRp-LhsU.js"/><link rel="modulepreload" href="/assets/use-dark-mode-mdHJdo6o.js"/><link rel="modulepreload" href="/assets/card-CRYRt8Xe.js"/><link rel="modulepreload" href="/assets/NavHeightContext-BwIQMGhB.js"/><link rel="modulepreload" href="/assets/expeditionIndex-BBmHlwnS.js"/><link rel="modulepreload" href="/assets/puzzleIndex-CkuFLq0I.js"/><link rel="modulepreload" href="/assets/loader-circle-D4Vxh6Q3.js"/><link rel="modulepreload" href="/assets/puzzle-detail-hC9iNGYR.js"/><link rel="modulepreload" href="/assets/useBack-uAQCGYKp.js"/><link rel="modulepreload" href="/assets/ItemCardList-BrZolSfb.js"/><link rel="modulepreload" href="/assets/ErrorBoundary-DAtG3o8H.js"/><script>
              (function initTheme() {
                if (localStorage.getItem('darkmode') === '1') {
                  document.documentElement.classList.add('dark');
                }
              })();
            </script><link rel="stylesheet" href="/assets/root-DvQh58kf.css"/><link rel="stylesheet" href="/assets/useBack-2KSn8t0Q.css"/></head><body><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><div class="min-h-screen bg-background"><nav class="sticky top-0 z-[1000] border-b border-border bg-card"><div class="container mx-auto px-6"><div class="flex h-16 items-center justify-between"><a class="flex items-center gap-3 text-nav-foreground no-underline" href="/" data-discover="true"><svg class="h-10 w-10 text-nav-foreground" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2211.37 2208.98" aria-label="Puzzlestone Peak Logo"><g><g><path fill="currentColor" d="M1108.28,0c649.77,5.24,1114.13,533.8,1102.89,1120-11.85,618.13-493.23,1100.61-1128,1088.81C450,2197-8.61,1690.25.12,1087.2,8.81,487.59,492.57,4.1,1108.28,0ZM121.13,1114.76c1.14,543.44,432.5,984.51,996.37,978.51,557.06-5.93,978-444.2,971.35-995.6C2082,528.37,1628.73,114,1095.67,118.84,573.44,123.64,121,538.05,121.13,1114.76Z"></path><path fill="currentColor" d="M2021.18,1304.81c-125.17-118.57-243.11-238.8-364.9-359.1-2.56,14.24,1.92,24,3.82,33.95,4.41,23.07,11.61,45.81,13.73,69.05,4,43.53,24.59,76.14,55.56,106,57.17,55,111.85,112.69,167.64,169.19,3.08,3.11,6.78,5.62,13.43,11.07l-29.92-94c24.62,13.75,40.06,32.2,57.87,47.59,20.91,18.06,40.77,37.34,61.77,55.28,8.84,7.54,10.58,14.7,7.36,25.8-20.06,69.13-47.63,135-81.34,198.6-9.36,17.65-14.91,9.53-22.48,0q-90.9-114.8-181.89-229.53-95.47-120.15-191.27-240c-1-1.26-2.64-2-7-5.25,9.72,71.9,28.35,139.3,37.91,208.53-107.81-169.7-206.63-344.59-311.28-516-9.22,3.51-3.87,12.13-10,16-12-7.35-18.72-20.06-27.45-30.66q-45.4-55.15-89.63-111.28c-9.15-11.66-14.16-9.84-23.87.14-12.63,13-13.15,24.45-6.86,40.56,17.11,43.76,35.07,87.25,48.64,132.33,1,3.28,1.72,6.64,3.84,14.9L1022.35,771.4l-2.78,2.64c13.51,22.36,26.89,44.8,40.55,67.06,24.58,40.09,49,80.27,74.21,120,6,9.48,6,15.92-1.51,24.54-28.26,32.31-55.84,65.21-83.61,97.95-15.86,18.69-15.92,18.85,1.06,35.86q114.7,114.87,229.51,229.63c2.84,2.84,5.41,6,11.73,12.92-46.79-8.28-88.16-19-132.09-25.8l298,291.64,3.93-2.17L1430.53,1306c23.59,34.58,44.25,64.91,65,95.22q123.36,180.63,251.43,357.94c1.38,1.9,2.39,4.13,4,5.79,13.32,13.77,9.47,24-4.25,35.81-47.75,41.22-98,78.83-151.9,111.65-8.1,4.94-16.34,5.41-25.27,5.45-104.54.45-203.43-26.94-300.81-61.29-107-37.74-210.39-84.76-315.67-126.92-149.26-59.78-302.65-102.49-463-118.55-55.13-5.53-110.43-4.65-165.7-3.63-9.28.18-16.45-.49-22-10-61.64-105.06-105-216.59-122.31-337.73-1.51-10.61,1.49-17.46,8.71-24.81q184.24-187.54,367.82-375.72c10-10.28,15.36-7.56,23.67,1.12,35.77,37.39,72.31,74.05,108,111.53,8.31,8.73,13.08,10.25,21.86.21Q871.5,787.48,1033.71,603.54c21-23.84,42.59-47.13,63.21-71.27,8.62-10.09,13.52-8.08,21.52,1q195.46,222.81,391.26,445.32c9.78,11.18,14.44,10.28,23.92.32,36.07-37.91,73.29-74.72,109.47-112.54,8.26-8.63,13.09-7.71,20.87.25q175.07,179.21,350.85,357.7c13.23,13.39,20.15,25.9,13.9,44.57C2025.39,1278.84,2024.3,1289.49,2021.18,1304.81ZM564.41,931.41c0,18.05-1.59,31,.28,43.31,7.16,47.25-7.05,85.12-43.68,116.5-15.75,13.5-32.89,30.56-38.74,49.32-11,35.33-14.27,73.08-20.87,110.49,8.29-1,11-6.85,14.51-11.08q84.69-101.51,174.52-198.49c8.71-9.46,11.86-16.15.08-25.48-9.14-7.24-16.56-16.62-24.93-24.86C606.56,972.43,587.42,953.86,564.41,931.41Z"></path><path fill="currentColor" d="M1258,2036.19c-156.22,31.67-307.68,13.84-456-37.14-128-44-242.37-111.53-346.16-205.19,33.78-3.18,62.72.36,91.57,3.41,177.71,18.78,340.49,86.11,502.68,155.25,63.74,27.17,127.88,53.3,193.63,75.29C1248.52,2029.42,1254.05,2029.85,1258,2036.19Z"></path><path fill="currentColor" d="M1461.61,671.32c.48-75.58,59.09-133.3,135-132.91,69.62.35,129.18,61.43,128.77,132.05-.43,74-59.91,132.06-134.66,131.48C1518.42,801.37,1461.15,743.42,1461.61,671.32Z"></path></g></g></svg><span class="text-[1.25rem] font-semibold leading-none">Puzzlestone Peak</span></a><div class="hidden items-center gap-6 md:flex"><ul class="flex items-center gap-8"><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/progress" data-discover="true">Progress</a></li></ul><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div><button class="flex h-8 w-8 cursor-pointer flex-col justify-around border-none bg-transparent p-1 text-nav-foreground md:hidden" aria-label="Toggle mobile menu" aria-expanded="false" aria-controls="mobile-menu"><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span></button></div></div></nav><div id="mobile-menu" class="fixed left-0 right-0 top-16 z-[999] border-b border-border bg-card shadow-lg transition-all duration-300 md:hidden pointer-events-none -translate-y-full opacity-0"><div class="px-6 pb-6 pt-4"><ul class="flex flex-col gap-3"><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/progress" data-discover="true">Progress</a></li></ul><div class="mt-4 flex justify-center border-t border-border pt-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div></div></div><main><div class="container mx-auto px-4 py-6 max-w-4xl"><a class="inline-flex items-center text-link hover:text-link-hover hover:underline mb-6 cursor-pointer" href="/puzzles" data-discover="true">← Back</a><div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-4"><h1 class="text-4xl font-bold text-foreground sm:flex-1">Traversing the Hypercube</h1><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><div class="space-y-4 border-b border-divider pb-6 mb-6"><div><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-hard text-difficulty-hard-foreground">Hard</span></div><div class="text-sm text-muted-foreground"><span>Created: <!-- -->November 2, 2025</span></div></div><div class="markdown-content prose max-w-none space-y-4"></div><div class="flex justify-center my-8"><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><section class="mt-12"><h2 class="mb-6 text-xl font-bold text-foreground lg:text-2xl">Try These Next</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/chain-link-2" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Chain Link 2</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">An apprentice is working for you, the village’s master blacksmith, for 21 days. For payment, you have agreed to give him a gold chain with 21 links, one link...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/two-girlfriends-and-two-trains" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Two Girlfriends and Two Trains</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Unfaithful Bob has two girlfriends Alice and Carol. Bob can take a train ride from the city’s train station to get to them. There is only 1 line going in both...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/confused-bank-teller" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Confused Bank Teller</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">When Dorothy went to cash in a cheque, the confused bank teller swapped the dollars and cents. He gave her dollars in place of cents, and cents in place of...</p></div></a></div></section></div></main></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":false,"unstable_splitRouteModules":false,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-e73eb6ee.js";
import * as route0 from "/assets/root-DeKCuioB.js";
import * as route1 from "/assets/puzzle-detail-hC9iNGYR.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/puzzle-detail":route1};

import("/assets/entry.client-BQEHofJp.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_148\":-5,\"_149\":-5},\"loaderData\",{\"_3\":4},\"routes/puzzle-detail\",{\"_5\":6,\"_7\":8,\"_9\":10},\"status\",\"success\",\"slug\",\"traversing-the-hypercube\",\"puzzle\",{\"_7\":8,\"_11\":12,\"_37\":38,\"_39\":40,\"_41\":42,\"_138\":139},\"metadata\",{\"_13\":14,\"_15\":16,\"_17\":18,\"_19\":20,\"_24\":25,\"_27\":28,\"_29\":30,\"_31\":30,\"_32\":33,\"_34\":35,\"_36\":35},\"id\",\"puzzle-1\",\"title\",\"Traversing the Hypercube\",\"difficulty\",\"hard\",\"concepts\",[21,22,23],\"graph-theory\",\"hamiltonian-cycles\",\"induction\",\"tags\",[26],\"has-solution\",\"credit\",\"Classic graph theory problem. Question and solution written by Puzzlestone Peak.\",\"dateCreated\",\"2025-11-02\",\"lastUpdated\",\"changelog\",\"2025-11-03: Added to Puzzlestone Peak\",\"preview\",\"Ossarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if...\",\"websitePreview\",\"content\",\"\u003cp\u003eOssarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if it’s possible to travel along the edges of a hypercube, visiting each vertex exactly once before returning to the start. Such a path is called a Hamiltonian cycle.\u003c/p\u003e\\n\u003cp\u003eExcited with the challenge, he takes a look at a 2D hypercube, an object that you would call a \\\"square\\\". Starting at a vertex, he easily finds that he can traverse the following path, visiting each vertex exactly once.\u003c/p\u003e\\n\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"0\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eUp next is a 3D hypercube, or a \\\"cube\\\". With more options at each vertex to navigate, it's harder to find a route that traverses each vertex only once. Eventually, though, Ossarion-429 finds such a path. Can you find it too?\u003c/p\u003e\\n\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"1\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\\n\u003cp\u003eSo far so good; we’ve managed to find a Hamiltonian cycle for 2D and 3D hypercubes. But how about a 4-dimensional hypercube? Or 5? As the number of vertices increases exponentially with the number of dimensions, would there ever be a hypercube that doesn’t have a Hamiltonian cycle? If yes, what’s the smallest n such that an n-dimensional hypercube has no such path? If not, prove it.\u003c/p\u003e\\n\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eAll n-dimensional hypercubes have a Hamiltonian cycle, so long as \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e≥\u003c/mo\u003e\u003cmn\u003e2\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation\u003en \\\\geq 2\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.7719em;vertical-align:-0.136em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003en\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mrel\\\"\u003e≥\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e, which I'll explain why at the end.\u003c/p\u003e\u003cp\u003eLet's prove this by considering the Hamiltonian cycle on a square.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"2\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eTo construct a cube, we can place 2 squares side by side and connect their corresponding vertices.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"3\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eLet's draw a Hamiltonian cycle for each square, leaving out the last edge that brings us back to the start. We'll also reverse the path on one of the squares.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"4\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNote how we can connect the two paths together like this, forming a Hamiltonian cycle for a cube.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"5\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe can perform a similar process to construct a Hamiltonian cycle for a 4D hypercube.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"6\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis works for higher-dimensional hypercubes, proving that there will always be a Hamiltonian cycle.\u003c/p\u003e\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eExtra Credit\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eThere's also another way to solve this. Let's consider a cube with unit length, placing one corner at the origin of a 3D cartesian space. Its vertices will be at the coordinates (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), and (1, 1, 1). We then convert each vertex directly into binary by concatenating its coordinates. For instance, the vertex at (1, 0, 1) will be \u003ccode\u003e101\u003c/code\u003e. If you know what \u003ca href=\\\"/expedition/gray-code\\\"\u003eGray codes\u003c/a\u003e are, you'll notice that the Gray code sequence of length 3 will form our Hamiltonian cycle.\u003c/p\u003e\u003cp\u003e\u003ccode\u003e000\u003c/code\u003e, \u003ccode\u003e001\u003c/code\u003e, \u003ccode\u003e011\u003c/code\u003e, \u003ccode\u003e010\u003c/code\u003e, \u003ccode\u003e110\u003c/code\u003e, \u003ccode\u003e111\u003c/code\u003e, \u003ccode\u003e101\u003c/code\u003e, \u003ccode\u003e100\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThis works because of 3 facts:\u003c/p\u003e\u003cul\u003e\\n\u003cli\u003eEvery number in the Gray code sequence is unique, ensuring that we will never visit the same vertex twice.\u003c/li\u003e\\n\u003cli\u003e2 vertices are connected by an edge if and only if their coordinates differ by 1 value. For instance, (0, 0, 0) is adjacent to (1, 0, 0), (0, 1, 0), and (0, 0, 1). Since each consecutive number in the Gray code differs by at most one value, the sequence forms a valid path on the cube.\u003c/li\u003e\\n\u003cli\u003eThe last number in the Gray code sequence is only 1 bit off from the first number, allowing us to form a closed cycle.\u003c/li\u003e\\n\u003c/ul\u003e\u003cp\u003eLet's take a look at our earlier examples with the binary labels.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"7\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"8\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"9\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eBut why is this not true for \u003cspan class=\\\"katex\\\"\u003e\u003cspan class=\\\"katex-mathml\\\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/mrow\u003e\u003cannotation\u003en = 1\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\\\"katex-html\\\"\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord mathnormal\\\"\u003en\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mrel\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\\\"base\\\"\u003e\u003cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003e\u003c/span\u003e\u003cspan class=\\\"mord\\\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e? Well, that's because a 1D hypercube is just a line.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"10\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe path that traverses each vertex once will start at one vertex, go to the other, then back, crossing the same edge twice. In graph theory, cycles cannot repeat a vertex or an edge, so we cannot consider this a Hamiltonian cycle based on this technicality.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\",\"rawContent\",\"\\nOssarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if it’s possible to travel along the edges of a hypercube, visiting each vertex exactly once before returning to the start. Such a path is called a Hamiltonian cycle.\\n\\nExcited with the challenge, he takes a look at a 2D hypercube, an object that you would call a \\\"square\\\". Starting at a vertex, he easily finds that he can traverse the following path, visiting each vertex exactly once.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"2D hypercube (square) with Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 2\\n  paths:\\n    - [\\\"00\\\", \\\"01\\\", \\\"11\\\", \\\"10\\\", \\\"00\\\"]\\n```\\n:::\\n\\nUp next is a 3D hypercube, or a \\\"cube\\\". With more options at each vertex to navigate, it's harder to find a route that traverses each vertex only once. Eventually, though, Ossarion-429 finds such a path. Can you find it too?\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"3D hypercube (cube)\\\"\\nprops:\\n  dimensions: 3\\n```\\n:::\\n\\nSo far so good; we’ve managed to find a Hamiltonian cycle for 2D and 3D hypercubes. But how about a 4-dimensional hypercube? Or 5? As the number of vertices increases exponentially with the number of dimensions, would there ever be a hypercube that doesn’t have a Hamiltonian cycle? If yes, what’s the smallest n such that an n-dimensional hypercube has no such path? If not, prove it.\\n\\n:::::solution\\nAll n-dimensional hypercubes have a Hamiltonian cycle, so long as $n \\\\geq 2$, which I'll explain why at the end.\\n\\nLet's prove this by considering the Hamiltonian cycle on a square.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Square with Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 2\\n  paths:\\n    - [\\\"00\\\", \\\"01\\\", \\\"11\\\", \\\"10\\\", \\\"00\\\"]\\n```\\n:::\\n\\nTo construct a cube, we can place 2 squares side by side and connect their corresponding vertices.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Cube constructed from two squares\\\"\\nprops:\\n  dimensions: 3\\n```\\n:::\\n\\nLet's draw a Hamiltonian cycle for each square, leaving out the last edge that brings us back to the start. We'll also reverse the path on one of the squares.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Cube with paths on each square face\\\"\\nprops:\\n  dimensions: 3\\n  paths:\\n    - [\\\"000\\\", \\\"001\\\", \\\"011\\\", \\\"010\\\"]\\n    - [\\\"110\\\", \\\"111\\\", \\\"101\\\", \\\"100\\\"]\\n```\\n:::\\n\\nNote how we can connect the two paths together like this, forming a Hamiltonian cycle for a cube.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Cube with complete Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 3\\n  paths:\\n    - [\\\"000\\\", \\\"001\\\", \\\"011\\\", \\\"010\\\", \\\"110\\\", \\\"111\\\", \\\"101\\\", \\\"100\\\", \\\"000\\\"]\\n```\\n:::\\n\\nWe can perform a similar process to construct a Hamiltonian cycle for a 4D hypercube.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"4D hypercube with Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 4\\n  paths:\\n    - [\\\"0000\\\", \\\"0001\\\", \\\"0011\\\", \\\"0010\\\", \\\"0110\\\", \\\"0111\\\", \\\"0101\\\", \\\"0100\\\", \\\"1100\\\", \\\"1101\\\", \\\"1111\\\", \\\"1110\\\", \\\"1010\\\", \\\"1011\\\", \\\"1001\\\", \\\"1000\\\", \\\"0000\\\"]\\n```\\n:::\\n\\nThis works for higher-dimensional hypercubes, proving that there will always be a Hamiltonian cycle.\\n\\n::::solution[Extra Credit]\\n\\nThere's also another way to solve this. Let's consider a cube with unit length, placing one corner at the origin of a 3D cartesian space. Its vertices will be at the coordinates (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), and (1, 1, 1). We then convert each vertex directly into binary by concatenating its coordinates. For instance, the vertex at (1, 0, 1) will be `101`. If you know what [Gray codes](expedition:gray-code) are, you'll notice that the Gray code sequence of length 3 will form our Hamiltonian cycle.\\n\\n`000`, `001`, `011`, `010`, `110`, `111`, `101`, `100`.\\n\\nThis works because of 3 facts:\\n- Every number in the Gray code sequence is unique, ensuring that we will never visit the same vertex twice.  \\n- 2 vertices are connected by an edge if and only if their coordinates differ by 1 value. For instance, (0, 0, 0) is adjacent to (1, 0, 0), (0, 1, 0), and (0, 0, 1). Since each consecutive number in the Gray code differs by at most one value, the sequence forms a valid path on the cube.  \\n- The last number in the Gray code sequence is only 1 bit off from the first number, allowing us to form a closed cycle.\\n\\nLet's take a look at our earlier examples with the binary labels.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Labelled 2D hypercube with Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 2\\n  labels: true\\n  paths:\\n    - [\\\"00\\\", \\\"01\\\", \\\"11\\\", \\\"10\\\", \\\"00\\\"]\\n```\\n:::\\n\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Labelled 3D hypercube with Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 3\\n  labels: true\\n  paths:\\n    - [\\\"000\\\", \\\"001\\\", \\\"011\\\", \\\"010\\\", \\\"110\\\", \\\"111\\\", \\\"101\\\", \\\"100\\\", \\\"000\\\"]\\n```\\n:::\\n\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"Labelled 4D hypercube with Hamiltonian cycle\\\"\\nprops:\\n  dimensions: 4\\n  labels: true\\n  paths:\\n    - [\\\"0000\\\", \\\"0001\\\", \\\"0011\\\", \\\"0010\\\", \\\"0110\\\", \\\"0111\\\", \\\"0101\\\", \\\"0100\\\", \\\"1100\\\", \\\"1101\\\", \\\"1111\\\", \\\"1110\\\", \\\"1010\\\", \\\"1011\\\", \\\"1001\\\", \\\"1000\\\", \\\"0000\\\"]\\n```\\n:::\\n\\nBut why is this not true for $n = 1$? Well, that's because a 1D hypercube is just a line.\\n\\n:::dynamic\\n```yaml\\nuse: '#hypercube-viz'\\ntitle: \\\"1D hypercube (line)\\\"\\nprops:\\n  dimensions: 1\\n  labels: true\\n```\\n:::\\n\\nThe path that traverses each vertex once will start at one vertex, go to the other, then back, crossing the same edge twice. In graph theory, cycles cannot repeat a vertex or an edge, so we cannot consider this a Hamiltonian cycle based on this technicality.\\n::::\\n:::::\\n\\n:::component[hypercube-viz]\\n```html\\n\u003ccanvas id=\\\"hypercube-canvas\\\"\u003e\u003c/canvas\u003e\\n```\\n\\n```js\\n// Configuration constants\\nconst MAX_CUBE_WIDTH = 100;\\nconst LABEL_OFFSET = 25;\\nconst Z_X_MULTIPLIER = 0.3;\\nconst W_X_MULTIPLIER = 2;\\nconst Z_Y_MULTIPLIER = -0.3;\\nconst W_Y_MULTIPLIER = -0.8;\\nconst BASE_LINE_WIDTH = 2;\\nconst PATH_LINE_WIDTH = 4;\\nconst PATH_ARROW_LINE_WIDTH = 2;\\nconst VERTEX_RADIUS = 4;\\nconst PADDING = 20;\\nconst ARROWHEAD_LENGTH = 12;\\nconst ARROWHEAD_ANGLE = Math.PI / 3;\\n\\nfunction mount(options) {\\n  const { root, api, props } = options;\\n  const canvas = root.querySelector('#hypercube-canvas');\\n  const ctx = canvas.getContext('2d');\\n\\n  // Default props\\n  const dimensions = props.dimensions;\\n  const showLabels = props.labels ?? false;\\n  const paths = props.paths || [];\\n\\n  // Draw function that handles the actual rendering\\n  function drawCube() {\\n    const width = api.size.width;\\n\\n    // Generate all vertices for n-dimensional hypercube\\n    const vertices = generateVertices(dimensions);\\n\\n    // Calculate projection bounds\\n    const projected = vertices.map(v =\u003e projectVertex(v));\\n    const bounds = calculateBounds(projected);\\n\\n    // Calculate diagram dimensions in unit space (natural aspect ratio)\\n    const diagramWidth = bounds.maxX - bounds.minX;\\n    const diagramHeight = bounds.maxY - bounds.minY;\\n\\n    // Calculate label space needed by finding max offsets from calculateLabelOffset\\n    let labelHorizontalSpace = 0;\\n    let labelVerticalSpace = 0;\\n    if (showLabels) {\\n      // Estimate text dimensions (approximate based on 1rem font)\\n      const charWidth = 10; // Approximate width per character in pixels\\n      const textHeight = 16; // Approximate text height in pixels\\n      const maxLabelWidth = dimensions * charWidth; // e.g., \\\"1111\\\" is 4 chars for 4D\\n\\n      projected.forEach(vertex =\u003e {\\n        const offset = calculateLabelOffset(vertex, MAX_CUBE_WIDTH);\\n        // Add text dimensions to offset to get total space needed\\n        labelHorizontalSpace = Math.max(labelHorizontalSpace, Math.abs(offset.x) + maxLabelWidth / 2);\\n        labelVerticalSpace = Math.max(labelVerticalSpace, Math.abs(offset.y) + textHeight / 2);\\n      });\\n    }\\n\\n    // Calculate actual cube width in pixels (fit within available width, up to MAX_CUBE_WIDTH)\\n    const canvasWidth = width;\\n    const availableWidth = canvasWidth - 2 * labelHorizontalSpace;\\n    const cubeWidth = Math.min(MAX_CUBE_WIDTH, availableWidth / diagramWidth);\\n\\n    const canvasHeight = diagramHeight * cubeWidth + 2 * PADDING + 2 * labelVerticalSpace;\\n\\n    canvas.width = canvasWidth;\\n    canvas.height = canvasHeight;\\n\\n    // Clear canvas\\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\\n\\n    // Center offset (leave space for labels on both sides)\\n    const offsetX = labelHorizontalSpace + (availableWidth - diagramWidth * cubeWidth) / 2 - bounds.minX * cubeWidth;\\n    const offsetY = PADDING + labelVerticalSpace - bounds.minY * cubeWidth;\\n\\n    // Scale and translate projected vertices\\n    const scaledVertices = projected.map(p =\u003e ({\\n      x: p.x * cubeWidth + offsetX,\\n      y: p.y * cubeWidth + offsetY,\\n      label: p.label\\n    }));\\n\\n    // Get theme colors\\n    const mutedColor = api.getColor('muted-foreground');\\n    const foregroundColor = api.getColor('foreground');\\n\\n    // Draw base edges\\n    ctx.strokeStyle = mutedColor;\\n    ctx.lineWidth = BASE_LINE_WIDTH;\\n    const edges = generateEdges(vertices);\\n    edges.forEach(([i, j]) =\u003e {\\n      const v1 = scaledVertices[i];\\n      const v2 = scaledVertices[j];\\n      ctx.beginPath();\\n      ctx.moveTo(v1.x, v1.y);\\n      ctx.lineTo(v2.x, v2.y);\\n      ctx.stroke();\\n    });\\n\\n    // Draw vertices (before path lines so paths appear on top)\\n    ctx.fillStyle = mutedColor;\\n    scaledVertices.forEach(v =\u003e {\\n      ctx.beginPath();\\n      ctx.arc(v.x, v.y, VERTEX_RADIUS, 0, 2 * Math.PI);\\n      ctx.fill();\\n    });\\n\\n    // Draw path lines if provided (drawn on top of vertices)\\n    if (paths \u0026\u0026 paths.length \u003e 0) {\\n      ctx.strokeStyle = foregroundColor;\\n      ctx.lineWidth = PATH_LINE_WIDTH;\\n\\n      paths.forEach(path =\u003e {\\n        for (let i = 0; i \u003c path.length - 1; i++) {\\n          const idx1 = vertices.findIndex(v =\u003e v.label === path[i]);\\n          const idx2 = vertices.findIndex(v =\u003e v.label === path[i + 1]);\\n          if (idx1 !== -1 \u0026\u0026 idx2 !== -1) {\\n            const v1 = scaledVertices[idx1];\\n            const v2 = scaledVertices[idx2];\\n\\n            // Draw the path line\\n            ctx.lineWidth = PATH_LINE_WIDTH;\\n            ctx.beginPath();\\n            ctx.moveTo(v1.x, v1.y);\\n            ctx.lineTo(v2.x, v2.y);\\n            ctx.stroke();\\n\\n            // Draw arrowhead with center at midpoint\\n            ctx.lineWidth = PATH_ARROW_LINE_WIDTH;\\n            const midX = (v1.x + v2.x) / 2;\\n            const midY = (v1.y + v2.y) / 2;\\n\\n            // Calculate direction angle\\n            const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);\\n\\n            // Calculate tip position (half arrowhead length forward from midpoint)\\n            const tipX = midX + (ARROWHEAD_LENGTH / 2) * Math.cos(angle);\\n            const tipY = midY + (ARROWHEAD_LENGTH / 2) * Math.sin(angle);\\n\\n            // Calculate base points (half arrowhead length backward from midpoint, spread by angle)\\n            const arrow1X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle - ARROWHEAD_ANGLE);\\n            const arrow1Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle - ARROWHEAD_ANGLE);\\n            const arrow2X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle + ARROWHEAD_ANGLE);\\n            const arrow2Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle + ARROWHEAD_ANGLE);\\n\\n            ctx.beginPath();\\n            ctx.moveTo(arrow1X, arrow1Y);\\n            ctx.lineTo(tipX, tipY);\\n            ctx.lineTo(arrow2X, arrow2Y);\\n            ctx.stroke();\\n\\n            // Reset line width for next path segment\\n            ctx.lineWidth = PATH_LINE_WIDTH;\\n          }\\n        }\\n      });\\n    }\\n\\n    // Draw labels if enabled\\n    if (showLabels) {\\n      ctx.fillStyle = foregroundColor;\\n      ctx.font = '1rem ' + api.getFont('default');\\n      ctx.textBaseline = 'middle';\\n\\n      scaledVertices.forEach(v =\u003e {\\n        // Calculate label position with smart offset\\n        const offset = calculateLabelOffset(v, cubeWidth);\\n        ctx.textAlign = offset.align || 'center';\\n        ctx.fillText(v.label, v.x + offset.x, v.y + offset.y);\\n      });\\n    }\\n  }\\n\\n  // Generate vertices for n-dimensional hypercube\\n  function generateVertices(n) {\\n    const count = Math.pow(2, n);\\n    const vertices = [];\\n    for (let i = 0; i \u003c count; i++) {\\n      const coords = [];\\n      const label = [];\\n      for (let j = 0; j \u003c n; j++) {\\n        const bit = (i \u003e\u003e j) \u0026 1;\\n        coords.push(bit);\\n        label.unshift(bit); // Reverse order for label\\n      }\\n      vertices.push({ coords, label: label.join('') });\\n    }\\n    return vertices;\\n  }\\n\\n  // Project vertex to 2D using the specified projection\\n  function projectVertex(vertex) {\\n    const [x = 0, y = 0, z = 0, w = 0] = vertex.coords;\\n    return {\\n      x: x + Z_X_MULTIPLIER * z + W_X_MULTIPLIER * w,\\n      y: y + Z_Y_MULTIPLIER * z + W_Y_MULTIPLIER * w,\\n      label: vertex.label\\n    };\\n  }\\n\\n  // Calculate bounds of projected vertices\\n  function calculateBounds(projected) {\\n    let minX = Infinity, maxX = -Infinity;\\n    let minY = Infinity, maxY = -Infinity;\\n    projected.forEach(p =\u003e {\\n      minX = Math.min(minX, p.x);\\n      maxX = Math.max(maxX, p.x);\\n      minY = Math.min(minY, p.y);\\n      maxY = Math.max(maxY, p.y);\\n    });\\n    return { minX, maxX, minY, maxY };\\n  }\\n\\n  // Generate edges (vertices that differ by exactly 1 bit)\\n  function generateEdges(vertices) {\\n    const edges = [];\\n    for (let i = 0; i \u003c vertices.length; i++) {\\n      for (let j = i + 1; j \u003c vertices.length; j++) {\\n        const diff = vertices[i].coords.filter((val, idx) =\u003e val !== vertices[j].coords[idx]).length;\\n        if (diff === 1) {\\n          edges.push([i, j]);\\n        }\\n      }\\n    }\\n    return edges;\\n  }\\n\\n  // Calculate smart label offset to avoid overlapping edges\\n  function calculateLabelOffset(vertex, cubeWidth) {\\n    // Label offset map based on dimensions and coordinates\\n    const labelOffsets = {\\n      1: {\\n        '0': { x: 0, y: cubeWidth * 0.2, align: 'center' },\\n        '1': { x: 0, y: cubeWidth * 0.2, align: 'center' },\\n      },\\n      2: {\\n        '00': { x: -cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'right' },\\n        '01': { x: cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'left' },\\n        '10': { x: -cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'right' },\\n        '11': { x: cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'left' },\\n      },\\n      3: {\\n        '000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\\n        '010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\\n        '100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\\n        '101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\\n        '110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\\n        '111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\\n      },\\n      4: {\\n        '0000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '0001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\\n        '0010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '0011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\\n        '0100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\\n        '0101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\\n        '0110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\\n        '0111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\\n        '1000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '1001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\\n        '1010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '1011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\\n        '1100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\\n        '1101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\\n        '1110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\\n        '1111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\\n      }\\n    };\\n\\n    const config = labelOffsets[dimensions]?.[vertex.label];\\n    return config;\\n  }\\n\\n  // Initial draw\\n  drawCube();\\n\\n  // Redraw on theme change\\n  api.onThemeChange(() =\u003e {\\n    drawCube();\\n  });\\n\\n  // Redraw on resize\\n  api.onResize(() =\u003e {\\n    drawCube();\\n  });\\n}\\n```\\n:::\\n\",\"dynamicBlocks\",[43,64,68,73,76,90,95,117,124,129,134],{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":51,\"_15\":61,\"_62\":63},\"type\",\"dynamic\",\"mode\",\"component\",\"componentId\",\"#hypercube-viz\",\"props\",{\"_52\":53,\"_54\":55},\"dimensions\",2,\"paths\",[56],[57,58,59,60,57],\"00\",\"01\",\"11\",\"10\",\"2D hypercube (square) with Hamiltonian cycle\",\"sourceFile\",\"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/graph-theory/traversing-the-hypercube.md\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":65,\"_15\":67,\"_62\":63},{\"_52\":66},3,\"3D hypercube (cube)\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":69,\"_15\":72,\"_62\":63},{\"_52\":53,\"_54\":70},[71],[57,58,59,60,57],\"Square with Hamiltonian cycle\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":74,\"_15\":75,\"_62\":63},{\"_52\":66},\"Cube constructed from two squares\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":77,\"_15\":89,\"_62\":63},{\"_52\":66,\"_54\":78},[79,84],[80,81,82,83],\"000\",\"001\",\"011\",\"010\",[85,86,87,88],\"110\",\"111\",\"101\",\"100\",\"Cube with paths on each square face\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":91,\"_15\":94,\"_62\":63},{\"_52\":66,\"_54\":92},[93],[80,81,82,83,85,86,87,88,80],\"Cube with complete Hamiltonian cycle\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":96,\"_15\":116,\"_62\":63},{\"_52\":97,\"_54\":98},4,[99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,100],\"0000\",\"0001\",\"0011\",\"0010\",\"0110\",\"0111\",\"0101\",\"0100\",\"1100\",\"1101\",\"1111\",\"1110\",\"1010\",\"1011\",\"1001\",\"1000\",\"4D hypercube with Hamiltonian cycle\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":118,\"_15\":123,\"_62\":63},{\"_52\":53,\"_119\":120,\"_54\":121},\"labels\",true,[122],[57,58,59,60,57],\"Labelled 2D hypercube with Hamiltonian cycle\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":125,\"_15\":128,\"_62\":63},{\"_52\":66,\"_119\":120,\"_54\":126},[127],[80,81,82,83,85,86,87,88,80],\"Labelled 3D hypercube with Hamiltonian cycle\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":130,\"_15\":133,\"_62\":63},{\"_52\":97,\"_119\":120,\"_54\":131},[132],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,100],\"Labelled 4D hypercube with Hamiltonian cycle\",{\"_44\":45,\"_46\":47,\"_48\":49,\"_50\":135,\"_15\":137,\"_62\":63},{\"_52\":136,\"_119\":120},1,\"1D hypercube (line)\",\"inlineComponents\",{\"_140\":141},\"hypercube-viz\",{\"_13\":140,\"_142\":143,\"_144\":145,\"_146\":147},\"code\",\"// Configuration constants\\nconst MAX_CUBE_WIDTH = 100;\\nconst LABEL_OFFSET = 25;\\nconst Z_X_MULTIPLIER = 0.3;\\nconst W_X_MULTIPLIER = 2;\\nconst Z_Y_MULTIPLIER = -0.3;\\nconst W_Y_MULTIPLIER = -0.8;\\nconst BASE_LINE_WIDTH = 2;\\nconst PATH_LINE_WIDTH = 4;\\nconst PATH_ARROW_LINE_WIDTH = 2;\\nconst VERTEX_RADIUS = 4;\\nconst PADDING = 20;\\nconst ARROWHEAD_LENGTH = 12;\\nconst ARROWHEAD_ANGLE = Math.PI / 3;\\n\\nfunction mount(options) {\\n  const { root, api, props } = options;\\n  const canvas = root.querySelector('#hypercube-canvas');\\n  const ctx = canvas.getContext('2d');\\n\\n  // Default props\\n  const dimensions = props.dimensions;\\n  const showLabels = props.labels ?? false;\\n  const paths = props.paths || [];\\n\\n  // Draw function that handles the actual rendering\\n  function drawCube() {\\n    const width = api.size.width;\\n\\n    // Generate all vertices for n-dimensional hypercube\\n    const vertices = generateVertices(dimensions);\\n\\n    // Calculate projection bounds\\n    const projected = vertices.map(v =\u003e projectVertex(v));\\n    const bounds = calculateBounds(projected);\\n\\n    // Calculate diagram dimensions in unit space (natural aspect ratio)\\n    const diagramWidth = bounds.maxX - bounds.minX;\\n    const diagramHeight = bounds.maxY - bounds.minY;\\n\\n    // Calculate label space needed by finding max offsets from calculateLabelOffset\\n    let labelHorizontalSpace = 0;\\n    let labelVerticalSpace = 0;\\n    if (showLabels) {\\n      // Estimate text dimensions (approximate based on 1rem font)\\n      const charWidth = 10; // Approximate width per character in pixels\\n      const textHeight = 16; // Approximate text height in pixels\\n      const maxLabelWidth = dimensions * charWidth; // e.g., \\\"1111\\\" is 4 chars for 4D\\n\\n      projected.forEach(vertex =\u003e {\\n        const offset = calculateLabelOffset(vertex, MAX_CUBE_WIDTH);\\n        // Add text dimensions to offset to get total space needed\\n        labelHorizontalSpace = Math.max(labelHorizontalSpace, Math.abs(offset.x) + maxLabelWidth / 2);\\n        labelVerticalSpace = Math.max(labelVerticalSpace, Math.abs(offset.y) + textHeight / 2);\\n      });\\n    }\\n\\n    // Calculate actual cube width in pixels (fit within available width, up to MAX_CUBE_WIDTH)\\n    const canvasWidth = width;\\n    const availableWidth = canvasWidth - 2 * labelHorizontalSpace;\\n    const cubeWidth = Math.min(MAX_CUBE_WIDTH, availableWidth / diagramWidth);\\n\\n    const canvasHeight = diagramHeight * cubeWidth + 2 * PADDING + 2 * labelVerticalSpace;\\n\\n    canvas.width = canvasWidth;\\n    canvas.height = canvasHeight;\\n\\n    // Clear canvas\\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\\n\\n    // Center offset (leave space for labels on both sides)\\n    const offsetX = labelHorizontalSpace + (availableWidth - diagramWidth * cubeWidth) / 2 - bounds.minX * cubeWidth;\\n    const offsetY = PADDING + labelVerticalSpace - bounds.minY * cubeWidth;\\n\\n    // Scale and translate projected vertices\\n    const scaledVertices = projected.map(p =\u003e ({\\n      x: p.x * cubeWidth + offsetX,\\n      y: p.y * cubeWidth + offsetY,\\n      label: p.label\\n    }));\\n\\n    // Get theme colors\\n    const mutedColor = api.getColor('muted-foreground');\\n    const foregroundColor = api.getColor('foreground');\\n\\n    // Draw base edges\\n    ctx.strokeStyle = mutedColor;\\n    ctx.lineWidth = BASE_LINE_WIDTH;\\n    const edges = generateEdges(vertices);\\n    edges.forEach(([i, j]) =\u003e {\\n      const v1 = scaledVertices[i];\\n      const v2 = scaledVertices[j];\\n      ctx.beginPath();\\n      ctx.moveTo(v1.x, v1.y);\\n      ctx.lineTo(v2.x, v2.y);\\n      ctx.stroke();\\n    });\\n\\n    // Draw vertices (before path lines so paths appear on top)\\n    ctx.fillStyle = mutedColor;\\n    scaledVertices.forEach(v =\u003e {\\n      ctx.beginPath();\\n      ctx.arc(v.x, v.y, VERTEX_RADIUS, 0, 2 * Math.PI);\\n      ctx.fill();\\n    });\\n\\n    // Draw path lines if provided (drawn on top of vertices)\\n    if (paths \u0026\u0026 paths.length \u003e 0) {\\n      ctx.strokeStyle = foregroundColor;\\n      ctx.lineWidth = PATH_LINE_WIDTH;\\n\\n      paths.forEach(path =\u003e {\\n        for (let i = 0; i \u003c path.length - 1; i++) {\\n          const idx1 = vertices.findIndex(v =\u003e v.label === path[i]);\\n          const idx2 = vertices.findIndex(v =\u003e v.label === path[i + 1]);\\n          if (idx1 !== -1 \u0026\u0026 idx2 !== -1) {\\n            const v1 = scaledVertices[idx1];\\n            const v2 = scaledVertices[idx2];\\n\\n            // Draw the path line\\n            ctx.lineWidth = PATH_LINE_WIDTH;\\n            ctx.beginPath();\\n            ctx.moveTo(v1.x, v1.y);\\n            ctx.lineTo(v2.x, v2.y);\\n            ctx.stroke();\\n\\n            // Draw arrowhead with center at midpoint\\n            ctx.lineWidth = PATH_ARROW_LINE_WIDTH;\\n            const midX = (v1.x + v2.x) / 2;\\n            const midY = (v1.y + v2.y) / 2;\\n\\n            // Calculate direction angle\\n            const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);\\n\\n            // Calculate tip position (half arrowhead length forward from midpoint)\\n            const tipX = midX + (ARROWHEAD_LENGTH / 2) * Math.cos(angle);\\n            const tipY = midY + (ARROWHEAD_LENGTH / 2) * Math.sin(angle);\\n\\n            // Calculate base points (half arrowhead length backward from midpoint, spread by angle)\\n            const arrow1X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle - ARROWHEAD_ANGLE);\\n            const arrow1Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle - ARROWHEAD_ANGLE);\\n            const arrow2X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle + ARROWHEAD_ANGLE);\\n            const arrow2Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle + ARROWHEAD_ANGLE);\\n\\n            ctx.beginPath();\\n            ctx.moveTo(arrow1X, arrow1Y);\\n            ctx.lineTo(tipX, tipY);\\n            ctx.lineTo(arrow2X, arrow2Y);\\n            ctx.stroke();\\n\\n            // Reset line width for next path segment\\n            ctx.lineWidth = PATH_LINE_WIDTH;\\n          }\\n        }\\n      });\\n    }\\n\\n    // Draw labels if enabled\\n    if (showLabels) {\\n      ctx.fillStyle = foregroundColor;\\n      ctx.font = '1rem ' + api.getFont('default');\\n      ctx.textBaseline = 'middle';\\n\\n      scaledVertices.forEach(v =\u003e {\\n        // Calculate label position with smart offset\\n        const offset = calculateLabelOffset(v, cubeWidth);\\n        ctx.textAlign = offset.align || 'center';\\n        ctx.fillText(v.label, v.x + offset.x, v.y + offset.y);\\n      });\\n    }\\n  }\\n\\n  // Generate vertices for n-dimensional hypercube\\n  function generateVertices(n) {\\n    const count = Math.pow(2, n);\\n    const vertices = [];\\n    for (let i = 0; i \u003c count; i++) {\\n      const coords = [];\\n      const label = [];\\n      for (let j = 0; j \u003c n; j++) {\\n        const bit = (i \u003e\u003e j) \u0026 1;\\n        coords.push(bit);\\n        label.unshift(bit); // Reverse order for label\\n      }\\n      vertices.push({ coords, label: label.join('') });\\n    }\\n    return vertices;\\n  }\\n\\n  // Project vertex to 2D using the specified projection\\n  function projectVertex(vertex) {\\n    const [x = 0, y = 0, z = 0, w = 0] = vertex.coords;\\n    return {\\n      x: x + Z_X_MULTIPLIER * z + W_X_MULTIPLIER * w,\\n      y: y + Z_Y_MULTIPLIER * z + W_Y_MULTIPLIER * w,\\n      label: vertex.label\\n    };\\n  }\\n\\n  // Calculate bounds of projected vertices\\n  function calculateBounds(projected) {\\n    let minX = Infinity, maxX = -Infinity;\\n    let minY = Infinity, maxY = -Infinity;\\n    projected.forEach(p =\u003e {\\n      minX = Math.min(minX, p.x);\\n      maxX = Math.max(maxX, p.x);\\n      minY = Math.min(minY, p.y);\\n      maxY = Math.max(maxY, p.y);\\n    });\\n    return { minX, maxX, minY, maxY };\\n  }\\n\\n  // Generate edges (vertices that differ by exactly 1 bit)\\n  function generateEdges(vertices) {\\n    const edges = [];\\n    for (let i = 0; i \u003c vertices.length; i++) {\\n      for (let j = i + 1; j \u003c vertices.length; j++) {\\n        const diff = vertices[i].coords.filter((val, idx) =\u003e val !== vertices[j].coords[idx]).length;\\n        if (diff === 1) {\\n          edges.push([i, j]);\\n        }\\n      }\\n    }\\n    return edges;\\n  }\\n\\n  // Calculate smart label offset to avoid overlapping edges\\n  function calculateLabelOffset(vertex, cubeWidth) {\\n    // Label offset map based on dimensions and coordinates\\n    const labelOffsets = {\\n      1: {\\n        '0': { x: 0, y: cubeWidth * 0.2, align: 'center' },\\n        '1': { x: 0, y: cubeWidth * 0.2, align: 'center' },\\n      },\\n      2: {\\n        '00': { x: -cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'right' },\\n        '01': { x: cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'left' },\\n        '10': { x: -cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'right' },\\n        '11': { x: cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'left' },\\n      },\\n      3: {\\n        '000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\\n        '010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\\n        '100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\\n        '101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\\n        '110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\\n        '111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\\n      },\\n      4: {\\n        '0000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '0001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\\n        '0010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '0011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\\n        '0100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\\n        '0101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\\n        '0110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\\n        '0111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\\n        '1000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '1001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\\n        '1010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\\n        '1011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\\n        '1100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\\n        '1101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\\n        '1110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\\n        '1111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\\n      }\\n    };\\n\\n    const config = labelOffsets[dimensions]?.[vertex.label];\\n    return config;\\n  }\\n\\n  // Initial draw\\n  drawCube();\\n\\n  // Redraw on theme change\\n  api.onThemeChange(() =\u003e {\\n    drawCube();\\n  });\\n\\n  // Redraw on resize\\n  api.onResize(() =\u003e {\\n    drawCube();\\n  });\\n}\",\"layout\",\"\u003ccanvas id=\\\"hypercube-canvas\\\"\u003e\u003c/canvas\u003e\",\"startLine\",189,\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>