[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","vanishing-square","puzzle",{"_7":8,"_11":12,"_37":38,"_39":40,"_41":42,"_68":69},"metadata",{"_13":14,"_15":16,"_17":18,"_20":21,"_24":25,"_27":28,"_29":30,"_31":30,"_32":33,"_34":35,"_36":35},"id","puzzle-71","title","Vanishing Square","concepts",[19],"geometry","difficulty",{"_17":22,"_23":22},"easy","reasoning","tags",[26],"has-solution","nextPuzzle","infinite-chocolate-bar","dateCreated","2026-02-05","lastUpdated","credit","Classic puzzle. Question and solution written by Puzzlestone Peak.\n","preview","The diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap,...","websitePreview","content","<p>The diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap, while the second does not. Where did the additional area go?</p>\n<p>Here’s the first arrangement:</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<p>And here’s the rearranged version without the gap:</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>Neither arrangement actually forms a true triangle. The “hypotenuse” isn’t a straight line in either case—it’s slightly bent, but the bend is so subtle that it’s hard to notice without close inspection.</p><p>The key is in the slopes of the two triangular pieces:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Big triangle: 3 units tall by 8 units wide, giving a slope of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mn>3</mn><mn>8</mn></mfrac><mo>=</mo><mn>0.375</mn></mrow><annotation>\\frac{3}{8} = 0.375</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.375</span></span></span></span>.\nSmall triangle: 2 units tall by 5 units wide, giving a slope of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac><mo>=</mo><mn>0.400</mn></mrow><annotation>\\frac{2}{5} = 0.400</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.400</span></span></span></span>.</p><p>Since <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mn>3</mn><mn>8</mn></mfrac><mo>≠</mo><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow><annotation>\\frac{3}{8} \\ne \\frac{2}{5}</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>, the two triangular pieces don’t have the same slope. When placed together, they create a very slight bend in what appears to be the hypotenuse.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"3\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>In the first arrangement, the “hypotenuse” bends very slightly inward, while in the second arrangement, it bends very slightly outward. This gap accounts for the 1 unit² of area difference.</p></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nThe diagrams below show two arrangements of the same four pieces. Both form a 13 by 5 right triangle. Yet the first arrangement contains a 1-square-unit gap, while the second does not. Where did the additional area go?\n\nHere’s the first arrangement:\n\n:::dynamic\n```yaml\ntitle: \"Triangle puzzle - Arrangement A with gap\"\nuse: '#vanishing-square-diagram'\nprops:\n  mode: arrangement-a\n```\n:::\n\nAnd here’s the rearranged version without the gap:\n\n:::dynamic\n```yaml\ntitle: \"Triangle puzzle - Arrangement B\"\nuse: '#vanishing-square-diagram'\nprops:\n  mode: arrangement-b\n```\n:::\n\n::::solution\nNeither arrangement actually forms a true triangle. The “hypotenuse” isn’t a straight line in either case—it’s slightly bent, but the bend is so subtle that it’s hard to notice without close inspection.\n\nThe key is in the slopes of the two triangular pieces:\n\n:::dynamic\n```yaml\ntitle: \"Slope comparison diagram\"\nuse: '#vanishing-square-diagram'\nprops:\n  mode: diagram\n```\n:::\n\nBig triangle: 3 units tall by 8 units wide, giving a slope of $\\frac{3}{8} = 0.375$.\nSmall triangle: 2 units tall by 5 units wide, giving a slope of $\\frac{2}{5} = 0.400$.\n\nSince $\\frac{3}{8} \\ne \\frac{2}{5}$, the two triangular pieces don’t have the same slope. When placed together, they create a very slight bend in what appears to be the hypotenuse.\n\n:::dynamic\n```yaml\ntitle: \"Overlay showing the true hypotenuse difference\"\nuse: '#vanishing-square-diagram'\nprops:\n  mode: solution\n```\n:::\n\nIn the first arrangement, the “hypotenuse” bends very slightly inward, while in the second arrangement, it bends very slightly outward. This gap accounts for the 1 unit² of area difference.\n::::\n\n\n:::component[vanishing-square-diagram]\n```js\nfunction draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext('2d');\n  const mode = props.mode;\n\n  // Padding constants per mode (in grid units)\n  const PADDING = {\n    'arrangement-a': { top: 1, bottom: 1, left: 1, right: 1 },\n    'arrangement-b': { top: 1, bottom: 1, left: 1, right: 1 },\n    'solution': { top: 1, bottom: 1, left: 1, right: 1 },\n    'diagram': { top: 1.5, bottom: 1.5, left: 1, right: 2 }\n  };\n  const pad = PADDING[mode];\n\n  // Content dimensions (in grid units)\n  const contentWidth = mode === 'diagram' ? 15 : 13;\n  const contentHeight = mode === 'diagram' ? 3 : 5;\n  const totalWidth = pad.left + contentWidth + pad.right;\n  const totalHeight = pad.top + contentHeight + pad.bottom;\n\n  // Responsive sizing (solution mode scales larger for visibility)\n  const maxGridSize = mode === 'solution' ? 60 : 40;\n  const gridSize = Math.min(width / totalWidth, maxGridSize);\n  const canvasWidth = totalWidth * gridSize;\n  const canvasHeight = totalHeight * gridSize;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Theme colors\n  const isDark = api.theme === 'dark';\n  const bgColor = api.getColor('background');\n  const gridColor = api.getColor(isDark ? 'neutral-200' : 'neutral-600');\n  const textColor = api.getColor('foreground');\n\n  // Piece colors - distinct palette hues, theme-adapted\n  const colorBigTri = api.getColor(isDark ? 'emerald-500' : 'emerald-600');\n  const colorSmallTri = api.getColor(isDark ? 'sky-500' : 'sky-600');\n  const colorBlock1 = api.getColor(isDark ? 'violet-500' : 'violet-600');\n  const colorBlock2 = api.getColor(isDark ? 'amber-500' : 'amber-500');\n\n  // Clear canvas\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, canvas.width, canvasHeight);\n\n  // Calculate pixel offsets from padding\n  const padX = pad.left * gridSize;\n  const padY = pad.top * gridSize;\n\n  if (mode === 'arrangement-a') {\n    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_A, padX, padY);\n  } else if (mode === 'arrangement-b') {\n    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_B, padX, padY);\n  } else if (mode === 'solution') {\n    drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY);\n  } else if (mode === 'diagram') {\n    drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY);\n  }\n}\n\n// Piece definitions (relative coordinates)\nconst PIECES = {\n  bigTriangle: [[8, 0], [8, 3], [0, 3]],\n  smallTriangle: [[5, 0], [5, 2], [0, 2]],\n  block1: [[0, 0], [5, 0], [5, 1], [2, 1], [2, 2], [0, 2]],\n  block2: [[0, 1], [2, 1], [2, 0], [5, 0], [5, 2], [0, 2]]\n};\n\n// Arrangement positions\nconst ARRANGEMENT_A = {\n  bigTriangle: [5, 0],\n  smallTriangle: [0, 3],\n  block1: [5, 3],\n  block2: [8, 3]\n};\n\nconst ARRANGEMENT_B = {\n  bigTriangle: [0, 2],\n  smallTriangle: [8, 0],\n  block1: [8, 2],\n  block2: [8, 3]\n};\n\nfunction drawPolygon(ctx, offsetX, offsetY, gridSize, points, color) {\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(offsetX + points[0][0] * gridSize, offsetY + points[0][1] * gridSize);\n  for (let i = 1; i < points.length; i++) {\n    ctx.lineTo(offsetX + points[i][0] * gridSize, offsetY + points[i][1] * gridSize);\n  }\n  ctx.closePath();\n  ctx.fill();\n}\n\nfunction drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, arrangement, padX, padY) {\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n\n  drawPolygon(ctx, padX + arrangement.bigTriangle[0] * gridSize, padY + arrangement.bigTriangle[1] * gridSize, gridSize, PIECES.bigTriangle, colorBigTri);\n  drawPolygon(ctx, padX + arrangement.smallTriangle[0] * gridSize, padY + arrangement.smallTriangle[1] * gridSize, gridSize, PIECES.smallTriangle, colorSmallTri);\n  drawPolygon(ctx, padX + arrangement.block1[0] * gridSize, padY + arrangement.block1[1] * gridSize, gridSize, PIECES.block1, colorBlock1);\n  drawPolygon(ctx, padX + arrangement.block2[0] * gridSize, padY + arrangement.block2[1] * gridSize, gridSize, PIECES.block2, colorBlock2);\n\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n}\n\nfunction drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY) {\n  const isDark = api.theme === 'dark';\n\n  // Draw grid first\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n\n  // Draw two translucent dotted triangles overlaid\n  ctx.setLineDash([5, 5]);\n  ctx.lineWidth = 3;\n  ctx.globalAlpha = 0.6;\n\n  // Arrangement A triangle: (0,5) -> (5,3) -> (13,0) (bends inward)\n  ctx.strokeStyle = api.getColor(isDark ? 'sky-400' : 'sky-600');\n  ctx.beginPath();\n  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left\n  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right\n  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right\n  ctx.lineTo(padX + 5 * gridSize, padY + 3 * gridSize);   // bend point\n  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)\n  ctx.stroke();\n\n  // Arrangement B triangle: (0,5) -> (8,2) -> (13,0) (bulges outward)\n  ctx.strokeStyle = api.getColor(isDark ? 'rose-400' : 'rose-600');\n  ctx.beginPath();\n  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left\n  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right\n  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right\n  ctx.lineTo(padX + 8 * gridSize, padY + 2 * gridSize);   // bend point\n  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)\n  ctx.stroke();\n\n  // Reset drawing state\n  ctx.setLineDash([]);\n  ctx.globalAlpha = 1.0;\n\n  // Redraw grid\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n}\n\nfunction drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY) {\n  // Draw big triangle with stroke\n  ctx.strokeStyle = api.getColor('foreground');\n  ctx.lineWidth = 2;\n  drawPolygon(ctx, padX, padY, gridSize, PIECES.bigTriangle, colorBigTri);\n  ctx.beginPath();\n  for (let i = 0; i < PIECES.bigTriangle.length; i++) {\n    const [x, y] = PIECES.bigTriangle[i];\n    if (i === 0) ctx.moveTo(padX + x * gridSize, padY + y * gridSize);\n    else ctx.lineTo(padX + x * gridSize, padY + y * gridSize);\n  }\n  ctx.closePath();\n  ctx.stroke();\n\n  // Draw small triangle with stroke (moved down 0.5 blocks)\n  const offsetX2 = padX + 10 * gridSize;\n  const offsetY2 = padY + 0.5 * gridSize;\n  drawPolygon(ctx, offsetX2, offsetY2, gridSize, PIECES.smallTriangle, colorSmallTri);\n  ctx.beginPath();\n  for (let i = 0; i < PIECES.smallTriangle.length; i++) {\n    const [x, y] = PIECES.smallTriangle[i];\n    if (i === 0) ctx.moveTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);\n    else ctx.lineTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);\n  }\n  ctx.closePath();\n  ctx.stroke();\n\n  // Labels (dimensions only, no slope calculations)\n  ctx.font = `bold ${Math.max(12, gridSize * 0.35)}px ${api.getFont('default')}`;\n  ctx.fillStyle = textColor;\n\n  // Big triangle labels\n  ctx.fillText('8', padX + 4 * gridSize, padY + 3 * gridSize + 18);\n  ctx.fillText('3', padX + 8 * gridSize + 8, padY + 1.5 * gridSize);\n\n  // Small triangle labels\n  ctx.fillText('5', offsetX2 + 2.5 * gridSize, offsetY2 + 2 * gridSize + 18);\n  ctx.fillText('2', offsetX2 + 5 * gridSize + 8, offsetY2 + gridSize);\n}\n\nfunction drawGrid(ctx, offsetX, offsetY, cols, rows, gridSize, gridColor) {\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 1;\n\n  for (let i = 0; i <= cols; i++) {\n    ctx.beginPath();\n    ctx.moveTo(offsetX + i * gridSize, offsetY);\n    ctx.lineTo(offsetX + i * gridSize, offsetY + rows * gridSize);\n    ctx.stroke();\n  }\n\n  for (let i = 0; i <= rows; i++) {\n    ctx.beginPath();\n    ctx.moveTo(offsetX, offsetY + i * gridSize);\n    ctx.lineTo(offsetX + cols * gridSize, offsetY + i * gridSize);\n    ctx.stroke();\n  }\n}\n```\n::::\n","dynamicBlocks",[43,56,60,64],{"_44":45,"_46":47,"_48":49,"_50":51,"_15":53,"_54":55},"type","dynamic","mode","component","componentId","#vanishing-square-diagram","props",{"_46":52},"arrangement-a","Triangle puzzle - Arrangement A with gap","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/vanishing-square.md",{"_44":45,"_46":47,"_48":49,"_50":57,"_15":59,"_54":55},{"_46":58},"arrangement-b","Triangle puzzle - Arrangement B",{"_44":45,"_46":47,"_48":49,"_50":61,"_15":63,"_54":55},{"_46":62},"diagram","Slope comparison diagram",{"_44":45,"_46":47,"_48":49,"_50":65,"_15":67,"_54":55},{"_46":66},"solution","Overlay showing the true hypotenuse difference","inlineComponents",{"_70":71},"vanishing-square-diagram",{"_13":70,"_72":73,"_74":75},"code","function draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext('2d');\n  const mode = props.mode;\n\n  // Padding constants per mode (in grid units)\n  const PADDING = {\n    'arrangement-a': { top: 1, bottom: 1, left: 1, right: 1 },\n    'arrangement-b': { top: 1, bottom: 1, left: 1, right: 1 },\n    'solution': { top: 1, bottom: 1, left: 1, right: 1 },\n    'diagram': { top: 1.5, bottom: 1.5, left: 1, right: 2 }\n  };\n  const pad = PADDING[mode];\n\n  // Content dimensions (in grid units)\n  const contentWidth = mode === 'diagram' ? 15 : 13;\n  const contentHeight = mode === 'diagram' ? 3 : 5;\n  const totalWidth = pad.left + contentWidth + pad.right;\n  const totalHeight = pad.top + contentHeight + pad.bottom;\n\n  // Responsive sizing (solution mode scales larger for visibility)\n  const maxGridSize = mode === 'solution' ? 60 : 40;\n  const gridSize = Math.min(width / totalWidth, maxGridSize);\n  const canvasWidth = totalWidth * gridSize;\n  const canvasHeight = totalHeight * gridSize;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  // Theme colors\n  const isDark = api.theme === 'dark';\n  const bgColor = api.getColor('background');\n  const gridColor = api.getColor(isDark ? 'neutral-200' : 'neutral-600');\n  const textColor = api.getColor('foreground');\n\n  // Piece colors - distinct palette hues, theme-adapted\n  const colorBigTri = api.getColor(isDark ? 'emerald-500' : 'emerald-600');\n  const colorSmallTri = api.getColor(isDark ? 'sky-500' : 'sky-600');\n  const colorBlock1 = api.getColor(isDark ? 'violet-500' : 'violet-600');\n  const colorBlock2 = api.getColor(isDark ? 'amber-500' : 'amber-500');\n\n  // Clear canvas\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, canvas.width, canvasHeight);\n\n  // Calculate pixel offsets from padding\n  const padX = pad.left * gridSize;\n  const padY = pad.top * gridSize;\n\n  if (mode === 'arrangement-a') {\n    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_A, padX, padY);\n  } else if (mode === 'arrangement-b') {\n    drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, ARRANGEMENT_B, padX, padY);\n  } else if (mode === 'solution') {\n    drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY);\n  } else if (mode === 'diagram') {\n    drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY);\n  }\n}\n\n// Piece definitions (relative coordinates)\nconst PIECES = {\n  bigTriangle: [[8, 0], [8, 3], [0, 3]],\n  smallTriangle: [[5, 0], [5, 2], [0, 2]],\n  block1: [[0, 0], [5, 0], [5, 1], [2, 1], [2, 2], [0, 2]],\n  block2: [[0, 1], [2, 1], [2, 0], [5, 0], [5, 2], [0, 2]]\n};\n\n// Arrangement positions\nconst ARRANGEMENT_A = {\n  bigTriangle: [5, 0],\n  smallTriangle: [0, 3],\n  block1: [5, 3],\n  block2: [8, 3]\n};\n\nconst ARRANGEMENT_B = {\n  bigTriangle: [0, 2],\n  smallTriangle: [8, 0],\n  block1: [8, 2],\n  block2: [8, 3]\n};\n\nfunction drawPolygon(ctx, offsetX, offsetY, gridSize, points, color) {\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(offsetX + points[0][0] * gridSize, offsetY + points[0][1] * gridSize);\n  for (let i = 1; i < points.length; i++) {\n    ctx.lineTo(offsetX + points[i][0] * gridSize, offsetY + points[i][1] * gridSize);\n  }\n  ctx.closePath();\n  ctx.fill();\n}\n\nfunction drawArrangement(ctx, gridSize, gridColor, colorBigTri, colorSmallTri, colorBlock1, colorBlock2, arrangement, padX, padY) {\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n\n  drawPolygon(ctx, padX + arrangement.bigTriangle[0] * gridSize, padY + arrangement.bigTriangle[1] * gridSize, gridSize, PIECES.bigTriangle, colorBigTri);\n  drawPolygon(ctx, padX + arrangement.smallTriangle[0] * gridSize, padY + arrangement.smallTriangle[1] * gridSize, gridSize, PIECES.smallTriangle, colorSmallTri);\n  drawPolygon(ctx, padX + arrangement.block1[0] * gridSize, padY + arrangement.block1[1] * gridSize, gridSize, PIECES.block1, colorBlock1);\n  drawPolygon(ctx, padX + arrangement.block2[0] * gridSize, padY + arrangement.block2[1] * gridSize, gridSize, PIECES.block2, colorBlock2);\n\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n}\n\nfunction drawSolution(ctx, gridSize, gridColor, textColor, api, padX, padY) {\n  const isDark = api.theme === 'dark';\n\n  // Draw grid first\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n\n  // Draw two translucent dotted triangles overlaid\n  ctx.setLineDash([5, 5]);\n  ctx.lineWidth = 3;\n  ctx.globalAlpha = 0.6;\n\n  // Arrangement A triangle: (0,5) -> (5,3) -> (13,0) (bends inward)\n  ctx.strokeStyle = api.getColor(isDark ? 'sky-400' : 'sky-600');\n  ctx.beginPath();\n  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left\n  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right\n  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right\n  ctx.lineTo(padX + 5 * gridSize, padY + 3 * gridSize);   // bend point\n  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)\n  ctx.stroke();\n\n  // Arrangement B triangle: (0,5) -> (8,2) -> (13,0) (bulges outward)\n  ctx.strokeStyle = api.getColor(isDark ? 'rose-400' : 'rose-600');\n  ctx.beginPath();\n  ctx.moveTo(padX + 0 * gridSize, padY + 5 * gridSize);   // bottom-left\n  ctx.lineTo(padX + 13 * gridSize, padY + 5 * gridSize);  // bottom-right\n  ctx.lineTo(padX + 13 * gridSize, padY + 0 * gridSize);  // top-right\n  ctx.lineTo(padX + 8 * gridSize, padY + 2 * gridSize);   // bend point\n  ctx.lineTo(padX + 0 * gridSize, padY + 5 * gridSize);   // back to start (hypotenuse)\n  ctx.stroke();\n\n  // Reset drawing state\n  ctx.setLineDash([]);\n  ctx.globalAlpha = 1.0;\n\n  // Redraw grid\n  drawGrid(ctx, padX, padY, 13, 5, gridSize, gridColor);\n}\n\nfunction drawDiagram(ctx, gridSize, gridColor, textColor, colorBigTri, colorSmallTri, api, padX, padY) {\n  // Draw big triangle with stroke\n  ctx.strokeStyle = api.getColor('foreground');\n  ctx.lineWidth = 2;\n  drawPolygon(ctx, padX, padY, gridSize, PIECES.bigTriangle, colorBigTri);\n  ctx.beginPath();\n  for (let i = 0; i < PIECES.bigTriangle.length; i++) {\n    const [x, y] = PIECES.bigTriangle[i];\n    if (i === 0) ctx.moveTo(padX + x * gridSize, padY + y * gridSize);\n    else ctx.lineTo(padX + x * gridSize, padY + y * gridSize);\n  }\n  ctx.closePath();\n  ctx.stroke();\n\n  // Draw small triangle with stroke (moved down 0.5 blocks)\n  const offsetX2 = padX + 10 * gridSize;\n  const offsetY2 = padY + 0.5 * gridSize;\n  drawPolygon(ctx, offsetX2, offsetY2, gridSize, PIECES.smallTriangle, colorSmallTri);\n  ctx.beginPath();\n  for (let i = 0; i < PIECES.smallTriangle.length; i++) {\n    const [x, y] = PIECES.smallTriangle[i];\n    if (i === 0) ctx.moveTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);\n    else ctx.lineTo(offsetX2 + x * gridSize, offsetY2 + y * gridSize);\n  }\n  ctx.closePath();\n  ctx.stroke();\n\n  // Labels (dimensions only, no slope calculations)\n  ctx.font = `bold ${Math.max(12, gridSize * 0.35)}px ${api.getFont('default')}`;\n  ctx.fillStyle = textColor;\n\n  // Big triangle labels\n  ctx.fillText('8', padX + 4 * gridSize, padY + 3 * gridSize + 18);\n  ctx.fillText('3', padX + 8 * gridSize + 8, padY + 1.5 * gridSize);\n\n  // Small triangle labels\n  ctx.fillText('5', offsetX2 + 2.5 * gridSize, offsetY2 + 2 * gridSize + 18);\n  ctx.fillText('2', offsetX2 + 5 * gridSize + 8, offsetY2 + gridSize);\n}\n\nfunction drawGrid(ctx, offsetX, offsetY, cols, rows, gridSize, gridColor) {\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 1;\n\n  for (let i = 0; i <= cols; i++) {\n    ctx.beginPath();\n    ctx.moveTo(offsetX + i * gridSize, offsetY);\n    ctx.lineTo(offsetX + i * gridSize, offsetY + rows * gridSize);\n    ctx.stroke();\n  }\n\n  for (let i = 0; i <= rows; i++) {\n    ctx.beginPath();\n    ctx.moveTo(offsetX, offsetY + i * gridSize);\n    ctx.lineTo(offsetX + cols * gridSize, offsetY + i * gridSize);\n    ctx.stroke();\n  }\n}","startLine",76]
