<!DOCTYPE html><html lang="en" class=""><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1LM5FNK1VX"></script><meta name="color-scheme" content="dark light"/><link rel="preload" href="/assets/poppins-400-cpxAROuN.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-500-C8OXljZJ.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-600-zEkxB9Mr.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/assets/poppins-700-Qrb0O0WB.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><title>Coins on a Table - Puzzlestone Peak</title><meta name="description" content="You and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put..."/><meta property="og:title" content="Coins on a Table - Puzzlestone Peak"/><meta property="og:description" content="You and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put..."/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Coins on a Table - Puzzlestone Peak"/><meta name="twitter:description" content="You and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put..."/><meta name="keywords" content="game-theory, medium, logic puzzle"/><link rel="modulepreload" href="/assets/manifest-83194972.js"/><link rel="modulepreload" href="/assets/entry.client-BQEHofJp.js"/><link rel="modulepreload" href="/assets/index-DIth0oIc.js"/><link rel="modulepreload" href="/assets/root-CWl7GNMN.js"/><link rel="modulepreload" href="/assets/Logo-BRp-LhsU.js"/><link rel="modulepreload" href="/assets/use-dark-mode-mdHJdo6o.js"/><link rel="modulepreload" href="/assets/card-fxtljBLB.js"/><link rel="modulepreload" href="/assets/NavHeightContext-BwIQMGhB.js"/><link rel="modulepreload" href="/assets/difficulty-types-Yz_I7Ggm.js"/><link rel="modulepreload" href="/assets/expeditionIndex-BBmHlwnS.js"/><link rel="modulepreload" href="/assets/puzzleIndex-Dp99oJog.js"/><link rel="modulepreload" href="/assets/loader-circle-liqmjHjk.js"/><link rel="modulepreload" href="/assets/puzzle-detail-CumiX9fv.js"/><link rel="modulepreload" href="/assets/useBack-BgNMwnEm.js"/><link rel="modulepreload" href="/assets/ItemCardList-C-RxMh7h.js"/><link rel="modulepreload" href="/assets/ErrorBoundary-B5mn_yui.js"/><link rel="modulepreload" href="/assets/chevron-down-BphMwi9y.js"/><script>
              (function initTheme() {
                if (localStorage.getItem('darkmode') === '1') {
                  document.documentElement.classList.add('dark');
                }
              })();
            </script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-1LM5FNK1VX');
            </script><link rel="stylesheet" href="/assets/root-BuMUS0hv.css"/><link rel="stylesheet" href="/assets/useBack-2KSn8t0Q.css"/></head><body><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><div class="min-h-screen bg-background"><nav class="sticky top-0 z-[1000] border-b border-border bg-card"><div class="container mx-auto px-6"><div class="flex h-16 items-center justify-between"><a class="flex items-center gap-3 text-nav-foreground no-underline" href="/" data-discover="true"><svg class="h-10 w-10 text-nav-foreground" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2211.37 2208.98" aria-label="Puzzlestone Peak Logo"><g><g><path fill="currentColor" d="M1108.28,0c649.77,5.24,1114.13,533.8,1102.89,1120-11.85,618.13-493.23,1100.61-1128,1088.81C450,2197-8.61,1690.25.12,1087.2,8.81,487.59,492.57,4.1,1108.28,0ZM121.13,1114.76c1.14,543.44,432.5,984.51,996.37,978.51,557.06-5.93,978-444.2,971.35-995.6C2082,528.37,1628.73,114,1095.67,118.84,573.44,123.64,121,538.05,121.13,1114.76Z"></path><path fill="currentColor" d="M2021.18,1304.81c-125.17-118.57-243.11-238.8-364.9-359.1-2.56,14.24,1.92,24,3.82,33.95,4.41,23.07,11.61,45.81,13.73,69.05,4,43.53,24.59,76.14,55.56,106,57.17,55,111.85,112.69,167.64,169.19,3.08,3.11,6.78,5.62,13.43,11.07l-29.92-94c24.62,13.75,40.06,32.2,57.87,47.59,20.91,18.06,40.77,37.34,61.77,55.28,8.84,7.54,10.58,14.7,7.36,25.8-20.06,69.13-47.63,135-81.34,198.6-9.36,17.65-14.91,9.53-22.48,0q-90.9-114.8-181.89-229.53-95.47-120.15-191.27-240c-1-1.26-2.64-2-7-5.25,9.72,71.9,28.35,139.3,37.91,208.53-107.81-169.7-206.63-344.59-311.28-516-9.22,3.51-3.87,12.13-10,16-12-7.35-18.72-20.06-27.45-30.66q-45.4-55.15-89.63-111.28c-9.15-11.66-14.16-9.84-23.87.14-12.63,13-13.15,24.45-6.86,40.56,17.11,43.76,35.07,87.25,48.64,132.33,1,3.28,1.72,6.64,3.84,14.9L1022.35,771.4l-2.78,2.64c13.51,22.36,26.89,44.8,40.55,67.06,24.58,40.09,49,80.27,74.21,120,6,9.48,6,15.92-1.51,24.54-28.26,32.31-55.84,65.21-83.61,97.95-15.86,18.69-15.92,18.85,1.06,35.86q114.7,114.87,229.51,229.63c2.84,2.84,5.41,6,11.73,12.92-46.79-8.28-88.16-19-132.09-25.8l298,291.64,3.93-2.17L1430.53,1306c23.59,34.58,44.25,64.91,65,95.22q123.36,180.63,251.43,357.94c1.38,1.9,2.39,4.13,4,5.79,13.32,13.77,9.47,24-4.25,35.81-47.75,41.22-98,78.83-151.9,111.65-8.1,4.94-16.34,5.41-25.27,5.45-104.54.45-203.43-26.94-300.81-61.29-107-37.74-210.39-84.76-315.67-126.92-149.26-59.78-302.65-102.49-463-118.55-55.13-5.53-110.43-4.65-165.7-3.63-9.28.18-16.45-.49-22-10-61.64-105.06-105-216.59-122.31-337.73-1.51-10.61,1.49-17.46,8.71-24.81q184.24-187.54,367.82-375.72c10-10.28,15.36-7.56,23.67,1.12,35.77,37.39,72.31,74.05,108,111.53,8.31,8.73,13.08,10.25,21.86.21Q871.5,787.48,1033.71,603.54c21-23.84,42.59-47.13,63.21-71.27,8.62-10.09,13.52-8.08,21.52,1q195.46,222.81,391.26,445.32c9.78,11.18,14.44,10.28,23.92.32,36.07-37.91,73.29-74.72,109.47-112.54,8.26-8.63,13.09-7.71,20.87.25q175.07,179.21,350.85,357.7c13.23,13.39,20.15,25.9,13.9,44.57C2025.39,1278.84,2024.3,1289.49,2021.18,1304.81ZM564.41,931.41c0,18.05-1.59,31,.28,43.31,7.16,47.25-7.05,85.12-43.68,116.5-15.75,13.5-32.89,30.56-38.74,49.32-11,35.33-14.27,73.08-20.87,110.49,8.29-1,11-6.85,14.51-11.08q84.69-101.51,174.52-198.49c8.71-9.46,11.86-16.15.08-25.48-9.14-7.24-16.56-16.62-24.93-24.86C606.56,972.43,587.42,953.86,564.41,931.41Z"></path><path fill="currentColor" d="M1258,2036.19c-156.22,31.67-307.68,13.84-456-37.14-128-44-242.37-111.53-346.16-205.19,33.78-3.18,62.72.36,91.57,3.41,177.71,18.78,340.49,86.11,502.68,155.25,63.74,27.17,127.88,53.3,193.63,75.29C1248.52,2029.42,1254.05,2029.85,1258,2036.19Z"></path><path fill="currentColor" d="M1461.61,671.32c.48-75.58,59.09-133.3,135-132.91,69.62.35,129.18,61.43,128.77,132.05-.43,74-59.91,132.06-134.66,131.48C1518.42,801.37,1461.15,743.42,1461.61,671.32Z"></path></g></g></svg><span class="text-[1.25rem] font-semibold leading-none">Puzzlestone Peak</span></a><div class="hidden items-center gap-6 md:flex"><ul class="flex items-center gap-8"><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="relative pb-2 text-[1rem] font-medium text-nav-foreground no-underline after:absolute after:bottom-0 after:left-0 after:h-[2px] after:w-0 after:bg-nav-foreground after:transition-all after:duration-200 hover:after:w-full" href="/progress" data-discover="true">Progress</a></li></ul><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div><button class="flex h-8 w-8 cursor-pointer flex-col justify-around border-none bg-transparent p-1 text-nav-foreground md:hidden" aria-label="Toggle mobile menu" aria-expanded="false" aria-controls="mobile-menu"><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span><span class="block h-[2px] w-full bg-current transition-all duration-300"></span></button></div></div></nav><div id="mobile-menu" class="fixed left-0 right-0 top-16 z-[999] border-b border-border bg-card shadow-lg transition-all duration-300 md:hidden pointer-events-none -translate-y-full opacity-0"><div class="px-6 pb-6 pt-4"><ul class="flex flex-col gap-3"><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/puzzles" data-discover="true">Puzzles</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/expeditions" data-discover="true">Expeditions</a></li><li><a class="flex items-center border-l-[3px] px-4 py-3.5 text-base font-medium text-nav-foreground no-underline transition-all duration-200 border-l-transparent hover:border-l-nav-foreground hover:bg-muted" href="/progress" data-discover="true">Progress</a></li></ul><div class="mt-4 flex justify-center border-t border-border pt-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 h-10 w-10 text-primary hover:bg-primary hover:text-background" aria-label="Light mode enabled. Switch to dark mode" aria-pressed="false"><div><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class=""><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></div></button></div></div></div><main><div class="container mx-auto px-4 py-6 max-w-4xl"><a class="inline-flex items-center text-link hover:text-link-hover hover:underline mb-6 cursor-pointer" href="/puzzles" data-discover="true">← Back</a><div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-4"><h1 class="text-4xl font-bold text-foreground sm:flex-1">Coins on a Table</h1><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><div class="space-y-4 border-b border-divider pb-6 mb-6"><div><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-medium text-difficulty-medium-foreground">Medium</span></div><div class="text-sm text-muted-foreground"><span>Created: <!-- -->November 2, 2025</span></div></div><div class="markdown-content prose max-w-none space-y-4"></div><div class="flex justify-center my-8"><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 cursor-pointer disabled:cursor-not-allowed disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border bg-background h-10 px-4 py-2 border-completed text-completed hover:bg-completed/20 gap-2 w-full sm:w-40" aria-label="Mark puzzle as solved">Mark as Solved</button></div><section class="mt-12"><h2 class="mb-6 text-xl font-bold text-foreground lg:text-2xl">Try These Next</h2><div class="overflow-hidden rounded-xl border border-border bg-card [&amp;&gt;*]:border-b [&amp;&gt;*]:border-border [&amp;&gt;*:last-child]:border-b-0"><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/the-camel-race" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">The Camel Race</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">An aging sheikh, nearing the end of his life, decides to leave his vast fortune to one of his two sons. To determine the heir, he devises a strange contest...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/chain-link-1" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Chain Link 1</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Five apprentices are working for you, the village’s master blacksmith. After three days of work, you now have to pay them each a gold chain of 3 links. You...</p></div></a><a class="relative block transition-colors no-underline p-4 hover:bg-muted" href="/puzzle/diagonals-on-a-cube" data-discover="true"><div class="flex items-center gap-3 mb-3"><span class="px-3 py-1 rounded-full text-sm font-medium bg-difficulty-easy text-difficulty-easy-foreground">Easy</span></div><div class="space-y-2"><h3 class="text-base font-semibold pr-8 text-foreground">Diagonals on a Cube</h3><p class="text-sm line-clamp-2 pr-8 text-muted-foreground">Two diagonal lines are drawn on a cube. What is the angle between these two lines?</p></div></a></div></section></div></main></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":false,"unstable_splitRouteModules":false,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-83194972.js";
import * as route0 from "/assets/root-CWl7GNMN.js";
import * as route1 from "/assets/puzzle-detail-CumiX9fv.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/puzzle-detail":route1};

import("/assets/entry.client-BQEHofJp.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_69\":-5,\"_70\":-5},\"loaderData\",{\"_3\":4},\"routes/puzzle-detail\",{\"_5\":6,\"_7\":8,\"_9\":10},\"status\",\"success\",\"slug\",\"coins-on-a-table\",\"puzzle\",{\"_7\":8,\"_11\":12,\"_36\":37,\"_38\":39,\"_40\":41,\"_59\":60},\"metadata\",{\"_13\":14,\"_15\":16,\"_17\":18,\"_19\":20,\"_22\":23,\"_26\":27,\"_28\":29,\"_30\":29,\"_31\":32,\"_33\":34,\"_35\":34},\"id\",\"puzzle-18\",\"title\",\"Coins on a Table\",\"difficulty\",\"medium\",\"concepts\",[21],\"game-theory\",\"tags\",[24,25],\"has-solution\",\"starter\",\"credit\",\"Classic game theory puzzle. Question and solution written by Puzzlestone Peak.\",\"dateCreated\",\"2025-11-02\",\"lastUpdated\",\"changelog\",\"2025-11-03: Added to Puzzlestone Peak\",\"preview\",\"You and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put...\",\"websitePreview\",\"content\",\"\u003cp\u003eYou and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put identically-sized coins on the table. The coins must be laid flat on the table without extending beyond the table or overlapping another coin. The first person who cannot put down a coin loses. Your friend lets you decide if you’d like to go first or second.\u003c/p\u003e\\n\u003cp\u003eShould you go first or second? And how do you ensure that you can win?\u003c/p\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eIf you choose to go first, there’s a strategy for you to guarantee a win.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block hint-block\\\" data-type=\\\"hint\\\"\u003e\u003csummary class=\\\"hint-label\\\"\u003eHint\u003c/summary\u003e\u003cdiv class=\\\"hint-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eThe table doesn’t have to be a circle for this strategy to work. In fact, it can be an oval, a square, a rectangle, or even a hexagon. However, this strategy would fail on a triangular table.\u003c/p\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdetails class=\\\"content-block solution-block\\\" data-type=\\\"solution\\\"\u003e\u003csummary class=\\\"solution-label\\\"\u003eSolution\u003c/summary\u003e\u003cdiv class=\\\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\\\"\u003e\u003cp\u003eYou should go first. On your first move, place a coin in the middle of the table. After your friend places a coin, place your coin on the opposite side.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"0\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003cp\u003eYour strategy involves keeping the table symmetric by a 180° rotation. This means that wherever your friend places a coin, there’ll be an identical spot on the opposite side where you can place a coin too. You can always guarantee a space for your coin until your friend runs out of spots to place his.\u003c/p\u003e\u003cp\u003eHowever, if a coin was placed over the midpoint of the table but offset to the side, then you can no longer keep the table symmetric, and the strategy breaks down. This is why you have to go first to place a coin in the exact middle of the table.\u003c/p\u003e\u003cp\u003eThis strategy works on any table with a shape that is symmetric by a 180° rotation. This is why it works on shapes like ovals, squares, rectangles, hexagons, and so on, but not shapes like triangles and pentagons.\u003c/p\u003e\u003cp\u003eYou can face off with this strategy as the second player. You play as the blue player against the red player.\u003c/p\u003e\u003cdiv class=\\\"dynamic-block-placeholder\\\" data-dynamic-block-id=\\\"1\\\" data-mode=\\\"component\\\"\u003e\u003cp class=\\\"text-muted-foreground text-sm\\\"\u003e[Interactive content: component mode]\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/details\u003e\\n\u003cdiv class=\\\"inline-component-definition\\\" style=\\\"display: none;\\\"\u003e\u003c/div\u003e\",\"rawContent\",\"\\nYou and a friend want to settle who is the smarter of you two with a game. The game is played on a circular table, with you and your friend taking turns to put identically-sized coins on the table. The coins must be laid flat on the table without extending beyond the table or overlapping another coin. The first person who cannot put down a coin loses. Your friend lets you decide if you’d like to go first or second.\\n\\nShould you go first or second? And how do you ensure that you can win?\\n\\n:::hint\\nIf you choose to go first, there’s a strategy for you to guarantee a win.\\n:::\\n\\n:::hint\\nThe table doesn’t have to be a circle for this strategy to work. In fact, it can be an oval, a square, a rectangle, or even a hexagon. However, this strategy would fail on a triangular table.\\n:::\\n\\n::::solution\\nYou should go first. On your first move, place a coin in the middle of the table. After your friend places a coin, place your coin on the opposite side.\\n\\n:::dynamic\\n```yaml\\ntitle: \\\"Visual demonstration of the winning strategy: Place center coin, then mirror opponent's moves\\\"\\nuse: '#diagram'\\nprops:\\n  mode: demo\\n```\\n:::\\n\\nYour strategy involves keeping the table symmetric by a 180° rotation. This means that wherever your friend places a coin, there’ll be an identical spot on the opposite side where you can place a coin too. You can always guarantee a space for your coin until your friend runs out of spots to place his.\\n\\nHowever, if a coin was placed over the midpoint of the table but offset to the side, then you can no longer keep the table symmetric, and the strategy breaks down. This is why you have to go first to place a coin in the exact middle of the table.\\n\\nThis strategy works on any table with a shape that is symmetric by a 180° rotation. This is why it works on shapes like ovals, squares, rectangles, hexagons, and so on, but not shapes like triangles and pentagons.\\n\\nYou can face off with this strategy as the second player. You play as the blue player against the red player.\\n\\n:::dynamic\\n```yaml\\ntitle: \\\"Interactive game: Try the strategy as the second player (blue) against the first player (red)\\\"\\nuse: '#diagram'\\nprops:\\n  mode: interactive\\n```\\n:::\\n::::\\n\\n:::component[diagram]\\n\\n```html\\n\u003cdiv id=\\\"container\\\" class=\\\"flex justify-center\\\"\u003e\\n  \u003cdiv class=\\\"relative w-fit\\\"\u003e\\n    \u003ccanvas id=\\\"table-canvas\\\"\u003e\u003c/canvas\u003e\\n    \u003ccanvas id=\\\"action-canvas\\\" class=\\\"hidden absolute inset-0\\\"\u003e\u003c/canvas\u003e\\n  \u003c/div\u003e\\n\u003c/div\u003e\\n\u003cdiv id=\\\"button-container\\\" class=\\\"flex justify-center gap-4 [\u0026:not(:empty)]:mt-4\\\"\u003e\\n\u003c/div\u003e\\n```\\n\\n```js\\nfunction mount(options) {\\n  const { props } = options;\\n  if (props.mode === 'demo') {\\n    mountDemo(options);\\n  } else if (props.mode === 'interactive') {\\n    mountInteractive(options);\\n  }\\n}\\n\\nfunction mountDemo(options) {\\n  const { api, props } = options;\\n  const containerElem = document.querySelector('#container');\\n\\n  function draw() {\\n    const containerWidth = containerElem.getBoundingClientRect().width;\\n    const width = Math.min(800, containerWidth);\\n\\n    const maxGap = 20;\\n    const gapRatio = 0.2; // for smaller screens, the gap should be this much of table diameter\\n    const TABLE_COUNT = 3;\\n    const gap = Math.min(maxGap, width / ((TABLE_COUNT + (TABLE_COUNT - 1) * gapRatio)) * gapRatio);\\n    const tableSize = (width - ((TABLE_COUNT - 1) * gap)) / TABLE_COUNT;\\n\\n    const canvas = document.querySelector('#table-canvas');\\n    canvas.width = width;\\n    canvas.height = tableSize;\\n    drawConfiguration({\\n      canvas,\\n      x: tableSize / 2 + (0 * (tableSize + gap)),\\n      y: tableSize / 2,\\n      radius: tableSize / 2,\\n      coins: [\\n        { player: 'A', theta: 0, radius: 0, new: true },\\n        // { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\\n        // { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\\n      ],\\n    });\\n    drawConfiguration({\\n      canvas,\\n      x: tableSize / 2 + (1 * (tableSize + gap)),\\n      y: tableSize / 2,\\n      radius: tableSize / 2,\\n      coins: [\\n        { player: 'A', theta: 0, radius: 0 },\\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5, new: true },\\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5, new: true },\\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\\n      ],\\n    });\\n    drawConfiguration({\\n      canvas,\\n      x: tableSize / 2 + (2 * (tableSize + gap)),\\n      y: tableSize / 2,\\n      radius: tableSize / 2,\\n      coins: [\\n        { player: 'A', theta: 0, radius: 0 },\\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\\n        { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\\n        { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\\n      ],\\n    });\\n  }\\n\\n  let prevWidth = 0;\\n  const observer = new ResizeObserver(entries =\u003e {\\n    const curWidth = containerElem.getBoundingClientRect().width;\\n    if (prevWidth === curWidth) { return; }\\n    prevWidth = curWidth;\\n    draw();\\n  });\\n  observer.observe(containerElem);\\n  draw();\\n}\\n\\nfunction mountInteractive(options) {\\n  const { api, props } = options;\\n  const containerElem = document.querySelector('#container');\\n  const buttonContainerElem = document.querySelector('#button-container');\\n\\n  const canvas = document.querySelector('#table-canvas');\\n  const actionCanvas = document.querySelector('#action-canvas');\\n  actionCanvas.classList.remove('hidden');\\n\\n  const firstCoin = { player: 'B', theta: 0, radius: 0, new: true };\\n  let coins = [firstCoin];\\n  let cursorCoin = undefined;\\n  let lastInvalidCoin = undefined;\\n\\n  const undoButton = api.ui.button({ label: 'Undo', variant: 'contained', color: 'primary' });\\n  const resetButton = api.ui.button({ label: 'Reset', variant: 'outlined', color: 'destructive' });\\n\\n  undoButton.classList.add(api.css('w-20'));\\n  resetButton.classList.add(api.css('w-20'));\\n\\n  buttonContainerElem.appendChild(undoButton);\\n  buttonContainerElem.appendChild(resetButton);\\n\\n  function updateControls() {\\n    undoButton.disabled = coins.length \u003c= 1;\\n    resetButton.disabled = coins.length == 1;\\n  }\\n\\n  function handleUndo() {\\n    if (coins.length \u003e 1) {\\n      coins = coins.slice(0, -2);\\n    }\\n    draw();\\n    updateControls();\\n  }\\n\\n  function handleReset() {\\n    coins = [firstCoin];\\n    draw();\\n    updateControls();\\n  }\\n\\n  undoButton.addEventListener('click', handleUndo);\\n  resetButton.addEventListener('click', handleReset);\\n  updateControls();\\n\\n  let containerWidth = 0;\\n  let canvasSize = 0;\\n  let tableSize = 0;\\n\\n  function draw() {\\n    containerWidth = containerElem.getBoundingClientRect().width;\\n    canvasSize = Math.min(400, containerWidth);\\n    tableSize = canvasSize / (1 + COIN_TO_TABLE_RATIO)\\n\\n    canvas.width = canvasSize;\\n    canvas.height = canvasSize;\\n    drawConfiguration({\\n      canvas,\\n      x: canvasSize / 2,\\n      y: canvasSize / 2,\\n      radius: tableSize / 2,\\n      coins,\\n    });\\n    drawAction();\\n  }\\n\\n  let prevWidth = 0;\\n  const observer = new ResizeObserver(entries =\u003e {\\n    const curWidth = containerElem.getBoundingClientRect().width;\\n    if (prevWidth === curWidth) { return; }\\n    prevWidth = curWidth;\\n    draw();\\n  });\\n  observer.observe(containerElem);\\n  draw();\\n\\n  function drawAction() {\\n    actionCanvas.width = canvasSize;\\n    actionCanvas.height = canvasSize;\\n    drawConfiguration({\\n      canvas: actionCanvas,\\n      x: canvasSize / 2,\\n      y: canvasSize / 2,\\n      radius: tableSize / 2,\\n      hideTable: true,\\n      coins: [\\n        ...(!!cursorCoin ? [cursorCoin] : []),\\n        ...(!!lastInvalidCoin ? [lastInvalidCoin] : []),\\n      ],\\n    });\\n  }\\n\\n  function checkValidMove(coordinates) {\\n    // Check if new coin is within table bounds\\n    if (!coordinates.withinTable || coordinates.radius \u003e 1) {\\n      return false;\\n    }\\n\\n    const tableRadius = tableSize / 2;\\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\\n    const maxCoinCenterDistance = tableRadius - coinRadius;\\n    const centerX = canvasSize / 2;\\n    const centerY = canvasSize / 2;\\n\\n    // Convert input coordinates to x/y\\n    const newCoinDistance = coordinates.radius * maxCoinCenterDistance;\\n    const newX = centerX + newCoinDistance * Math.cos(coordinates.theta);\\n    const newY = centerY + newCoinDistance * Math.sin(coordinates.theta);\\n\\n    // Check overlap with existing coins\\n    const minDistanceSquared = (2 * coinRadius) * (2 * coinRadius);\\n    for (const coin of coins) {\\n      const coinDistance = coin.radius * maxCoinCenterDistance;\\n      const coinX = centerX + coinDistance * Math.cos(coin.theta);\\n      const coinY = centerY + coinDistance * Math.sin(coin.theta);\\n\\n      const dx = newX - coinX;\\n      const dy = newY - coinY;\\n      const distanceSquared = dx * dx + dy * dy;\\n\\n      // Two coins overlap if distance between centers \u003c sum of radii\\n      // Compare squared distances to avoid expensive sqrt\\n      if (distanceSquared \u003c minDistanceSquared) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  function handleMoveCursorCoin(coordinates) {\\n    if (!coordinates || !coordinates.withinTable) {\\n      cursorCoin = undefined;\\n      drawAction();\\n      return;\\n    }\\n\\n    cursorCoin = {\\n      player: 'A',\\n      theta: coordinates.theta,\\n      radius: coordinates.radius,\\n      state: checkValidMove(coordinates) ? 'attempt' : 'invalid-attempt',\\n    };\\n    drawAction();\\n  }\\n\\n  function handleClick(coordinates) {\\n    if (!coordinates || !coordinates.withinTable) {\\n      cursorCoin = undefined;\\n      drawAction();\\n      return;\\n    }\\n    const isValidMove = checkValidMove(coordinates);\\n    if (!isValidMove) {\\n      cursorCoin = {\\n        player: 'A',\\n        theta: coordinates.theta,\\n        radius: coordinates.radius,\\n        state: 'error',\\n      };\\n      drawAction();\\n      return;\\n    }\\n\\n    coins.push({\\n      player: 'A',\\n      theta: coordinates.theta,\\n      radius: coordinates.radius,\\n    });\\n    coins.push({\\n      player: 'B',\\n      theta: (coordinates.theta + Math.PI) % (2 * Math.PI),\\n      radius: coordinates.radius,\\n    });\\n    draw();\\n    updateControls();\\n  }\\n\\n  function getCoordinatesFromEvent(e) {\\n    const rect = actionCanvas.getBoundingClientRect();\\n    const mouseX = e.clientX - rect.left;\\n    const mouseY = e.clientY - rect.top;\\n\\n    // Calculate position relative to table center\\n    const centerX = canvasSize / 2;\\n    const centerY = canvasSize / 2;\\n    const dx = mouseX - centerX;\\n    const dy = mouseY - centerY;\\n\\n    // Calculate polar coordinates\\n    const tableRadius = tableSize / 2;\\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\\n    const maxCoinCenterDistance = tableRadius - coinRadius;\\n\\n    const radius = Math.sqrt(dx * dx + dy * dy);\\n    const normalizedRadius = radius / maxCoinCenterDistance;\\n    const theta = Math.atan2(dy, dx);\\n    const withinTable = radius \u003c= tableRadius;\\n\\n    return { radius: normalizedRadius, theta, withinTable };\\n  }\\n\\n  // Add hover coordinate logging\\n  actionCanvas.addEventListener('mousemove', (e) =\u003e {\\n    const coords = getCoordinatesFromEvent(e);\\n    handleMoveCursorCoin(coords);\\n  });\\n\\n  actionCanvas.addEventListener('click', (e) =\u003e {\\n    const coords = getCoordinatesFromEvent(e);\\n    handleClick(coords);\\n  });\\n\\n  actionCanvas.addEventListener('mouseleave', () =\u003e {\\n    handleMoveCursorCoin(undefined);\\n  });\\n}\\n\\n// Configuration\\nconst OUTLINE_THICKNESS = 2;\\nconst COIN_TO_TABLE_RATIO = 1 / 8;\\n\\n// Colors\\nconst TABLE_FILL = '#8B6F47';\\nconst TABLE_OUTLINE = '#5C4A33';\\nconst PLAYER_A_FILL = '#3B82F6';\\nconst PLAYER_A_OUTLINE = '#1E40AF';\\nconst PLAYER_B_FILL = '#EF4444';\\nconst PLAYER_B_OUTLINE = '#991B1B';\\nconst NEW_COIN_OUTLINE_THICKNESS = OUTLINE_THICKNESS * 3;\\n\\n/**\\n * Draws a configuration of coins on a circular table\\n * @param {Object} params - Configuration parameters\\n * @param {HTMLCanvasElement} params.canvas - The canvas element to draw on\\n * @param {number} params.x - The x-coordinate of the table center\\n * @param {number} params.y - The y-coordinate of the table center\\n * @param {number} params.radius - The radius of the table in pixels\\n * @param {boolean} [params.hideTable] - Hides the table\\n * @param {Array\u003c{player: 'A'|'B', theta: number, radius: number, state?:  }\u003e} params.coins - Array of coin positions\\n *   - player: The player who placed the coin ('A' or 'B')\\n *   - theta: Angular position in radians (0 to 2π)\\n *   - radius: Normalized radial distance from center (0 to 1)\\n *   - state: `undefined` for no status | 'new' | 'attempt' | 'invalid-attempt' | 'error'\\n */\\nfunction drawConfiguration({ canvas, x, y, radius, hideTable, coins }) {\\n  const ctx = canvas.getContext('2d');\\n\\n  if (!hideTable) {\\n    // Draw table\\n    ctx.beginPath();\\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\\n    ctx.fillStyle = TABLE_FILL;\\n    ctx.fill();\\n\\n    // Draw table outline (inset by half thickness)\\n    ctx.beginPath();\\n    ctx.arc(x, y, Math.max(0, radius - OUTLINE_THICKNESS / 2), 0, Math.PI * 2);\\n    ctx.lineWidth = OUTLINE_THICKNESS;\\n    ctx.strokeStyle = TABLE_OUTLINE;\\n    ctx.stroke();\\n  }\\n\\n  // Draw coins\\n  const COIN_RADIUS = radius * COIN_TO_TABLE_RATIO;\\n  const maxCoinCenterDistance = radius - COIN_RADIUS;\\n\\n  for (const coin of coins) {\\n    // Calculate coin center position\\n    const coinCenterDistance = coin.radius * maxCoinCenterDistance;\\n    const coinCenterX = x + coinCenterDistance * Math.cos(coin.theta);\\n    const coinCenterY = y + coinCenterDistance * Math.sin(coin.theta);\\n\\n    // Choose colors based on player\\n    const fillColor = coin.player === 'A' ? PLAYER_A_FILL : PLAYER_B_FILL;\\n    const outlineColor = coin.player === 'A' ? PLAYER_A_OUTLINE : PLAYER_B_OUTLINE;\\n\\n    ctx.save();\\n\\n    if (coin.state === 'invalid-attempt' || coin.state === 'error') {\\n      ctx.globalAlpha = 0.4;\\n    }\\n\\n    // Draw coin\\n    ctx.beginPath();\\n    ctx.arc(coinCenterX, coinCenterY, COIN_RADIUS, 0, Math.PI * 2);\\n    ctx.fillStyle = fillColor;\\n    ctx.fill();\\n\\n    // Draw coin outline (inset by half thickness)\\n    ctx.beginPath();\\n    const outlineThickness = coin.state === 'new' ? NEW_COIN_OUTLINE_THICKNESS : OUTLINE_THICKNESS;\\n    ctx.arc(coinCenterX, coinCenterY, Math.max(0, COIN_RADIUS - outlineThickness / 2), 0, Math.PI * 2);\\n    ctx.lineWidth = outlineThickness;\\n    ctx.strokeStyle = outlineColor;\\n    ctx.stroke();\\n\\n    ctx.restore();\\n  }\\n}\\n```\",\"dynamicBlocks\",[42,55],{\"_43\":44,\"_45\":46,\"_47\":48,\"_49\":50,\"_15\":52,\"_53\":54},\"type\",\"dynamic\",\"mode\",\"component\",\"componentId\",\"#diagram\",\"props\",{\"_45\":51},\"demo\",\"Visual demonstration of the winning strategy: Place center coin, then mirror opponent's moves\",\"sourceFile\",\"/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/adversarial-games/coins-on-a-table.md\",{\"_43\":44,\"_45\":46,\"_47\":48,\"_49\":56,\"_15\":58,\"_53\":54},{\"_45\":57},\"interactive\",\"Interactive game: Try the strategy as the second player (blue) against the first player (red)\",\"inlineComponents\",{\"_61\":62},\"diagram\",{\"_13\":61,\"_63\":64,\"_65\":66,\"_67\":68},\"code\",\"function mount(options) {\\n  const { props } = options;\\n  if (props.mode === 'demo') {\\n    mountDemo(options);\\n  } else if (props.mode === 'interactive') {\\n    mountInteractive(options);\\n  }\\n}\\n\\nfunction mountDemo(options) {\\n  const { api, props } = options;\\n  const containerElem = document.querySelector('#container');\\n\\n  function draw() {\\n    const containerWidth = containerElem.getBoundingClientRect().width;\\n    const width = Math.min(800, containerWidth);\\n\\n    const maxGap = 20;\\n    const gapRatio = 0.2; // for smaller screens, the gap should be this much of table diameter\\n    const TABLE_COUNT = 3;\\n    const gap = Math.min(maxGap, width / ((TABLE_COUNT + (TABLE_COUNT - 1) * gapRatio)) * gapRatio);\\n    const tableSize = (width - ((TABLE_COUNT - 1) * gap)) / TABLE_COUNT;\\n\\n    const canvas = document.querySelector('#table-canvas');\\n    canvas.width = width;\\n    canvas.height = tableSize;\\n    drawConfiguration({\\n      canvas,\\n      x: tableSize / 2 + (0 * (tableSize + gap)),\\n      y: tableSize / 2,\\n      radius: tableSize / 2,\\n      coins: [\\n        { player: 'A', theta: 0, radius: 0, new: true },\\n        // { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\\n        // { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\\n      ],\\n    });\\n    drawConfiguration({\\n      canvas,\\n      x: tableSize / 2 + (1 * (tableSize + gap)),\\n      y: tableSize / 2,\\n      radius: tableSize / 2,\\n      coins: [\\n        { player: 'A', theta: 0, radius: 0 },\\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5, new: true },\\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5, new: true },\\n        // { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\\n        // { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\\n      ],\\n    });\\n    drawConfiguration({\\n      canvas,\\n      x: tableSize / 2 + (2 * (tableSize + gap)),\\n      y: tableSize / 2,\\n      radius: tableSize / 2,\\n      coins: [\\n        { player: 'A', theta: 0, radius: 0 },\\n        { player: 'B', theta: Math.PI * 0.3, radius: 0.5 },\\n        { player: 'A', theta: Math.PI + Math.PI * 0.3, radius: 0.5 },\\n        { player: 'B', theta: Math.PI * 1.6, radius: 0.9, new: true },\\n        { player: 'A', theta: Math.PI + Math.PI * 1.6, radius: 0.9, new: true },\\n      ],\\n    });\\n  }\\n\\n  let prevWidth = 0;\\n  const observer = new ResizeObserver(entries =\u003e {\\n    const curWidth = containerElem.getBoundingClientRect().width;\\n    if (prevWidth === curWidth) { return; }\\n    prevWidth = curWidth;\\n    draw();\\n  });\\n  observer.observe(containerElem);\\n  draw();\\n}\\n\\nfunction mountInteractive(options) {\\n  const { api, props } = options;\\n  const containerElem = document.querySelector('#container');\\n  const buttonContainerElem = document.querySelector('#button-container');\\n\\n  const canvas = document.querySelector('#table-canvas');\\n  const actionCanvas = document.querySelector('#action-canvas');\\n  actionCanvas.classList.remove('hidden');\\n\\n  const firstCoin = { player: 'B', theta: 0, radius: 0, new: true };\\n  let coins = [firstCoin];\\n  let cursorCoin = undefined;\\n  let lastInvalidCoin = undefined;\\n\\n  const undoButton = api.ui.button({ label: 'Undo', variant: 'contained', color: 'primary' });\\n  const resetButton = api.ui.button({ label: 'Reset', variant: 'outlined', color: 'destructive' });\\n\\n  undoButton.classList.add(api.css('w-20'));\\n  resetButton.classList.add(api.css('w-20'));\\n\\n  buttonContainerElem.appendChild(undoButton);\\n  buttonContainerElem.appendChild(resetButton);\\n\\n  function updateControls() {\\n    undoButton.disabled = coins.length \u003c= 1;\\n    resetButton.disabled = coins.length == 1;\\n  }\\n\\n  function handleUndo() {\\n    if (coins.length \u003e 1) {\\n      coins = coins.slice(0, -2);\\n    }\\n    draw();\\n    updateControls();\\n  }\\n\\n  function handleReset() {\\n    coins = [firstCoin];\\n    draw();\\n    updateControls();\\n  }\\n\\n  undoButton.addEventListener('click', handleUndo);\\n  resetButton.addEventListener('click', handleReset);\\n  updateControls();\\n\\n  let containerWidth = 0;\\n  let canvasSize = 0;\\n  let tableSize = 0;\\n\\n  function draw() {\\n    containerWidth = containerElem.getBoundingClientRect().width;\\n    canvasSize = Math.min(400, containerWidth);\\n    tableSize = canvasSize / (1 + COIN_TO_TABLE_RATIO)\\n\\n    canvas.width = canvasSize;\\n    canvas.height = canvasSize;\\n    drawConfiguration({\\n      canvas,\\n      x: canvasSize / 2,\\n      y: canvasSize / 2,\\n      radius: tableSize / 2,\\n      coins,\\n    });\\n    drawAction();\\n  }\\n\\n  let prevWidth = 0;\\n  const observer = new ResizeObserver(entries =\u003e {\\n    const curWidth = containerElem.getBoundingClientRect().width;\\n    if (prevWidth === curWidth) { return; }\\n    prevWidth = curWidth;\\n    draw();\\n  });\\n  observer.observe(containerElem);\\n  draw();\\n\\n  function drawAction() {\\n    actionCanvas.width = canvasSize;\\n    actionCanvas.height = canvasSize;\\n    drawConfiguration({\\n      canvas: actionCanvas,\\n      x: canvasSize / 2,\\n      y: canvasSize / 2,\\n      radius: tableSize / 2,\\n      hideTable: true,\\n      coins: [\\n        ...(!!cursorCoin ? [cursorCoin] : []),\\n        ...(!!lastInvalidCoin ? [lastInvalidCoin] : []),\\n      ],\\n    });\\n  }\\n\\n  function checkValidMove(coordinates) {\\n    // Check if new coin is within table bounds\\n    if (!coordinates.withinTable || coordinates.radius \u003e 1) {\\n      return false;\\n    }\\n\\n    const tableRadius = tableSize / 2;\\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\\n    const maxCoinCenterDistance = tableRadius - coinRadius;\\n    const centerX = canvasSize / 2;\\n    const centerY = canvasSize / 2;\\n\\n    // Convert input coordinates to x/y\\n    const newCoinDistance = coordinates.radius * maxCoinCenterDistance;\\n    const newX = centerX + newCoinDistance * Math.cos(coordinates.theta);\\n    const newY = centerY + newCoinDistance * Math.sin(coordinates.theta);\\n\\n    // Check overlap with existing coins\\n    const minDistanceSquared = (2 * coinRadius) * (2 * coinRadius);\\n    for (const coin of coins) {\\n      const coinDistance = coin.radius * maxCoinCenterDistance;\\n      const coinX = centerX + coinDistance * Math.cos(coin.theta);\\n      const coinY = centerY + coinDistance * Math.sin(coin.theta);\\n\\n      const dx = newX - coinX;\\n      const dy = newY - coinY;\\n      const distanceSquared = dx * dx + dy * dy;\\n\\n      // Two coins overlap if distance between centers \u003c sum of radii\\n      // Compare squared distances to avoid expensive sqrt\\n      if (distanceSquared \u003c minDistanceSquared) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  function handleMoveCursorCoin(coordinates) {\\n    if (!coordinates || !coordinates.withinTable) {\\n      cursorCoin = undefined;\\n      drawAction();\\n      return;\\n    }\\n\\n    cursorCoin = {\\n      player: 'A',\\n      theta: coordinates.theta,\\n      radius: coordinates.radius,\\n      state: checkValidMove(coordinates) ? 'attempt' : 'invalid-attempt',\\n    };\\n    drawAction();\\n  }\\n\\n  function handleClick(coordinates) {\\n    if (!coordinates || !coordinates.withinTable) {\\n      cursorCoin = undefined;\\n      drawAction();\\n      return;\\n    }\\n    const isValidMove = checkValidMove(coordinates);\\n    if (!isValidMove) {\\n      cursorCoin = {\\n        player: 'A',\\n        theta: coordinates.theta,\\n        radius: coordinates.radius,\\n        state: 'error',\\n      };\\n      drawAction();\\n      return;\\n    }\\n\\n    coins.push({\\n      player: 'A',\\n      theta: coordinates.theta,\\n      radius: coordinates.radius,\\n    });\\n    coins.push({\\n      player: 'B',\\n      theta: (coordinates.theta + Math.PI) % (2 * Math.PI),\\n      radius: coordinates.radius,\\n    });\\n    draw();\\n    updateControls();\\n  }\\n\\n  function getCoordinatesFromEvent(e) {\\n    const rect = actionCanvas.getBoundingClientRect();\\n    const mouseX = e.clientX - rect.left;\\n    const mouseY = e.clientY - rect.top;\\n\\n    // Calculate position relative to table center\\n    const centerX = canvasSize / 2;\\n    const centerY = canvasSize / 2;\\n    const dx = mouseX - centerX;\\n    const dy = mouseY - centerY;\\n\\n    // Calculate polar coordinates\\n    const tableRadius = tableSize / 2;\\n    const coinRadius = tableRadius * COIN_TO_TABLE_RATIO;\\n    const maxCoinCenterDistance = tableRadius - coinRadius;\\n\\n    const radius = Math.sqrt(dx * dx + dy * dy);\\n    const normalizedRadius = radius / maxCoinCenterDistance;\\n    const theta = Math.atan2(dy, dx);\\n    const withinTable = radius \u003c= tableRadius;\\n\\n    return { radius: normalizedRadius, theta, withinTable };\\n  }\\n\\n  // Add hover coordinate logging\\n  actionCanvas.addEventListener('mousemove', (e) =\u003e {\\n    const coords = getCoordinatesFromEvent(e);\\n    handleMoveCursorCoin(coords);\\n  });\\n\\n  actionCanvas.addEventListener('click', (e) =\u003e {\\n    const coords = getCoordinatesFromEvent(e);\\n    handleClick(coords);\\n  });\\n\\n  actionCanvas.addEventListener('mouseleave', () =\u003e {\\n    handleMoveCursorCoin(undefined);\\n  });\\n}\\n\\n// Configuration\\nconst OUTLINE_THICKNESS = 2;\\nconst COIN_TO_TABLE_RATIO = 1 / 8;\\n\\n// Colors\\nconst TABLE_FILL = '#8B6F47';\\nconst TABLE_OUTLINE = '#5C4A33';\\nconst PLAYER_A_FILL = '#3B82F6';\\nconst PLAYER_A_OUTLINE = '#1E40AF';\\nconst PLAYER_B_FILL = '#EF4444';\\nconst PLAYER_B_OUTLINE = '#991B1B';\\nconst NEW_COIN_OUTLINE_THICKNESS = OUTLINE_THICKNESS * 3;\\n\\n/**\\n * Draws a configuration of coins on a circular table\\n * @param {Object} params - Configuration parameters\\n * @param {HTMLCanvasElement} params.canvas - The canvas element to draw on\\n * @param {number} params.x - The x-coordinate of the table center\\n * @param {number} params.y - The y-coordinate of the table center\\n * @param {number} params.radius - The radius of the table in pixels\\n * @param {boolean} [params.hideTable] - Hides the table\\n * @param {Array\u003c{player: 'A'|'B', theta: number, radius: number, state?:  }\u003e} params.coins - Array of coin positions\\n *   - player: The player who placed the coin ('A' or 'B')\\n *   - theta: Angular position in radians (0 to 2π)\\n *   - radius: Normalized radial distance from center (0 to 1)\\n *   - state: `undefined` for no status | 'new' | 'attempt' | 'invalid-attempt' | 'error'\\n */\\nfunction drawConfiguration({ canvas, x, y, radius, hideTable, coins }) {\\n  const ctx = canvas.getContext('2d');\\n\\n  if (!hideTable) {\\n    // Draw table\\n    ctx.beginPath();\\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\\n    ctx.fillStyle = TABLE_FILL;\\n    ctx.fill();\\n\\n    // Draw table outline (inset by half thickness)\\n    ctx.beginPath();\\n    ctx.arc(x, y, Math.max(0, radius - OUTLINE_THICKNESS / 2), 0, Math.PI * 2);\\n    ctx.lineWidth = OUTLINE_THICKNESS;\\n    ctx.strokeStyle = TABLE_OUTLINE;\\n    ctx.stroke();\\n  }\\n\\n  // Draw coins\\n  const COIN_RADIUS = radius * COIN_TO_TABLE_RATIO;\\n  const maxCoinCenterDistance = radius - COIN_RADIUS;\\n\\n  for (const coin of coins) {\\n    // Calculate coin center position\\n    const coinCenterDistance = coin.radius * maxCoinCenterDistance;\\n    const coinCenterX = x + coinCenterDistance * Math.cos(coin.theta);\\n    const coinCenterY = y + coinCenterDistance * Math.sin(coin.theta);\\n\\n    // Choose colors based on player\\n    const fillColor = coin.player === 'A' ? PLAYER_A_FILL : PLAYER_B_FILL;\\n    const outlineColor = coin.player === 'A' ? PLAYER_A_OUTLINE : PLAYER_B_OUTLINE;\\n\\n    ctx.save();\\n\\n    if (coin.state === 'invalid-attempt' || coin.state === 'error') {\\n      ctx.globalAlpha = 0.4;\\n    }\\n\\n    // Draw coin\\n    ctx.beginPath();\\n    ctx.arc(coinCenterX, coinCenterY, COIN_RADIUS, 0, Math.PI * 2);\\n    ctx.fillStyle = fillColor;\\n    ctx.fill();\\n\\n    // Draw coin outline (inset by half thickness)\\n    ctx.beginPath();\\n    const outlineThickness = coin.state === 'new' ? NEW_COIN_OUTLINE_THICKNESS : OUTLINE_THICKNESS;\\n    ctx.arc(coinCenterX, coinCenterY, Math.max(0, COIN_RADIUS - outlineThickness / 2), 0, Math.PI * 2);\\n    ctx.lineWidth = outlineThickness;\\n    ctx.strokeStyle = outlineColor;\\n    ctx.stroke();\\n\\n    ctx.restore();\\n  }\\n}\",\"layout\",\"\u003cdiv id=\\\"container\\\" class=\\\"flex justify-center\\\"\u003e\\n  \u003cdiv class=\\\"relative w-fit\\\"\u003e\\n    \u003ccanvas id=\\\"table-canvas\\\"\u003e\u003c/canvas\u003e\\n    \u003ccanvas id=\\\"action-canvas\\\" class=\\\"hidden absolute inset-0\\\"\u003e\u003c/canvas\u003e\\n  \u003c/div\u003e\\n\u003c/div\u003e\\n\u003cdiv id=\\\"button-container\\\" class=\\\"flex justify-center gap-4 [\u0026:not(:empty)]:mt-4\\\"\u003e\\n\u003c/div\u003e\",\"startLine\",72,\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>