[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","equal-shape-cutting-2","puzzle",{"_7":8,"_11":12,"_38":39,"_40":41,"_42":43,"_64":65},"metadata",{"_13":14,"_15":16,"_17":18,"_19":20,"_23":24,"_26":27,"_28":29,"_30":29,"_31":32,"_33":34,"_35":36,"_37":36},"id","puzzle-draft-68","title","Equal Shape Cutting 2","difficulty","easy","concepts",[21,22],"geometry","self-similarity","tags",[25],"has-solution","credit","Classic geometry puzzle. Question and solution written by Puzzlestone Peak.","dateCreated","2026-02-02","lastUpdated","previousPuzzle","equal-shape-cutting-1","nextPuzzle","equal-shape-cutting-3","preview","Cut the L-shape into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.","websitePreview","content","<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<p>Cut the L-shape into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.</p>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>You can visualize the solution by dividing the L shape into squares:</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\n:::dynamic\n```yaml\ntitle: \"L-shaped figure\"\nuse: '#l-shape-diagram'\nprops:\n  mode: puzzle\n```\n:::\n\nCut the L-shape into 4 equal shapes of itself. The shapes can be rotated, but all 4 must be of the same size.\n\n::::solution\n\n:::dynamic\n```yaml\ntitle: \"L-shape divided into 4 smaller L-shapes\"\nuse: '#l-shape-diagram'\nprops:\n  mode: solution\n```\n:::\n\nYou can visualize the solution by dividing the L shape into squares:\n\n:::dynamic\n```yaml\ntitle: \"Grid structure of the L-shape\"\nuse: '#l-shape-diagram'\nprops:\n  mode: guides\n```\n:::\n\n::::\n\n\n:::component[l-shape-diagram]\n```js\nfunction draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  const lineWidth = 2;\n  const solutionLineWidth = 4;\n  const guideLineWidth = 0.5;\n  const maxSize = 350;\n  const imageSize = Math.min(width, maxSize);\n  const padding = 15;\n  const gridSize = 4;\n\n  // Mode: 'puzzle', 'solution', or 'guides'\n  const mode = props?.mode || 'puzzle';\n\n  const cellSize = (imageSize - 2 * padding) / gridSize;\n  const canvasHeight = cellSize * gridSize + 2 * padding;\n\n  canvas.width = imageSize;\n  canvas.height = canvasHeight;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Draw grid lines if mode is 'guides'\n  if (mode === 'guides') {\n    ctx.strokeStyle = api.getColor('foreground');\n    ctx.lineWidth = guideLineWidth;\n    ctx.beginPath();\n\n    // Draw vertical grid lines\n    for (let i = 1; i < gridSize; i++) {\n      const x = padding + cellSize * i;\n      // Only draw within the L-shape bounds\n      if (i <= 2) {\n        // Left part of L (top to bottom)\n        ctx.moveTo(x, padding);\n        ctx.lineTo(x, padding + cellSize * 4);\n      } else {\n        // Right part of L (from row 2 to bottom)\n        ctx.moveTo(x, padding + cellSize * 2);\n        ctx.lineTo(x, padding + cellSize * 4);\n      }\n    }\n\n    // Draw horizontal grid lines\n    for (let i = 1; i < gridSize; i++) {\n      const y = padding + cellSize * i;\n      if (i < 2) {\n        // Top part (left side only)\n        ctx.moveTo(padding, y);\n        ctx.lineTo(padding + cellSize * 2, y);\n      } else {\n        // Bottom part (full width)\n        ctx.moveTo(padding, y);\n        ctx.lineTo(padding + cellSize * 4, y);\n      }\n    }\n\n    ctx.stroke();\n  }\n\n  // Draw solution lines if mode is 'solution'\n  if (mode === 'solution' || mode === 'guides') {\n    ctx.beginPath();\n\n    // Horizontal division lines\n    ctx.moveTo(padding + cellSize, padding + cellSize);\n    ctx.lineTo(padding + cellSize * 2, padding + cellSize);\n    ctx.moveTo(padding, padding + cellSize * 2);\n    ctx.lineTo(padding + cellSize, padding + cellSize * 2);\n    ctx.moveTo(padding + cellSize, padding + cellSize * 3);\n    ctx.lineTo(padding + cellSize * 3, padding + cellSize * 3);\n\n    // Vertical division lines\n    ctx.moveTo(padding + cellSize, padding + cellSize);\n    ctx.lineTo(padding + cellSize, padding + cellSize * 3);\n    ctx.moveTo(padding + cellSize * 3, padding + cellSize * 2);\n    ctx.lineTo(padding + cellSize * 3, padding + cellSize * 3);\n    ctx.moveTo(padding + cellSize * 2, padding + cellSize * 3);\n    ctx.lineTo(padding + cellSize * 2, padding + cellSize * 4);\n\n    ctx.strokeStyle = api.getColor('primary');\n    ctx.lineWidth = solutionLineWidth;\n    ctx.lineCap = 'butt';\n    ctx.stroke();\n  }\n\n  // Draw main L-shape outline\n  ctx.beginPath();\n  ctx.moveTo(padding, padding);\n  ctx.lineTo(padding + cellSize * 2, padding);\n  ctx.lineTo(padding + cellSize * 2, padding + cellSize * 2);\n  ctx.lineTo(padding + cellSize * 4, padding + cellSize * 2);\n  ctx.lineTo(padding + cellSize * 4, padding + cellSize * 4);\n  ctx.lineTo(padding, padding + cellSize * 4);\n  ctx.closePath();\n  ctx.strokeStyle = api.getColor('foreground');\n  ctx.lineWidth = lineWidth;\n  ctx.lineCap = 'round';\n  ctx.stroke();\n}\n```\n:::\n","dynamicBlocks",[44,56,60],{"_45":46,"_47":48,"_49":50,"_51":52,"_15":53,"_54":55},"type","dynamic","mode","component","componentId","#l-shape-diagram","props",{"_47":9},"L-shaped figure","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/equal-shape-cutting/equal-shape-cutting-2.md",{"_45":46,"_47":48,"_49":50,"_51":57,"_15":59,"_54":55},{"_47":58},"solution","L-shape divided into 4 smaller L-shapes",{"_45":46,"_47":48,"_49":50,"_51":61,"_15":63,"_54":55},{"_47":62},"guides","Grid structure of the L-shape","inlineComponents",{"_66":67},"l-shape-diagram",{"_13":66,"_68":69,"_70":71},"code","function draw(options) {\n  const { canvas, api, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  const lineWidth = 2;\n  const solutionLineWidth = 4;\n  const guideLineWidth = 0.5;\n  const maxSize = 350;\n  const imageSize = Math.min(width, maxSize);\n  const padding = 15;\n  const gridSize = 4;\n\n  // Mode: 'puzzle', 'solution', or 'guides'\n  const mode = props?.mode || 'puzzle';\n\n  const cellSize = (imageSize - 2 * padding) / gridSize;\n  const canvasHeight = cellSize * gridSize + 2 * padding;\n\n  canvas.width = imageSize;\n  canvas.height = canvasHeight;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Draw grid lines if mode is 'guides'\n  if (mode === 'guides') {\n    ctx.strokeStyle = api.getColor('foreground');\n    ctx.lineWidth = guideLineWidth;\n    ctx.beginPath();\n\n    // Draw vertical grid lines\n    for (let i = 1; i < gridSize; i++) {\n      const x = padding + cellSize * i;\n      // Only draw within the L-shape bounds\n      if (i <= 2) {\n        // Left part of L (top to bottom)\n        ctx.moveTo(x, padding);\n        ctx.lineTo(x, padding + cellSize * 4);\n      } else {\n        // Right part of L (from row 2 to bottom)\n        ctx.moveTo(x, padding + cellSize * 2);\n        ctx.lineTo(x, padding + cellSize * 4);\n      }\n    }\n\n    // Draw horizontal grid lines\n    for (let i = 1; i < gridSize; i++) {\n      const y = padding + cellSize * i;\n      if (i < 2) {\n        // Top part (left side only)\n        ctx.moveTo(padding, y);\n        ctx.lineTo(padding + cellSize * 2, y);\n      } else {\n        // Bottom part (full width)\n        ctx.moveTo(padding, y);\n        ctx.lineTo(padding + cellSize * 4, y);\n      }\n    }\n\n    ctx.stroke();\n  }\n\n  // Draw solution lines if mode is 'solution'\n  if (mode === 'solution' || mode === 'guides') {\n    ctx.beginPath();\n\n    // Horizontal division lines\n    ctx.moveTo(padding + cellSize, padding + cellSize);\n    ctx.lineTo(padding + cellSize * 2, padding + cellSize);\n    ctx.moveTo(padding, padding + cellSize * 2);\n    ctx.lineTo(padding + cellSize, padding + cellSize * 2);\n    ctx.moveTo(padding + cellSize, padding + cellSize * 3);\n    ctx.lineTo(padding + cellSize * 3, padding + cellSize * 3);\n\n    // Vertical division lines\n    ctx.moveTo(padding + cellSize, padding + cellSize);\n    ctx.lineTo(padding + cellSize, padding + cellSize * 3);\n    ctx.moveTo(padding + cellSize * 3, padding + cellSize * 2);\n    ctx.lineTo(padding + cellSize * 3, padding + cellSize * 3);\n    ctx.moveTo(padding + cellSize * 2, padding + cellSize * 3);\n    ctx.lineTo(padding + cellSize * 2, padding + cellSize * 4);\n\n    ctx.strokeStyle = api.getColor('primary');\n    ctx.lineWidth = solutionLineWidth;\n    ctx.lineCap = 'butt';\n    ctx.stroke();\n  }\n\n  // Draw main L-shape outline\n  ctx.beginPath();\n  ctx.moveTo(padding, padding);\n  ctx.lineTo(padding + cellSize * 2, padding);\n  ctx.lineTo(padding + cellSize * 2, padding + cellSize * 2);\n  ctx.lineTo(padding + cellSize * 4, padding + cellSize * 2);\n  ctx.lineTo(padding + cellSize * 4, padding + cellSize * 4);\n  ctx.lineTo(padding, padding + cellSize * 4);\n  ctx.closePath();\n  ctx.strokeStyle = api.getColor('foreground');\n  ctx.lineWidth = lineWidth;\n  ctx.lineCap = 'round';\n  ctx.stroke();\n}","startLine",55]
