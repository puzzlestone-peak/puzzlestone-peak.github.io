[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","diagonals-on-a-cube","puzzle",{"_7":8,"_11":12,"_36":37,"_38":39,"_40":41,"_60":61},"metadata",{"_13":14,"_15":16,"_17":18,"_19":20,"_22":23,"_26":27,"_28":29,"_30":29,"_31":32,"_33":34,"_35":34},"id","puzzle-14","title","Diagonals on a Cube","difficulty","easy","concepts",[21],"geometry","tags",[24,25],"has-solution","starter","credit","Classic geometry puzzle. Question and solution written by Puzzlestone Peak.","dateCreated","2025-11-02","lastUpdated","changelog","2025-11-03: Added to Puzzlestone Peak","preview","Two diagonal lines are drawn on a cube. What is the angle between these two lines?","websitePreview","content","<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<p>Two diagonal lines are drawn on a cube. What is the angle between these two lines?</p>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>60</mn><mi>°</mi></mrow><annotation>60°</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">60°</span></span></span></span>.</p><p>Notice that if we connect a 3rd line between the ends of the other 2 lines, we form an equilateral triangle with angles of 60° on all sides.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\n:::dynamic\n```yaml\ntitle: \"3D cube with two diagonal face lines\"\nuse: '#cube-diagram'\nprops:\n  showSolution: false\n```\n:::\n\nTwo diagonal lines are drawn on a cube. What is the angle between these two lines?\n\n::::solution\n$60°$.\n\nNotice that if we connect a 3rd line between the ends of the other 2 lines, we form an equilateral triangle with angles of 60° on all sides.\n\n:::dynamic\n```yaml\ntitle: \"3D cube showing equilateral triangle formed by two diagonals and connecting edge\"\nuse: '#cube-diagram'\nprops:\n  showSolution: true\n```\n:::\n::::\n\n\n:::component[cube-diagram]\n```js\nfunction draw(options) {\n  const { canvas, api, theme, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  const lineWidth = 2;\n  const imageSize = Math.min(width, 300);\n  const yOffset = lineWidth / 2;\n  const xOffset = lineWidth / 2;\n\n  // Calculate cube size and positioning\n  const offsetPercent = 0.3;\n  const cubeSquareLength = (imageSize - lineWidth) / (1 + offsetPercent);\n  const backSquareOffset = cubeSquareLength * offsetPercent; // Diagonal offset for second square\n\n  canvas.width = imageSize;\n  canvas.height = imageSize;\n\n  // Get foreground color for solid lines\n  const foregroundColor = getComputedStyle(document.documentElement)\n    .getPropertyValue('--color-foreground').trim();\n  const fillColor = (() => {\n      const opacity = 0.2;\n      const tempEl = document.createElement('div');\n      tempEl.style.color = `color-mix(in srgb, var(--color-foreground) ${opacity * 100}%, transparent)`;\n      document.body.appendChild(tempEl);\n      const computed = getComputedStyle(tempEl).color;\n      document.body.removeChild(tempEl);\n      return computed;\n    })();\n\n  // Clear canvas\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Front square (bottom-left)\n  const front = {\n    bottomLeft: [xOffset, yOffset + cubeSquareLength + backSquareOffset],\n    bottomRight: [xOffset + cubeSquareLength, yOffset + cubeSquareLength + backSquareOffset],\n    topRight: [xOffset + cubeSquareLength, yOffset + backSquareOffset],\n    topLeft: [xOffset, yOffset + backSquareOffset],\n  };\n\n  // Back square (top-right, offset diagonally)\n  const back = {\n    bottomLeft: [xOffset + backSquareOffset, yOffset + cubeSquareLength],\n    bottomRight: [xOffset + cubeSquareLength + backSquareOffset, yOffset + cubeSquareLength],\n    topRight: [xOffset + cubeSquareLength + backSquareOffset, yOffset],\n    topLeft: [xOffset + backSquareOffset, yOffset]\n  };\n\n  ctx.lineCap = 'round';\n\n  // Draw filled faces first (back to front)\n\n  // Top face\n  ctx.fillStyle = fillColor;\n  ctx.beginPath();\n  ctx.moveTo(...front.topLeft);\n  ctx.lineTo(...front.topRight);\n  ctx.lineTo(...back.topRight);\n  ctx.lineTo(...back.topLeft);\n  ctx.closePath();\n  ctx.fill();\n\n  // Right face\n  ctx.fillStyle = fillColor;\n  ctx.beginPath();\n  ctx.moveTo(...front.topRight);\n  ctx.lineTo(...front.bottomRight);\n  ctx.lineTo(...back.bottomRight);\n  ctx.lineTo(...back.topRight);\n  ctx.closePath();\n  ctx.fill();\n\n  // Front face\n  ctx.fillStyle = fillColor;\n  ctx.beginPath();\n  ctx.moveTo(...front.bottomLeft);\n  ctx.lineTo(...front.bottomRight);\n  ctx.lineTo(...front.topRight);\n  ctx.lineTo(...front.topLeft);\n  ctx.closePath();\n  ctx.fill();\n\n  /**\n   * All lines to draw (order determines drawing order - reorder as needed for depth)\n   * @type {Array<[start: [number, number], end: [number, number], variant: string]>}\n   *\n   * Variants:\n   * - \"normal\": Solid line with foreground color (width 2)\n   * - \"dotted\": Dashed line with foreground color (width 2)\n   * - \"red\": Solid red line (width 3)\n   * - \"dotted-red\": Dashed red line (width 3)\n   * - \"not-drawn\": Skip drawing this line\n   */\n  const lines = [\n    [back.bottomLeft, back.bottomRight, \"dotted\"], // Back square - bottom\n    [back.bottomRight, back.topRight, \"normal\"], // Back square - right\n    [back.topRight, back.topLeft, \"normal\"], // Back square - top\n    [back.topLeft, back.bottomLeft, \"dotted\"], // Back square - left\n\n    [front.bottomLeft, back.bottomLeft, \"dotted\"], // Connecting line - bottom-left\n    [front.bottomRight, back.bottomRight, \"normal\"], // Connecting line - bottom-right\n    [front.topRight, back.topRight, \"normal\"], // Connecting line - top right\n    [front.topLeft, back.topLeft, \"normal\"], // Connecting line - top left\n\n    [front.bottomLeft, front.bottomRight, \"normal\"], // Front square - bottom\n    [front.bottomRight, front.topRight, \"normal\"], // Front square - right\n    [front.topRight, front.topLeft, \"normal\"], // Front square - top\n    [front.topLeft, front.bottomLeft, \"normal\"], // Front square - left\n\n    [front.topLeft, back.topRight, \"red\"],              // Diagonal 1: front top-left to back top-right\n    [front.topLeft, front.bottomRight, \"red\"],          // Diagonal 2: front top-left to front bottom-right\n    [front.bottomRight, back.topRight, (props && props.showSolution) ? \"red\" : \"not-drawn\"], // Diagonal 3: back top-right to front bottom-right\n  ];\n\n  // Draw all lines\n  lines.forEach(([start, end, variant]) => {\n    // Skip lines marked as not-drawn\n    if (variant === \"not-drawn\") {\n      return;\n    }\n\n    // Set style based on variant\n    if (variant === \"red\") {\n      ctx.strokeStyle = '#ff4444';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([]);\n    } else if (variant === \"dotted-red\") {\n      ctx.strokeStyle = '#ff4444';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([8, 8]);\n    } else if (variant === \"dotted\") {\n      ctx.strokeStyle = foregroundColor;\n      ctx.lineWidth = 2;\n      ctx.setLineDash([8, 8]);\n    } else {\n      // \"normal\"\n      ctx.strokeStyle = foregroundColor;\n      ctx.lineWidth = 2;\n      ctx.setLineDash([]);\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(...start);\n    ctx.lineTo(...end);\n    ctx.stroke();\n  });\n\n  // Reset line dash\n  ctx.setLineDash([]);\n}\n```\n:::\n","dynamicBlocks",[42,56],{"_43":44,"_45":46,"_47":48,"_49":50,"_15":53,"_54":55},"type","dynamic","mode","component","componentId","#cube-diagram","props",{"_51":52},"showSolution",false,"3D cube with two diagonal face lines","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/geometry/diagonals-on-a-cube.md",{"_43":44,"_45":46,"_47":48,"_49":57,"_15":59,"_54":55},{"_51":58},true,"3D cube showing equilateral triangle formed by two diagonals and connecting edge","inlineComponents",{"_62":63},"cube-diagram",{"_13":62,"_64":65,"_66":67},"code","function draw(options) {\n  const { canvas, api, theme, width, props } = options;\n  const ctx = canvas.getContext('2d');\n\n  const lineWidth = 2;\n  const imageSize = Math.min(width, 300);\n  const yOffset = lineWidth / 2;\n  const xOffset = lineWidth / 2;\n\n  // Calculate cube size and positioning\n  const offsetPercent = 0.3;\n  const cubeSquareLength = (imageSize - lineWidth) / (1 + offsetPercent);\n  const backSquareOffset = cubeSquareLength * offsetPercent; // Diagonal offset for second square\n\n  canvas.width = imageSize;\n  canvas.height = imageSize;\n\n  // Get foreground color for solid lines\n  const foregroundColor = getComputedStyle(document.documentElement)\n    .getPropertyValue('--color-foreground').trim();\n  const fillColor = (() => {\n      const opacity = 0.2;\n      const tempEl = document.createElement('div');\n      tempEl.style.color = `color-mix(in srgb, var(--color-foreground) ${opacity * 100}%, transparent)`;\n      document.body.appendChild(tempEl);\n      const computed = getComputedStyle(tempEl).color;\n      document.body.removeChild(tempEl);\n      return computed;\n    })();\n\n  // Clear canvas\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Front square (bottom-left)\n  const front = {\n    bottomLeft: [xOffset, yOffset + cubeSquareLength + backSquareOffset],\n    bottomRight: [xOffset + cubeSquareLength, yOffset + cubeSquareLength + backSquareOffset],\n    topRight: [xOffset + cubeSquareLength, yOffset + backSquareOffset],\n    topLeft: [xOffset, yOffset + backSquareOffset],\n  };\n\n  // Back square (top-right, offset diagonally)\n  const back = {\n    bottomLeft: [xOffset + backSquareOffset, yOffset + cubeSquareLength],\n    bottomRight: [xOffset + cubeSquareLength + backSquareOffset, yOffset + cubeSquareLength],\n    topRight: [xOffset + cubeSquareLength + backSquareOffset, yOffset],\n    topLeft: [xOffset + backSquareOffset, yOffset]\n  };\n\n  ctx.lineCap = 'round';\n\n  // Draw filled faces first (back to front)\n\n  // Top face\n  ctx.fillStyle = fillColor;\n  ctx.beginPath();\n  ctx.moveTo(...front.topLeft);\n  ctx.lineTo(...front.topRight);\n  ctx.lineTo(...back.topRight);\n  ctx.lineTo(...back.topLeft);\n  ctx.closePath();\n  ctx.fill();\n\n  // Right face\n  ctx.fillStyle = fillColor;\n  ctx.beginPath();\n  ctx.moveTo(...front.topRight);\n  ctx.lineTo(...front.bottomRight);\n  ctx.lineTo(...back.bottomRight);\n  ctx.lineTo(...back.topRight);\n  ctx.closePath();\n  ctx.fill();\n\n  // Front face\n  ctx.fillStyle = fillColor;\n  ctx.beginPath();\n  ctx.moveTo(...front.bottomLeft);\n  ctx.lineTo(...front.bottomRight);\n  ctx.lineTo(...front.topRight);\n  ctx.lineTo(...front.topLeft);\n  ctx.closePath();\n  ctx.fill();\n\n  /**\n   * All lines to draw (order determines drawing order - reorder as needed for depth)\n   * @type {Array<[start: [number, number], end: [number, number], variant: string]>}\n   *\n   * Variants:\n   * - \"normal\": Solid line with foreground color (width 2)\n   * - \"dotted\": Dashed line with foreground color (width 2)\n   * - \"red\": Solid red line (width 3)\n   * - \"dotted-red\": Dashed red line (width 3)\n   * - \"not-drawn\": Skip drawing this line\n   */\n  const lines = [\n    [back.bottomLeft, back.bottomRight, \"dotted\"], // Back square - bottom\n    [back.bottomRight, back.topRight, \"normal\"], // Back square - right\n    [back.topRight, back.topLeft, \"normal\"], // Back square - top\n    [back.topLeft, back.bottomLeft, \"dotted\"], // Back square - left\n\n    [front.bottomLeft, back.bottomLeft, \"dotted\"], // Connecting line - bottom-left\n    [front.bottomRight, back.bottomRight, \"normal\"], // Connecting line - bottom-right\n    [front.topRight, back.topRight, \"normal\"], // Connecting line - top right\n    [front.topLeft, back.topLeft, \"normal\"], // Connecting line - top left\n\n    [front.bottomLeft, front.bottomRight, \"normal\"], // Front square - bottom\n    [front.bottomRight, front.topRight, \"normal\"], // Front square - right\n    [front.topRight, front.topLeft, \"normal\"], // Front square - top\n    [front.topLeft, front.bottomLeft, \"normal\"], // Front square - left\n\n    [front.topLeft, back.topRight, \"red\"],              // Diagonal 1: front top-left to back top-right\n    [front.topLeft, front.bottomRight, \"red\"],          // Diagonal 2: front top-left to front bottom-right\n    [front.bottomRight, back.topRight, (props && props.showSolution) ? \"red\" : \"not-drawn\"], // Diagonal 3: back top-right to front bottom-right\n  ];\n\n  // Draw all lines\n  lines.forEach(([start, end, variant]) => {\n    // Skip lines marked as not-drawn\n    if (variant === \"not-drawn\") {\n      return;\n    }\n\n    // Set style based on variant\n    if (variant === \"red\") {\n      ctx.strokeStyle = '#ff4444';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([]);\n    } else if (variant === \"dotted-red\") {\n      ctx.strokeStyle = '#ff4444';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([8, 8]);\n    } else if (variant === \"dotted\") {\n      ctx.strokeStyle = foregroundColor;\n      ctx.lineWidth = 2;\n      ctx.setLineDash([8, 8]);\n    } else {\n      // \"normal\"\n      ctx.strokeStyle = foregroundColor;\n      ctx.lineWidth = 2;\n      ctx.setLineDash([]);\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(...start);\n    ctx.lineTo(...end);\n    ctx.stroke();\n  });\n\n  // Reset line dash\n  ctx.setLineDash([]);\n}","startLine",45]
