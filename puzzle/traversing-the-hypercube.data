[{"_1":2},"routes/puzzle-detail",{"_3":4},"data",{"_5":6,"_7":8,"_9":10},"status","success","slug","traversing-the-hypercube","puzzle",{"_7":8,"_11":12,"_37":38,"_39":40,"_41":42,"_138":139},"metadata",{"_13":14,"_15":16,"_17":18,"_19":20,"_24":25,"_27":28,"_29":30,"_31":30,"_32":33,"_34":35,"_36":35},"id","puzzle-1","title","Traversing the Hypercube","difficulty","hard","concepts",[21,22,23],"graph-theory","hamiltonian-cycles","induction","tags",[26],"has-solution","credit","Classic graph theory problem. Question and solution written by Puzzlestone Peak.","dateCreated","2025-11-02","lastUpdated","changelog","2025-11-03: Added to Puzzlestone Peak","preview","Ossarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if...","websitePreview","content","<p>Ossarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if it’s possible to travel along the edges of a hypercube, visiting each vertex exactly once before returning to the start. Such a path is called a Hamiltonian cycle.</p>\n<p>Excited with the challenge, he takes a look at a 2D hypercube, an object that you would call a “square”. Starting at a vertex, he easily finds that he can traverse the following path, visiting each vertex exactly once.</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"0\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<p>Up next is a 3D hypercube, or a “cube”. With more options at each vertex to navigate, it’s harder to find a route that traverses each vertex only once. Eventually, though, Ossarion-429 finds such a path. Can you find it too?</p>\n<div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"1\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div>\n<p>So far so good; we’ve managed to find a Hamiltonian cycle for 2D and 3D hypercubes. But how about a 4-dimensional hypercube? Or 5? As the number of vertices increases exponentially with the number of dimensions, would there ever be a hypercube that doesn’t have a Hamiltonian cycle? If yes, what’s the smallest n such that an n-dimensional hypercube has no such path? If not, prove it.</p>\n<details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Solution</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>All n-dimensional hypercubes have a Hamiltonian cycle, so long as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation>n \\geq 2</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, which I’ll explain why at the end.</p><p>Let’s prove this by considering the Hamiltonian cycle on a square.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"2\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>To construct a cube, we can place 2 squares side by side and connect their corresponding vertices.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"3\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Let’s draw a Hamiltonian cycle for each square, leaving out the last edge that brings us back to the start. We’ll also reverse the path on one of the squares.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"4\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>Note how we can connect the two paths together like this, forming a Hamiltonian cycle for a cube.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"5\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>We can perform a similar process to construct a Hamiltonian cycle for a 4D hypercube.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"6\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>This works for higher-dimensional hypercubes, proving that there will always be a Hamiltonian cycle.</p><details class=\"content-block solution-block\" data-type=\"solution\"><summary class=\"solution-label\">Extra Credit</summary><div class=\"solution-content markdown-content prose max-w-none px-4 py-4 space-y-4\"><p>There’s also another way to solve this. Let’s consider a cube with unit length, placing one corner at the origin of a 3D cartesian space. Its vertices will be at the coordinates (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), and (1, 1, 1). We then convert each vertex directly into binary by concatenating its coordinates. For instance, the vertex at (1, 0, 1) will be <code>101</code>. If you know what <a href=\"/expedition/gray-code\">Gray codes</a> are, you’ll notice that the Gray code sequence of length 3 will form our Hamiltonian cycle.</p><p><code>000</code>, <code>001</code>, <code>011</code>, <code>010</code>, <code>110</code>, <code>111</code>, <code>101</code>, <code>100</code>.</p><p>This works because of 3 facts:</p><ul>\n<li>Every number in the Gray code sequence is unique, ensuring that we will never visit the same vertex twice.</li>\n<li>2 vertices are connected by an edge if and only if their coordinates differ by 1 value. For instance, (0, 0, 0) is adjacent to (1, 0, 0), (0, 1, 0), and (0, 0, 1). Since each consecutive number in the Gray code differs by at most one value, the sequence forms a valid path on the cube.</li>\n<li>The last number in the Gray code sequence is only 1 bit off from the first number, allowing us to form a closed cycle.</li>\n</ul><p>Let’s take a look at our earlier examples with the binary labels.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"7\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"8\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"9\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>But why is this not true for <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation>n = 1</annotation></semantics></math></span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>? Well, that’s because a 1D hypercube is just a line.</p><div class=\"dynamic-block-placeholder\" data-dynamic-block-id=\"10\" data-mode=\"component\"><p class=\"text-muted-foreground text-sm\">[Interactive content: component mode]</p></div><p>The path that traverses each vertex once will start at one vertex, go to the other, then back, crossing the same edge twice. In graph theory, cycles cannot repeat a vertex or an edge, so we cannot consider this a Hamiltonian cycle based on this technicality.</p></div></details></div></details>\n<div class=\"inline-component-definition\" style=\"display: none;\"></div>","rawContent","\nOssarion-429 is a multi-dimensional being travelling across hypercubes of various dimensions. Bored and having nothing else to do, he wonders to himself if it’s possible to travel along the edges of a hypercube, visiting each vertex exactly once before returning to the start. Such a path is called a Hamiltonian cycle.\n\nExcited with the challenge, he takes a look at a 2D hypercube, an object that you would call a “square”. Starting at a vertex, he easily finds that he can traverse the following path, visiting each vertex exactly once.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"2D hypercube (square) with Hamiltonian cycle\"\nprops:\n  dimensions: 2\n  paths:\n    - [\"00\", \"01\", \"11\", \"10\", \"00\"]\n```\n:::\n\nUp next is a 3D hypercube, or a “cube”. With more options at each vertex to navigate, it’s harder to find a route that traverses each vertex only once. Eventually, though, Ossarion-429 finds such a path. Can you find it too?\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"3D hypercube (cube)\"\nprops:\n  dimensions: 3\n```\n:::\n\nSo far so good; we’ve managed to find a Hamiltonian cycle for 2D and 3D hypercubes. But how about a 4-dimensional hypercube? Or 5? As the number of vertices increases exponentially with the number of dimensions, would there ever be a hypercube that doesn’t have a Hamiltonian cycle? If yes, what’s the smallest n such that an n-dimensional hypercube has no such path? If not, prove it.\n\n:::::solution\nAll n-dimensional hypercubes have a Hamiltonian cycle, so long as $n \\geq 2$, which I’ll explain why at the end.\n\nLet’s prove this by considering the Hamiltonian cycle on a square.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Square with Hamiltonian cycle\"\nprops:\n  dimensions: 2\n  paths:\n    - [\"00\", \"01\", \"11\", \"10\", \"00\"]\n```\n:::\n\nTo construct a cube, we can place 2 squares side by side and connect their corresponding vertices.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Cube constructed from two squares\"\nprops:\n  dimensions: 3\n```\n:::\n\nLet’s draw a Hamiltonian cycle for each square, leaving out the last edge that brings us back to the start. We’ll also reverse the path on one of the squares.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Cube with paths on each square face\"\nprops:\n  dimensions: 3\n  paths:\n    - [\"000\", \"001\", \"011\", \"010\"]\n    - [\"110\", \"111\", \"101\", \"100\"]\n```\n:::\n\nNote how we can connect the two paths together like this, forming a Hamiltonian cycle for a cube.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Cube with complete Hamiltonian cycle\"\nprops:\n  dimensions: 3\n  paths:\n    - [\"000\", \"001\", \"011\", \"010\", \"110\", \"111\", \"101\", \"100\", \"000\"]\n```\n:::\n\nWe can perform a similar process to construct a Hamiltonian cycle for a 4D hypercube.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"4D hypercube with Hamiltonian cycle\"\nprops:\n  dimensions: 4\n  paths:\n    - [\"0000\", \"0001\", \"0011\", \"0010\", \"0110\", \"0111\", \"0101\", \"0100\", \"1100\", \"1101\", \"1111\", \"1110\", \"1010\", \"1011\", \"1001\", \"1000\", \"0000\"]\n```\n:::\n\nThis works for higher-dimensional hypercubes, proving that there will always be a Hamiltonian cycle.\n\n::::solution[Extra Credit]\n\nThere’s also another way to solve this. Let’s consider a cube with unit length, placing one corner at the origin of a 3D cartesian space. Its vertices will be at the coordinates (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), and (1, 1, 1). We then convert each vertex directly into binary by concatenating its coordinates. For instance, the vertex at (1, 0, 1) will be `101`. If you know what [Gray codes](expedition:gray-code) are, you’ll notice that the Gray code sequence of length 3 will form our Hamiltonian cycle.\n\n`000`, `001`, `011`, `010`, `110`, `111`, `101`, `100`.\n\nThis works because of 3 facts:\n- Every number in the Gray code sequence is unique, ensuring that we will never visit the same vertex twice.  \n- 2 vertices are connected by an edge if and only if their coordinates differ by 1 value. For instance, (0, 0, 0) is adjacent to (1, 0, 0), (0, 1, 0), and (0, 0, 1). Since each consecutive number in the Gray code differs by at most one value, the sequence forms a valid path on the cube.  \n- The last number in the Gray code sequence is only 1 bit off from the first number, allowing us to form a closed cycle.\n\nLet’s take a look at our earlier examples with the binary labels.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Labelled 2D hypercube with Hamiltonian cycle\"\nprops:\n  dimensions: 2\n  labels: true\n  paths:\n    - [\"00\", \"01\", \"11\", \"10\", \"00\"]\n```\n:::\n\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Labelled 3D hypercube with Hamiltonian cycle\"\nprops:\n  dimensions: 3\n  labels: true\n  paths:\n    - [\"000\", \"001\", \"011\", \"010\", \"110\", \"111\", \"101\", \"100\", \"000\"]\n```\n:::\n\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"Labelled 4D hypercube with Hamiltonian cycle\"\nprops:\n  dimensions: 4\n  labels: true\n  paths:\n    - [\"0000\", \"0001\", \"0011\", \"0010\", \"0110\", \"0111\", \"0101\", \"0100\", \"1100\", \"1101\", \"1111\", \"1110\", \"1010\", \"1011\", \"1001\", \"1000\", \"0000\"]\n```\n:::\n\nBut why is this not true for $n = 1$? Well, that’s because a 1D hypercube is just a line.\n\n:::dynamic\n```yaml\nuse: '#hypercube-viz'\ntitle: \"1D hypercube (line)\"\nprops:\n  dimensions: 1\n  labels: true\n```\n:::\n\nThe path that traverses each vertex once will start at one vertex, go to the other, then back, crossing the same edge twice. In graph theory, cycles cannot repeat a vertex or an edge, so we cannot consider this a Hamiltonian cycle based on this technicality.\n::::\n:::::\n\n:::component[hypercube-viz]\n```html\n<canvas id=\"hypercube-canvas\"></canvas>\n```\n\n```js\n// Configuration constants\nconst MAX_CUBE_WIDTH = 100;\nconst LABEL_OFFSET = 25;\nconst Z_X_MULTIPLIER = 0.3;\nconst W_X_MULTIPLIER = 2;\nconst Z_Y_MULTIPLIER = -0.3;\nconst W_Y_MULTIPLIER = -0.8;\nconst BASE_LINE_WIDTH = 2;\nconst PATH_LINE_WIDTH = 4;\nconst PATH_ARROW_LINE_WIDTH = 2;\nconst VERTEX_RADIUS = 4;\nconst PADDING = 20;\nconst ARROWHEAD_LENGTH = 12;\nconst ARROWHEAD_ANGLE = Math.PI / 3;\n\nfunction mount(options) {\n  const { root, api, props } = options;\n  const canvas = root.querySelector('#hypercube-canvas');\n  const ctx = canvas.getContext('2d');\n\n  // Default props\n  const dimensions = props.dimensions;\n  const showLabels = props.labels ?? false;\n  const paths = props.paths || [];\n\n  // Draw function that handles the actual rendering\n  function drawCube() {\n    const width = api.size.width;\n\n    // Generate all vertices for n-dimensional hypercube\n    const vertices = generateVertices(dimensions);\n\n    // Calculate projection bounds\n    const projected = vertices.map(v => projectVertex(v));\n    const bounds = calculateBounds(projected);\n\n    // Calculate diagram dimensions in unit space (natural aspect ratio)\n    const diagramWidth = bounds.maxX - bounds.minX;\n    const diagramHeight = bounds.maxY - bounds.minY;\n\n    // Calculate label space needed by finding max offsets from calculateLabelOffset\n    let labelHorizontalSpace = 0;\n    let labelVerticalSpace = 0;\n    if (showLabels) {\n      // Estimate text dimensions (approximate based on 1rem font)\n      const charWidth = 10; // Approximate width per character in pixels\n      const textHeight = 16; // Approximate text height in pixels\n      const maxLabelWidth = dimensions * charWidth; // e.g., \"1111\" is 4 chars for 4D\n\n      projected.forEach(vertex => {\n        const offset = calculateLabelOffset(vertex, MAX_CUBE_WIDTH);\n        // Add text dimensions to offset to get total space needed\n        labelHorizontalSpace = Math.max(labelHorizontalSpace, Math.abs(offset.x) + maxLabelWidth / 2);\n        labelVerticalSpace = Math.max(labelVerticalSpace, Math.abs(offset.y) + textHeight / 2);\n      });\n    }\n\n    // Calculate actual cube width in pixels (fit within available width, up to MAX_CUBE_WIDTH)\n    const canvasWidth = width;\n    const availableWidth = canvasWidth - 2 * labelHorizontalSpace;\n    const cubeWidth = Math.min(MAX_CUBE_WIDTH, availableWidth / diagramWidth);\n\n    const canvasHeight = diagramHeight * cubeWidth + 2 * PADDING + 2 * labelVerticalSpace;\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Center offset (leave space for labels on both sides)\n    const offsetX = labelHorizontalSpace + (availableWidth - diagramWidth * cubeWidth) / 2 - bounds.minX * cubeWidth;\n    const offsetY = PADDING + labelVerticalSpace - bounds.minY * cubeWidth;\n\n    // Scale and translate projected vertices\n    const scaledVertices = projected.map(p => ({\n      x: p.x * cubeWidth + offsetX,\n      y: p.y * cubeWidth + offsetY,\n      label: p.label\n    }));\n\n    // Get theme colors\n    const mutedColor = api.getColor('muted-foreground');\n    const foregroundColor = api.getColor('foreground');\n\n    // Draw base edges\n    ctx.strokeStyle = mutedColor;\n    ctx.lineWidth = BASE_LINE_WIDTH;\n    const edges = generateEdges(vertices);\n    edges.forEach(([i, j]) => {\n      const v1 = scaledVertices[i];\n      const v2 = scaledVertices[j];\n      ctx.beginPath();\n      ctx.moveTo(v1.x, v1.y);\n      ctx.lineTo(v2.x, v2.y);\n      ctx.stroke();\n    });\n\n    // Draw vertices (before path lines so paths appear on top)\n    ctx.fillStyle = mutedColor;\n    scaledVertices.forEach(v => {\n      ctx.beginPath();\n      ctx.arc(v.x, v.y, VERTEX_RADIUS, 0, 2 * Math.PI);\n      ctx.fill();\n    });\n\n    // Draw path lines if provided (drawn on top of vertices)\n    if (paths && paths.length > 0) {\n      ctx.strokeStyle = foregroundColor;\n      ctx.lineWidth = PATH_LINE_WIDTH;\n\n      paths.forEach(path => {\n        for (let i = 0; i < path.length - 1; i++) {\n          const idx1 = vertices.findIndex(v => v.label === path[i]);\n          const idx2 = vertices.findIndex(v => v.label === path[i + 1]);\n          if (idx1 !== -1 && idx2 !== -1) {\n            const v1 = scaledVertices[idx1];\n            const v2 = scaledVertices[idx2];\n\n            // Draw the path line\n            ctx.lineWidth = PATH_LINE_WIDTH;\n            ctx.beginPath();\n            ctx.moveTo(v1.x, v1.y);\n            ctx.lineTo(v2.x, v2.y);\n            ctx.stroke();\n\n            // Draw arrowhead with center at midpoint\n            ctx.lineWidth = PATH_ARROW_LINE_WIDTH;\n            const midX = (v1.x + v2.x) / 2;\n            const midY = (v1.y + v2.y) / 2;\n\n            // Calculate direction angle\n            const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);\n\n            // Calculate tip position (half arrowhead length forward from midpoint)\n            const tipX = midX + (ARROWHEAD_LENGTH / 2) * Math.cos(angle);\n            const tipY = midY + (ARROWHEAD_LENGTH / 2) * Math.sin(angle);\n\n            // Calculate base points (half arrowhead length backward from midpoint, spread by angle)\n            const arrow1X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle - ARROWHEAD_ANGLE);\n            const arrow1Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle - ARROWHEAD_ANGLE);\n            const arrow2X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle + ARROWHEAD_ANGLE);\n            const arrow2Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle + ARROWHEAD_ANGLE);\n\n            ctx.beginPath();\n            ctx.moveTo(arrow1X, arrow1Y);\n            ctx.lineTo(tipX, tipY);\n            ctx.lineTo(arrow2X, arrow2Y);\n            ctx.stroke();\n\n            // Reset line width for next path segment\n            ctx.lineWidth = PATH_LINE_WIDTH;\n          }\n        }\n      });\n    }\n\n    // Draw labels if enabled\n    if (showLabels) {\n      ctx.fillStyle = foregroundColor;\n      ctx.font = '1rem ' + api.getFont('default');\n      ctx.textBaseline = 'middle';\n\n      scaledVertices.forEach(v => {\n        // Calculate label position with smart offset\n        const offset = calculateLabelOffset(v, cubeWidth);\n        ctx.textAlign = offset.align || 'center';\n        ctx.fillText(v.label, v.x + offset.x, v.y + offset.y);\n      });\n    }\n  }\n\n  // Generate vertices for n-dimensional hypercube\n  function generateVertices(n) {\n    const count = Math.pow(2, n);\n    const vertices = [];\n    for (let i = 0; i < count; i++) {\n      const coords = [];\n      const label = [];\n      for (let j = 0; j < n; j++) {\n        const bit = (i >> j) & 1;\n        coords.push(bit);\n        label.unshift(bit); // Reverse order for label\n      }\n      vertices.push({ coords, label: label.join('') });\n    }\n    return vertices;\n  }\n\n  // Project vertex to 2D using the specified projection\n  function projectVertex(vertex) {\n    const [x = 0, y = 0, z = 0, w = 0] = vertex.coords;\n    return {\n      x: x + Z_X_MULTIPLIER * z + W_X_MULTIPLIER * w,\n      y: y + Z_Y_MULTIPLIER * z + W_Y_MULTIPLIER * w,\n      label: vertex.label\n    };\n  }\n\n  // Calculate bounds of projected vertices\n  function calculateBounds(projected) {\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    projected.forEach(p => {\n      minX = Math.min(minX, p.x);\n      maxX = Math.max(maxX, p.x);\n      minY = Math.min(minY, p.y);\n      maxY = Math.max(maxY, p.y);\n    });\n    return { minX, maxX, minY, maxY };\n  }\n\n  // Generate edges (vertices that differ by exactly 1 bit)\n  function generateEdges(vertices) {\n    const edges = [];\n    for (let i = 0; i < vertices.length; i++) {\n      for (let j = i + 1; j < vertices.length; j++) {\n        const diff = vertices[i].coords.filter((val, idx) => val !== vertices[j].coords[idx]).length;\n        if (diff === 1) {\n          edges.push([i, j]);\n        }\n      }\n    }\n    return edges;\n  }\n\n  // Calculate smart label offset to avoid overlapping edges\n  function calculateLabelOffset(vertex, cubeWidth) {\n    // Label offset map based on dimensions and coordinates\n    const labelOffsets = {\n      1: {\n        '0': { x: 0, y: cubeWidth * 0.2, align: 'center' },\n        '1': { x: 0, y: cubeWidth * 0.2, align: 'center' },\n      },\n      2: {\n        '00': { x: -cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'right' },\n        '01': { x: cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'left' },\n        '10': { x: -cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'right' },\n        '11': { x: cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'left' },\n      },\n      3: {\n        '000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\n        '010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\n        '100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\n        '101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\n        '110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\n        '111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\n      },\n      4: {\n        '0000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '0001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\n        '0010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '0011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\n        '0100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\n        '0101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\n        '0110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\n        '0111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\n        '1000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '1001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\n        '1010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '1011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\n        '1100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\n        '1101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\n        '1110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\n        '1111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\n      }\n    };\n\n    const config = labelOffsets[dimensions]?.[vertex.label];\n    return config;\n  }\n\n  // Initial draw\n  drawCube();\n\n  // Redraw on theme change\n  api.onThemeChange(() => {\n    drawCube();\n  });\n\n  // Redraw on resize\n  api.onResize(() => {\n    drawCube();\n  });\n}\n```\n:::\n","dynamicBlocks",[43,64,68,73,76,90,95,117,124,129,134],{"_44":45,"_46":47,"_48":49,"_50":51,"_15":61,"_62":63},"type","dynamic","mode","component","componentId","#hypercube-viz","props",{"_52":53,"_54":55},"dimensions",2,"paths",[56],[57,58,59,60,57],"00","01","11","10","2D hypercube (square) with Hamiltonian cycle","sourceFile","/home/runner/work/puzzlestone-peak/puzzlestone-peak/apps/web/content/puzzles/graph-theory/traversing-the-hypercube.md",{"_44":45,"_46":47,"_48":49,"_50":65,"_15":67,"_62":63},{"_52":66},3,"3D hypercube (cube)",{"_44":45,"_46":47,"_48":49,"_50":69,"_15":72,"_62":63},{"_52":53,"_54":70},[71],[57,58,59,60,57],"Square with Hamiltonian cycle",{"_44":45,"_46":47,"_48":49,"_50":74,"_15":75,"_62":63},{"_52":66},"Cube constructed from two squares",{"_44":45,"_46":47,"_48":49,"_50":77,"_15":89,"_62":63},{"_52":66,"_54":78},[79,84],[80,81,82,83],"000","001","011","010",[85,86,87,88],"110","111","101","100","Cube with paths on each square face",{"_44":45,"_46":47,"_48":49,"_50":91,"_15":94,"_62":63},{"_52":66,"_54":92},[93],[80,81,82,83,85,86,87,88,80],"Cube with complete Hamiltonian cycle",{"_44":45,"_46":47,"_48":49,"_50":96,"_15":116,"_62":63},{"_52":97,"_54":98},4,[99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,100],"0000","0001","0011","0010","0110","0111","0101","0100","1100","1101","1111","1110","1010","1011","1001","1000","4D hypercube with Hamiltonian cycle",{"_44":45,"_46":47,"_48":49,"_50":118,"_15":123,"_62":63},{"_52":53,"_119":120,"_54":121},"labels",true,[122],[57,58,59,60,57],"Labelled 2D hypercube with Hamiltonian cycle",{"_44":45,"_46":47,"_48":49,"_50":125,"_15":128,"_62":63},{"_52":66,"_119":120,"_54":126},[127],[80,81,82,83,85,86,87,88,80],"Labelled 3D hypercube with Hamiltonian cycle",{"_44":45,"_46":47,"_48":49,"_50":130,"_15":133,"_62":63},{"_52":97,"_119":120,"_54":131},[132],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,100],"Labelled 4D hypercube with Hamiltonian cycle",{"_44":45,"_46":47,"_48":49,"_50":135,"_15":137,"_62":63},{"_52":136,"_119":120},1,"1D hypercube (line)","inlineComponents",{"_140":141},"hypercube-viz",{"_13":140,"_142":143,"_144":145,"_146":147},"code","// Configuration constants\nconst MAX_CUBE_WIDTH = 100;\nconst LABEL_OFFSET = 25;\nconst Z_X_MULTIPLIER = 0.3;\nconst W_X_MULTIPLIER = 2;\nconst Z_Y_MULTIPLIER = -0.3;\nconst W_Y_MULTIPLIER = -0.8;\nconst BASE_LINE_WIDTH = 2;\nconst PATH_LINE_WIDTH = 4;\nconst PATH_ARROW_LINE_WIDTH = 2;\nconst VERTEX_RADIUS = 4;\nconst PADDING = 20;\nconst ARROWHEAD_LENGTH = 12;\nconst ARROWHEAD_ANGLE = Math.PI / 3;\n\nfunction mount(options) {\n  const { root, api, props } = options;\n  const canvas = root.querySelector('#hypercube-canvas');\n  const ctx = canvas.getContext('2d');\n\n  // Default props\n  const dimensions = props.dimensions;\n  const showLabels = props.labels ?? false;\n  const paths = props.paths || [];\n\n  // Draw function that handles the actual rendering\n  function drawCube() {\n    const width = api.size.width;\n\n    // Generate all vertices for n-dimensional hypercube\n    const vertices = generateVertices(dimensions);\n\n    // Calculate projection bounds\n    const projected = vertices.map(v => projectVertex(v));\n    const bounds = calculateBounds(projected);\n\n    // Calculate diagram dimensions in unit space (natural aspect ratio)\n    const diagramWidth = bounds.maxX - bounds.minX;\n    const diagramHeight = bounds.maxY - bounds.minY;\n\n    // Calculate label space needed by finding max offsets from calculateLabelOffset\n    let labelHorizontalSpace = 0;\n    let labelVerticalSpace = 0;\n    if (showLabels) {\n      // Estimate text dimensions (approximate based on 1rem font)\n      const charWidth = 10; // Approximate width per character in pixels\n      const textHeight = 16; // Approximate text height in pixels\n      const maxLabelWidth = dimensions * charWidth; // e.g., \"1111\" is 4 chars for 4D\n\n      projected.forEach(vertex => {\n        const offset = calculateLabelOffset(vertex, MAX_CUBE_WIDTH);\n        // Add text dimensions to offset to get total space needed\n        labelHorizontalSpace = Math.max(labelHorizontalSpace, Math.abs(offset.x) + maxLabelWidth / 2);\n        labelVerticalSpace = Math.max(labelVerticalSpace, Math.abs(offset.y) + textHeight / 2);\n      });\n    }\n\n    // Calculate actual cube width in pixels (fit within available width, up to MAX_CUBE_WIDTH)\n    const canvasWidth = width;\n    const availableWidth = canvasWidth - 2 * labelHorizontalSpace;\n    const cubeWidth = Math.min(MAX_CUBE_WIDTH, availableWidth / diagramWidth);\n\n    const canvasHeight = diagramHeight * cubeWidth + 2 * PADDING + 2 * labelVerticalSpace;\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Center offset (leave space for labels on both sides)\n    const offsetX = labelHorizontalSpace + (availableWidth - diagramWidth * cubeWidth) / 2 - bounds.minX * cubeWidth;\n    const offsetY = PADDING + labelVerticalSpace - bounds.minY * cubeWidth;\n\n    // Scale and translate projected vertices\n    const scaledVertices = projected.map(p => ({\n      x: p.x * cubeWidth + offsetX,\n      y: p.y * cubeWidth + offsetY,\n      label: p.label\n    }));\n\n    // Get theme colors\n    const mutedColor = api.getColor('muted-foreground');\n    const foregroundColor = api.getColor('foreground');\n\n    // Draw base edges\n    ctx.strokeStyle = mutedColor;\n    ctx.lineWidth = BASE_LINE_WIDTH;\n    const edges = generateEdges(vertices);\n    edges.forEach(([i, j]) => {\n      const v1 = scaledVertices[i];\n      const v2 = scaledVertices[j];\n      ctx.beginPath();\n      ctx.moveTo(v1.x, v1.y);\n      ctx.lineTo(v2.x, v2.y);\n      ctx.stroke();\n    });\n\n    // Draw vertices (before path lines so paths appear on top)\n    ctx.fillStyle = mutedColor;\n    scaledVertices.forEach(v => {\n      ctx.beginPath();\n      ctx.arc(v.x, v.y, VERTEX_RADIUS, 0, 2 * Math.PI);\n      ctx.fill();\n    });\n\n    // Draw path lines if provided (drawn on top of vertices)\n    if (paths && paths.length > 0) {\n      ctx.strokeStyle = foregroundColor;\n      ctx.lineWidth = PATH_LINE_WIDTH;\n\n      paths.forEach(path => {\n        for (let i = 0; i < path.length - 1; i++) {\n          const idx1 = vertices.findIndex(v => v.label === path[i]);\n          const idx2 = vertices.findIndex(v => v.label === path[i + 1]);\n          if (idx1 !== -1 && idx2 !== -1) {\n            const v1 = scaledVertices[idx1];\n            const v2 = scaledVertices[idx2];\n\n            // Draw the path line\n            ctx.lineWidth = PATH_LINE_WIDTH;\n            ctx.beginPath();\n            ctx.moveTo(v1.x, v1.y);\n            ctx.lineTo(v2.x, v2.y);\n            ctx.stroke();\n\n            // Draw arrowhead with center at midpoint\n            ctx.lineWidth = PATH_ARROW_LINE_WIDTH;\n            const midX = (v1.x + v2.x) / 2;\n            const midY = (v1.y + v2.y) / 2;\n\n            // Calculate direction angle\n            const angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);\n\n            // Calculate tip position (half arrowhead length forward from midpoint)\n            const tipX = midX + (ARROWHEAD_LENGTH / 2) * Math.cos(angle);\n            const tipY = midY + (ARROWHEAD_LENGTH / 2) * Math.sin(angle);\n\n            // Calculate base points (half arrowhead length backward from midpoint, spread by angle)\n            const arrow1X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle - ARROWHEAD_ANGLE);\n            const arrow1Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle - ARROWHEAD_ANGLE);\n            const arrow2X = midX - (ARROWHEAD_LENGTH / 2) * Math.cos(angle + ARROWHEAD_ANGLE);\n            const arrow2Y = midY - (ARROWHEAD_LENGTH / 2) * Math.sin(angle + ARROWHEAD_ANGLE);\n\n            ctx.beginPath();\n            ctx.moveTo(arrow1X, arrow1Y);\n            ctx.lineTo(tipX, tipY);\n            ctx.lineTo(arrow2X, arrow2Y);\n            ctx.stroke();\n\n            // Reset line width for next path segment\n            ctx.lineWidth = PATH_LINE_WIDTH;\n          }\n        }\n      });\n    }\n\n    // Draw labels if enabled\n    if (showLabels) {\n      ctx.fillStyle = foregroundColor;\n      ctx.font = '1rem ' + api.getFont('default');\n      ctx.textBaseline = 'middle';\n\n      scaledVertices.forEach(v => {\n        // Calculate label position with smart offset\n        const offset = calculateLabelOffset(v, cubeWidth);\n        ctx.textAlign = offset.align || 'center';\n        ctx.fillText(v.label, v.x + offset.x, v.y + offset.y);\n      });\n    }\n  }\n\n  // Generate vertices for n-dimensional hypercube\n  function generateVertices(n) {\n    const count = Math.pow(2, n);\n    const vertices = [];\n    for (let i = 0; i < count; i++) {\n      const coords = [];\n      const label = [];\n      for (let j = 0; j < n; j++) {\n        const bit = (i >> j) & 1;\n        coords.push(bit);\n        label.unshift(bit); // Reverse order for label\n      }\n      vertices.push({ coords, label: label.join('') });\n    }\n    return vertices;\n  }\n\n  // Project vertex to 2D using the specified projection\n  function projectVertex(vertex) {\n    const [x = 0, y = 0, z = 0, w = 0] = vertex.coords;\n    return {\n      x: x + Z_X_MULTIPLIER * z + W_X_MULTIPLIER * w,\n      y: y + Z_Y_MULTIPLIER * z + W_Y_MULTIPLIER * w,\n      label: vertex.label\n    };\n  }\n\n  // Calculate bounds of projected vertices\n  function calculateBounds(projected) {\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    projected.forEach(p => {\n      minX = Math.min(minX, p.x);\n      maxX = Math.max(maxX, p.x);\n      minY = Math.min(minY, p.y);\n      maxY = Math.max(maxY, p.y);\n    });\n    return { minX, maxX, minY, maxY };\n  }\n\n  // Generate edges (vertices that differ by exactly 1 bit)\n  function generateEdges(vertices) {\n    const edges = [];\n    for (let i = 0; i < vertices.length; i++) {\n      for (let j = i + 1; j < vertices.length; j++) {\n        const diff = vertices[i].coords.filter((val, idx) => val !== vertices[j].coords[idx]).length;\n        if (diff === 1) {\n          edges.push([i, j]);\n        }\n      }\n    }\n    return edges;\n  }\n\n  // Calculate smart label offset to avoid overlapping edges\n  function calculateLabelOffset(vertex, cubeWidth) {\n    // Label offset map based on dimensions and coordinates\n    const labelOffsets = {\n      1: {\n        '0': { x: 0, y: cubeWidth * 0.2, align: 'center' },\n        '1': { x: 0, y: cubeWidth * 0.2, align: 'center' },\n      },\n      2: {\n        '00': { x: -cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'right' },\n        '01': { x: cubeWidth * 0.1, y: -cubeWidth * 0.05, align: 'left' },\n        '10': { x: -cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'right' },\n        '11': { x: cubeWidth * 0.1, y: cubeWidth * 0.05, align: 'left' },\n      },\n      3: {\n        '000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\n        '010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\n        '100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\n        '101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\n        '110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\n        '111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\n      },\n      4: {\n        '0000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '0001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\n        '0010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '0011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\n        '0100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\n        '0101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\n        '0110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\n        '0111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\n        '1000': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '1001': { x: -cubeWidth * 0.05, y: cubeWidth * 0.15, align: 'right' },\n        '1010': { x: -cubeWidth * 0.1, y: 0, align: 'right' },\n        '1011': { x: cubeWidth * 0.15, y: 0, align: 'left' },\n        '1100': { x: -cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'right' },\n        '1101': { x: cubeWidth * 0.05, y: -cubeWidth * 0.1, align: 'left' },\n        '1110': { x: cubeWidth * 0.05, y: -cubeWidth * 0.10, align: 'left' },\n        '1111': { x: cubeWidth * 0.1, y: 0, align: 'left' },\n      }\n    };\n\n    const config = labelOffsets[dimensions]?.[vertex.label];\n    return config;\n  }\n\n  // Initial draw\n  drawCube();\n\n  // Redraw on theme change\n  api.onThemeChange(() => {\n    drawCube();\n  });\n\n  // Redraw on resize\n  api.onResize(() => {\n    drawCube();\n  });\n}","layout","<canvas id=\"hypercube-canvas\"></canvas>","startLine",189]
